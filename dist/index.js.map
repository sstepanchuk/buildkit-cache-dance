{"mappings":"A,U,M,I,A,W,M,I,A,W,M,M,A,W,M,M,A,W,M,O,A,W,M,K,A,W,M,K,A,W,M,Q,A,W,M,Q,A,W,M,M,A,W,M,a,A,W,M,e,E,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,ECAA,AAAA,CAAA,UAAA,OAAA,SAAA,AAAA,aAAA,OAAA,OACA,OAAA,OAAA,CAAA,EAEA,AAAA,YAAA,OAAA,QAAA,OAAA,GAAA,EACA,OAAA,WACA,OAAA,CAEA,EAGE,CAAkB,EAAA,CAAA,QAAA,CAAA,SAAc,CAAO,CAArB,CAAA,CAAA,CAAA,CAAA,CAAA,EAAsB,IAAA,EAAA,EAAA,kDAExC,EAAI,EAAS,MACX,EAAA,EAAA,MACA,EAAO,EAAG,cAAV,CAAA,GACF,EAAA,EAAA,qBAEA,EAAkB,EAAlB,sBACE,EAAA,EAAA,aACA,EAAA,EAAA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E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,A,Y,G,O,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,EA5EA,CACA,CACA,SAAA,EAAA,CAAA,M,CAEA,CAAA,EAAA,IAAA,CAAA,EAAA,EAAA,KAAA,EAAA,A,C,C,EAAA,EAAA,KAAA,Y,E,E,I,E,S,C,E,E,E,E,EAAA,IAAA,CAAA,EAAA,EACA,CAEA,EAAA,AAAA,CAAA,EAAA,EAAA,KAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAA,IAAA,GAaA,E,EAEG,OACH,cADG,CAAA,EAAA,aAAA,CACH,MAAY,CAAA,CACV,G,E,U,C,E,Q,C,E,S,C,E,K,C,E,Q,C,E,U,C,E,I,C,E,M,C,E,O,C,E,K,C,E,K,C,E,O,C,E,S,C,E,c,C,E,S,C,E,e,C,E,iB,C,E,Q,C,E,O,C,E,S,C,E,c,C,E,Q,C,K,EAEG,IAAA,EACH,EAAA,oBAEA,EAAA,EAAA,oB,E,E,oBAEG,EACH,EAAA,EAAA,oBATU,EAAA,EAAA,EAAA,qBAiDZ,EAAA,EAAA,mB,S,E,C,C,C,E,I,E,Q,G,C,C,M,E,E,O,C,K,K,W,G,C,C,E,GA6EA,GAAA,GAAgB,EAAA,QACF,EACZ,CAAA,EAHC,MAAA,AAAA,MAAA,CAAA,iCAAA,EAAA,EAAA,CAAA,SAKD,AAAA,GAAyB,AACtB,CAAA,IADsB,EAAA,cAAe,CAErC,EAEI,EAAP,IAAA,EACF,CA+GA,SAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,E,E,Y,C,Q,E,mB,C,G,a,M,E,Q,G,E,C,S,E,C,E,E,K,C,Q,E,C,S,IAmDE,EAAA,KAAW,CAAX,WAEA,CAjPF,C,EAKE,EAAM,EAAW,QAAQ,EAAI,CAAA,EAAA,QAA7B,CAAA,CAAA,CAAA,EALF,CAAA,EAAA,OAAA,CAAA,EAAA,CAAA,UAGE,CAAY,CAAA,EAAZ,OAAA,CAAA,EAAA,CAAA,UAyBA,EAAA,cAAiB,CA3BnB,SAAA,CAAA,CAAA,CAAA,EAcA,IAAA,EAAA,EAAA,cAAA,CAAA,GAIA,G,Q,G,C,E,C,E,Q,G,C,U,E,EAAgB,CACd,IAAA,EAAY,sCACd,EAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA,EAAA,EAAA,CAAA,CAFA,EAAA,YAAA,CAAA,MAAA,EAIA,MAAA,EAAA,YAAA,CAAA,UAAA,C,K,C,E,EAGG,E,E,S,CASH,SAAA,CAAA,EARA,EAAA,YAAA,CAAA,WAAA,CAAA,EAAA,EAUA,EAgBE,EAAI,OAAA,C,S,C,E,Q,G,C,W,C,E,Y,C,O,GAPN,EAAgB,YAAuB,CAAA,WADpC,CAAA,EAAA,GAED,QAAM,GAAA,CACJ,IAAA,CAAQ,CAAG,EAAC,EAAS,EAAA,EAAK,SAAQ,CAAM,EAAA,QAAK,GAAA,CAAA,IAAgB,CAAA,CAAA,AAC/D,EAmBF,EAAA,QAAA,CAAA,EAsBqB,EAAA,iBAAA,C,S,C,C,C,EADrB,O,E,E,G,K,C,M,M,C,A,G,A,K,EACE,EAqBF,EAAA,eAAA,CAlBE,SAAuB,CAAM,CAAA,CAA7B,EAeF,IAAgB,EAAA,EAAwB,EAAxC,GACE,GAAA,AAfe,CACf,OAIF,OAVA,OAYA,CAQgB,QAAO,CAAA,GAArB,MAAA,CAAA,EACA,GAAA,A,C,Q,Q,QAHF,CAGE,QAAa,CAAA,GAAA,MAAc,CAAA,CAAC,OAAA,AAAA,UAAA,CAAA,0DAAA,EAAA;AAAA,0EAAA,CAAA,CAAI,EAgBlC,EAAA,SAAA,CAPE,SAAK,CAAC,CAAA,CAAQ,EAChB,QAAA,MAAA,CAAA,KAAA,CAAA,EAAA,GAAA,EAFA,EAAA,YAAA,CAAA,aAAA,CAIA,KAAA,CACA,EAAA,EACA,EAOA,EAAA,cAAA,CACE,SAAmB,CAAS,EAE5B,EAAA,KAAA,CAAA,OAAA,EAAA,KAAA,MACF,E,E,S,CAWA,SAAA,CAAA,EAFA,QAAA,QAAA,CAAA,EAAA,OAAA,CAIA,EAAA,E,EAYG,EACH,OAAgB,C,W,M,A,M,Q,G,C,Y,A,E,E,K,CAWhB,SAAA,CAAA,E,E,Y,C,Q,C,E,E,E,E,K,C,EAmCG,EACH,OAAgB,CAJhB,SAAA,CAAA,CAAA,EAAA,CAAA,CAAA,E,E,Y,C,U,E,mB,C,G,a,M,E,Q,G,E,E,E,M,C,S,C,C,E,C,C,E,E,Y,C,S,E,mB,C,G,a,M,E,Q,G,E,E,E,I,CAiBA,SAAA,CAAA,EAFA,QAAA,MAAA,CAAA,KAAA,CAAA,EAAA,EAAA,GAAA,CAIA,E,E,U,C,EAoBE,EAAA,QAAA,CAAA,EAqB4B,EAAA,KAAA,CA1B9B,SAAA,CAAA,CAAA,CAAA,EAcA,OAAA,EAAA,IAAA,CAAA,KAAA,EAAA,KAAA,EAAA,gBAEA,EADA,EAAA,GAGA,GAAA,C,E,M,G,Q,C,G,CAMA,OAAA,CACA,EACE,EAcA,EAAA,SAAO,CAJP,SAAe,CAAI,CAAA,CAAA,EACrB,EAAA,YAAA,CAAA,aAAA,CAFA,KAAA,CAIA,EAAA,E,EAOQ,EAAA,QAAA,CAAR,SAAA,CAAA,EAAQ,OAAA,QAAA,GAAA,CAAA,CAAA,MAAA,EAAA,EAAA,CAAA,CAAA,EAAA,EAAA,EAIL,EACH,UAAA,CALQ,SAAA,CAAA,EAAO,OAAA,EAAA,IAAA,CAAA,KAAA,EAAA,KAAA,EAAA,YAAA,OAAA,MAAA,EAAA,UAAA,CAAA,UAAA,CAAA,EAEf,E,EAGQ,IAAA,EAAA,EAAA,oBAAA,OAAA,cAAA,CAAA,EAAA,UAAA,CAAe,WAAA,CAAA,EAAA,IAAA,W,O,E,O,A,C,G,I,E,E,oB,O,c,C,E,kB,C,W,C,E,I,W,O,E,e,A,C,E,E,C,iB,Q,mB,Q,mB,Q,kB,K,iB,O,kB,Q,iB,O,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,E,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,EElXvB,GAAA,GAAA,EAAA,UAAA,CAAA,OAAA,EACA,IAAA,EAAA,CAAA,EAWA,GAAA,AAAA,MAAA,E,I,I,K,E,A,Y,G,O,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,a,C,M,C,C,GASG,EACH,KAAgB,CAAA,EAAA,YAEd,CAAA,KAAA,EAGA,IAAA,EAAM,EAAU,EAAQ,qBACxB,EAAQ,EAAY,oBAelB,SAAK,EACH,CADF,CAAA,CAAA,CAAA,CAAA,EAIA,IAAA,EAAK,IAAO,EAAZ,EAAA,EAAA,GACA,QAAI,MAAC,CAAA,KAAU,CAAA,EAAf,QAAA,GAAA,EAAA,GAAA,CACA,CACF,EAAA,YAAA,CAAA,EAMI,EAAA,KAAA,CAJJ,SAAA,CAAA,CAAA,EAAA,EAAA,EACE,EAAI,EAAS,CAAA,EAAA,EAEb,CAGE,OAAA,EAEI,YAAA,CAAM,CAAA,CAAW,CAAA,CAAW,CAAA,CAC5B,AAAA,GAAI,CAAA,EAAJ,iBAAA,EACE,IAAA,CAAA,OAAA,CAAA,EAGE,IAAA,CAAA,UAAA,CAAA,EAGF,IAAA,CAAA,OAAA,CAAA,CACD,CACF,UAAA,K,E,EAEJ,IAAA,EAAA,AAfK,KAeL,IAAA,CAAA,OAAA,CAED,GAAA,IAAA,CAAA,UAAa,EAAA,OAAa,IAAA,CAAA,IAAW,CAAA,UAAY,EAAG,MAApD,CAAA,EAAA,CACA,GAAA,IACF,IAAA,EAAA,CAAA,EACD,IAAA,IAAA,KAAA,IAAA,CAAA,UAAA,CAAA,GAAA,IAAA,CAAA,UAAA,CAAA,cAAA,CAAA,GAAA,CAEQ,IAAT,EAAA,IAAA,CAAA,UAAA,CAAA,EAAA,CACS,IAIT,EAAA,EAAA,CAAA,EAE8B,GAA9B,IACS,GAAA,CAAA,EAAc,EAClB,CAAA,E,EAAc,E,E,c,C,G,O,C,K,O,O,C,M,O,O,C,M,O,O,C,K,O,O,C,K,OACd,CAAA,C,C,CEzFL,O,E,K,E,I,C,O,C,E,c,C,G,O,C,K,O,O,C,M,O,O,C,M,Q,AACA,C,CAYS,EAAA,CAAA,mBAAW,KAAA,mBAAsB,OAAA,EAAA,CAAA,MAAiB,CAAA,SAChD,CADF,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAHT,OAAA,cAAA,CAAA,EAAA,aAAA,CASA,MAAA,CAAA,C,G,E,mB,C,E,c,C,K,EAiBI,EAAA,cAAS,CARX,SAAiB,CAAA,SAIjB,AAAA,MAAA,EAAA,GACE,AAAO,UAAP,OAAO,GAAP,aAAA,OAAA,EACA,KAAM,SAAA,CAAA,EACN,E,E,mB,C,S,C,S,A,O,I,C,G,M,C,CEnCJ,MAAA,EAAA,KAAA,C,K,E,I,C,K,E,S,C,Q,E,O,C,I,E,W,C,U,E,S,A,E,C,C,C,E,C,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,E,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,EAEA,GAAA,GAAA,EAAA,UAAA,CAAA,OAAA,EACA,IAAA,EAAA,CAAA,EAGA,GAAA,AAAA,MAAA,EACA,IAAA,IAAA,KAAA,EAAA,AAAA,YAAA,GAAA,OAAA,cAAA,CAAA,IAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAIE,OADA,EAAiB,EAAQ,GACpB,CAKL,EAIA,OAAG,cAAc,CAAC,EAAA,aAAa,CAC7B,MAAA,CAAA,CACD,GACH,EAAA,YAAA,CAAA,KAAA,E,I,E,E,E,qB,E,E,E,qB,E,E,mB,C,E,Y,C,S,C,C,C,E,I,E,Q,G,C,C,O,E,E,C,C,C,G,C,E,M,A,M,C,qD,E,E,C,E,G,C,E,U,C,G,M,A,M,C,sB,E,E,C,E,E,c,C,E,C,E,E,c,C,G,E,E,G,C,C,C,C,S,M,E,C,E,C,mB,K,mB,K,iB,O,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,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,SAAA,OAAA,IAAA,CAAA,IAAA,CAAA,QAAA,CAAA,IAAA,IAAA,CAAA,QAAA,EAAA,QAAA,CAAA,SACI,CAEJ,wBAAA,CAAA,CAAA,CACA,MAAA,CAAA,CACA,CACI,qBAAgB,CAAA,CAAA,CAAmB,CAAA,CAAA,CAAY,CACnD,OAAA,IACA,CACA,EAoBI,EAAA,uBAAA,CAlBJ,MACA,YAAA,CAAA,CAAA,CACI,IAAA,CAAA,KAAA,CAAA,CACJ,CAGJ,eAAA,CAAA,CAAA,CACI,EAAY,OAAZ,CAAA,aAAA,CAAA,UAAA,IAAA,CAAA,KAAA,AACI,CAEJ,wBAAA,CAAA,CAAA,CACA,MAAA,CAAA,CACA,CACI,qBAAgB,CAAA,CAAA,CACZ,CAAA,CAAW,CAAA,CACnB,OAAA,IACA,CACA,E,E,oC,CAEA,MACA,YAAA,CAAA,CAAA,CACI,IAAA,CAAA,KAAA,CAAA,CACJ,C,e,C,C,C,E,O,C,a,C,S,O,I,C,O,I,C,K,E,Q,C,S,C,wB,C,C,C,M,C,C,C,qB,C,C,C,C,C,C,C,O,I,C,C,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,EEvDJ,CACA,CACO,SAAQ,EAAA,CAAY,M,CAEd,CAAA,EAAA,IAAe,CAAG,EAAlB,EAAA,KAAA,EAAA,A,C,C,EAAA,EAAA,KAAA,Y,E,E,I,E,S,C,E,E,E,E,EAAA,IAAA,CAAA,EAAA,EACA,CAgDb,EAAA,AAAA,CAAA,EAAA,EAAA,KAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAA,IAAA,GAIE,EACE,EACF,OAAA,cAAA,CAAA,EAAA,aAAA,CAEA,MAAA,CAAA,C,G,E,O,C,E,e,C,E,gB,C,E,e,C,K,E,I,E,E,oB,E,E,oBAKG,CACW,OAAA,CAAA,CAAA,WAAA,CADX,CAAA,UAAA,CAAA,CAAA,CAAA,EAAA,QAAA,A,C,E,e,C,sBAED,EAAA,gBAAS,CAAA,4GCjEb,IAAI,EAAa,IDqEb,MACA,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","sources":["<anon>","src/index.ts","src/inject-cache.ts","src/opts.ts","node_modules/.pnpm/mri@1.2.0/node_modules/mri/lib/index.mjs","node_modules/.pnpm/@parcel+transformer-js@2.15.1_@parcel+core@2.15.1_@swc+helpers@0.5.17_/node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/core.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/core.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/command.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/command.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/utils.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/utils.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/file-command.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/file-command.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/oidc-utils.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/oidc-utils.ts","node_modules/.pnpm/@actions+http-client@1.0.11/node_modules/@actions/http-client/index.js","node_modules/.pnpm/@actions+http-client@1.0.11/node_modules/@actions/http-client/proxy.js","node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js","node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js","node_modules/.pnpm/@actions+http-client@1.0.11/node_modules/@actions/http-client/auth.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/summary.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/summary.ts","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/main.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/argument.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/jsonArgument.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/comment.js","node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/line.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/util.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/parser.js","node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/umd/main.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/parserDirective.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/heredoc.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/variable.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/add.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/jsonInstruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/modifiableInstruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/flag.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/flagOption.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/arg.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/property.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/propertyInstruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/cmd.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/copy.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/env.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/entrypoint.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/from.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/healthcheck.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/label.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/onbuild.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/run.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/shell.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/stopsignal.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/workdir.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/user.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/volume.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/dockerfile.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/imageTemplate.js","src/logger.ts","src/run.ts","node_modules/.pnpm/spawn-please@3.0.0/node_modules/spawn-please/src/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js","node_modules/.pnpm/which@2.0.2/node_modules/which/which.js","node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js","node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js","node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js","node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js","node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js","node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js","src/extract-cache.ts"],"sourcesContent":["import * as __parcelExternal0 from \"fs\";\nimport * as __parcelExternal1 from \"os\";\nimport * as __parcelExternal2 from \"path\";\nimport * as __parcelExternal3 from \"http\";\nimport * as __parcelExternal4 from \"https\";\nimport * as __parcelExternal5 from \"net\";\nimport * as __parcelExternal6 from \"tls\";\nimport * as __parcelExternal7 from \"events\";\nimport * as __parcelExternal8 from \"assert\";\nimport * as __parcelExternal9 from \"util\";\nimport * as __parcelExternal10 from \"async_hooks\";\nimport * as __parcelExternal11 from \"child_process\";\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"7sz5b\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nvar _fs = require(\"fs\");\nvar _os = require(\"os\");\nvar _osDefault = parcelHelpers.interopDefault(_os);\nvar _injectCacheJs = require(\"./inject-cache.js\");\nvar _extractCacheJs = require(\"./extract-cache.js\");\nvar _optsJs = require(\"./opts.js\");\nvar _loggerJs = require(\"./logger.js\");\nasync function main(args) {\n    const opts = (0, _optsJs.parseOpts)(args);\n    (0, _loggerJs.configureLogger)({\n        verbose: opts.verbose\n    });\n    if (opts.help) {\n        (0, _loggerJs.logInfo)(\"Displaying help information...\");\n        return (0, _optsJs.help)();\n    }\n    if (opts.extract) {\n        // Run the post step\n        (0, _loggerJs.logInfo)(\"Starting cache extraction workflow...\");\n        await (0, _extractCacheJs.extractCaches)(opts);\n    } else {\n        // Otherwise, this is the main step\n        if (process.env.GITHUB_STATE !== undefined) await (0, _fs.promises).appendFile(process.env.GITHUB_STATE, `POST=true${(0, _osDefault.default).EOL}`);\n        (0, _loggerJs.logInfo)(\"Starting cache injection workflow...\");\n        await (0, _injectCacheJs.injectCaches)(opts);\n    }\n}\nmain(process.argv).catch((err)=>{\n    (0, _loggerJs.logError)(err instanceof Error ? err : String(err));\n    if (err instanceof Error && err.stack) (0, _loggerJs.logVerbose)(err.stack);\n    process.exit(1);\n});\n\n},{\"fs\":\"fs\",\"os\":\"os\",\"./inject-cache.js\":\"g8Odb\",\"./extract-cache.js\":\"14eXt\",\"./opts.js\":\"bjlzi\",\"./logger.js\":\"lnguQ\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"g8Odb\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"injectCaches\", ()=>injectCaches);\nvar _fs = require(\"fs\");\nvar _path = require(\"path\");\nvar _pathDefault = parcelHelpers.interopDefault(_path);\nvar _optsJs = require(\"./opts.js\");\nvar _runJs = require(\"./run.js\");\nvar _loggerJs = require(\"./logger.js\");\nfunction createJobId(cacheSource) {\n    const slug = cacheSource.replace(/^[\\\\/]+/, '').replace(/[\\\\/]+/g, '-').replace(/[^a-zA-Z0-9_.-]/g, '-').toLowerCase().slice(-40);\n    const unique = Math.random().toString(36).slice(2, 10);\n    return `${slug || 'cache'}-${unique}`;\n}\nasync function injectCache(cacheSource, cacheOptions, scratchDir, containerImage, builder) {\n    return await (0, _loggerJs.logGroup)(`Inject cache for ${cacheSource}`, async ()=>{\n        const jobId = createJobId(cacheSource);\n        const jobScratchDir = (0, _pathDefault.default).join(scratchDir, jobId);\n        const imageTag = `dance:inject-${jobId}`;\n        (0, _loggerJs.logInfo)(`Preparing cache injection for source '${cacheSource}' using builder '${builder}'.`);\n        await (0, _fs.promises).rm(jobScratchDir, {\n            recursive: true,\n            force: true\n        });\n        await (0, _fs.promises).mkdir(jobScratchDir, {\n            recursive: true\n        });\n        // Prepare Cache Source Directory\n        await (0, _fs.promises).mkdir(cacheSource, {\n            recursive: true\n        });\n        (0, _loggerJs.logVerbose)(`Working directory prepared at '${cacheSource}'.`);\n        // Prepare Timestamp for Layer Cache Busting\n        const date = new Date().toISOString();\n        await (0, _fs.promises).writeFile((0, _pathDefault.default).join(cacheSource, 'buildstamp'), date);\n        (0, _loggerJs.logVerbose)(`Build timestamp written for cache busting: ${date}.`);\n        const targetPath = (0, _optsJs.getTargetPath)(cacheOptions);\n        const mountArgs = (0, _optsJs.getMountArgsString)(cacheOptions);\n        // If UID OR GID are set, then add chown to restore files ownership.\n        let ownershipCommand = \"\";\n        const uid = (0, _optsJs.getUID)(cacheOptions);\n        const gid = (0, _optsJs.getGID)(cacheOptions);\n        if (uid !== \"\" || gid !== \"\") ownershipCommand = `&& chown -R ${uid}:${gid} ${targetPath}`;\n        // Prepare Dancefile to Access Caches\n        const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    --mount=type=bind,source=.,target=/var/dance-cache \\\n    cp -p -R /var/dance-cache/. ${targetPath} ${ownershipCommand} || true\n`;\n        (0, _loggerJs.logVerbose)(`Dancefile for injection generated:\\n${dancefileContent}`);\n        // Inject Data into Docker Cache\n        (0, _loggerJs.logInfo)(`Running docker buildx to inject cache for '${cacheSource}'.`);\n        await (0, _runJs.runWithInput)('docker', [\n            'buildx',\n            'build',\n            '--builder',\n            builder,\n            '-f',\n            '-',\n            '--tag',\n            imageTag,\n            cacheSource\n        ], dancefileContent);\n        // Clean Directories\n        try {\n            await (0, _fs.promises).rm(cacheSource, {\n                recursive: true,\n                force: true\n            });\n        } catch (err) {\n            // Ignore Cleaning Errors\n            (0, _loggerJs.logNotice)(`Error while cleaning cache source directory at '${cacheSource}': ${err}. Ignoring...`);\n        }\n        await (0, _fs.promises).rm(jobScratchDir, {\n            recursive: true,\n            force: true\n        });\n        (0, _loggerJs.logInfo)(`Cache injection completed for source '${cacheSource}'.`);\n    });\n}\nasync function injectCaches(opts) {\n    const cacheMap = await (0, _optsJs.getCacheMap)(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n    const builder = (0, _optsJs.getBuilder)(opts);\n    (0, _loggerJs.logInfo)(`Injecting ${Object.keys(cacheMap).length} cache mount(s) using image '${containerImage}'.`);\n    // Inject Caches for each source-target pair\n    const tasks = Object.entries(cacheMap).map(([cacheSource, cacheOptions])=>injectCache(cacheSource, cacheOptions, scratchDir, containerImage, builder).catch((error)=>{\n            (0, _loggerJs.logWarning)(`Cache injection failed for '${cacheSource}': ${error}`);\n            throw error;\n        }));\n    await Promise.all(tasks);\n}\n\n},{\"fs\":\"fs\",\"path\":\"path\",\"./opts.js\":\"bjlzi\",\"./run.js\":\"kHqLa\",\"./logger.js\":\"lnguQ\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"bjlzi\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"parseOpts\", ()=>parseOpts);\nparcelHelpers.export(exports, \"help\", ()=>help);\nparcelHelpers.export(exports, \"getCacheMap\", ()=>getCacheMap);\nparcelHelpers.export(exports, \"getTargetPath\", ()=>getTargetPath);\nparcelHelpers.export(exports, \"getUID\", ()=>getUID);\nparcelHelpers.export(exports, \"getGID\", ()=>getGID);\n/**\n * Convert a cache options to a string that is passed to --mount=\n * @param CacheOptions The cache options to convert to a string\n */ parcelHelpers.export(exports, \"getMountArgsString\", ()=>getMountArgsString);\nparcelHelpers.export(exports, \"getBuilder\", ()=>getBuilder);\nvar _mri = require(\"mri\");\nvar _mriDefault = parcelHelpers.interopDefault(_mri);\nvar _fs = require(\"fs\");\nvar _coreJs = require(\"@actions/core/lib/core.js\");\nvar _dockerfileAst = require(\"dockerfile-ast\");\nvar _loggerJs = require(\"./logger.js\");\nfunction parseOpts(args) {\n    const opts = (0, _mriDefault.default)(args, {\n        default: {\n            \"cache-map\": (0, _coreJs.getInput)(\"cache-map\") || \"{}\",\n            \"dockerfile\": (0, _coreJs.getInput)(\"dockerfile\") || \"Dockerfile\",\n            \"cache-dir\": (0, _coreJs.getInput)(\"cache-dir\") || null,\n            \"scratch-dir\": (0, _coreJs.getInput)(\"scratch-dir\") || \"scratch\",\n            \"skip-extraction\": ((0, _coreJs.getInput)(\"skip-extraction\") || \"false\") === \"true\",\n            \"extract\": process.env[`STATE_POST`] !== undefined,\n            \"utility-image\": (0, _coreJs.getInput)(\"utility-image\") || \"ghcr.io/containerd/busybox:latest\",\n            \"builder\": (0, _coreJs.getInput)(\"builder\") || \"default\",\n            \"verbose\": ((0, _coreJs.getInput)(\"verbose\") || \"false\") === \"true\",\n            \"help\": false\n        },\n        string: [\n            \"cache-map\",\n            \"dockerfile\",\n            \"cache-dir\",\n            \"scratch-dir\",\n            \"cache-source\",\n            \"cache-target\",\n            \"utility-image\",\n            \"builder\"\n        ],\n        boolean: [\n            \"skip-extraction\",\n            \"help\",\n            \"extract\",\n            \"verbose\"\n        ],\n        alias: {\n            \"help\": [\n                \"h\"\n            ]\n        }\n    });\n    if (opts[\"cache-source\"] && opts[\"cache-target\"]) {\n        (0, _coreJs.warning)(\"The `cache-source` and `cache-target` options are deprecated. Use `cache-map` instead.\");\n        opts[\"cache-map\"] = JSON.stringify({\n            [opts[\"cache-source\"]]: opts[\"cache-target\"]\n        });\n    }\n    return opts;\n}\nfunction help() {\n    console.log(`build-cache-dance [options]\nSave 'RUN --mount=type=cache' caches on GitHub Actions or other CI platforms\n\nOptions:\n  --extract      Extract the cache from the docker container (extract step). Otherwise, inject the cache (main step)\n  --cache-map    The map of actions source paths to container destination paths or mount arguments\n  --dockerfile   The Dockerfile to use for auto-discovery of the cache-map. Default: 'Dockerfile'\n  --cache-dir    The root directory where cache content is injected from/extracted to when using auto-discovery of the cache-map.\n  --scratch-dir  Where the action is stores some temporary files for its processing. Default: 'scratch'\n  --skip-extraction  Skip the extraction of the cache from the docker container\n  --utility-image  The container image to use for injecting and extracting the cache. Default: 'ghcr.io/containerd/busybox:latest'\n  --builder      The name of the buildx builder to use for the cache injection\n  --verbose      Enable verbose logging output\n  --help         Show this help\n`);\n}\nasync function getCacheMapFromDockerfile(dockerfilePath, bindRoot) {\n    const dockerfileContent = await (0, _fs.promises).readFile(dockerfilePath, \"utf-8\");\n    const dockerfile = (0, _dockerfileAst.DockerfileParser).parse(dockerfileContent);\n    const cacheMap = {};\n    const runInstructions = dockerfile.getInstructions().filter((i)=>i.getKeyword() == 'RUN');\n    for (const run of runInstructions){\n        for (const flag of run.getFlags())if (flag.getName() == 'mount' && flag.getOption('type')?.getValue() == 'cache') {\n            // Extract the `id` flag which defaults to `target` when `id` is not set\n            // https://docs.docker.com/reference/dockerfile/#run---mounttypecache\n            const id = flag.getOption('id')?.getValue() || flag.getOption('target')?.getValue();\n            if (id == null) throw new Error('cache mount must define id or target: ' + flag.toString() + ' in ' + run.toString());\n            // The directory on the host to inject/extract the cache mount data from\n            const bindDir = bindRoot !== null ? `${bindRoot}/${id}` : id;\n            // The target in this action does not matter as long as it is\n            // different than /var/dance-cache of course\n            const target = \"/var/cache-target\";\n            cacheMap[bindDir] = {\n                id,\n                target\n            };\n        }\n    }\n    return cacheMap;\n}\nasync function getCacheMap(opts) {\n    try {\n        const cacheMap = JSON.parse(opts[\"cache-map\"]);\n        if (Object.keys(cacheMap).length !== 0) return cacheMap;\n        (0, _loggerJs.logInfo)(`No cache map provided. Trying to parse the Dockerfile to find the cache mount instructions...`);\n        const cacheMapFromDockerfile = await getCacheMapFromDockerfile(opts[\"dockerfile\"], opts[\"cache-dir\"]);\n        (0, _loggerJs.logVerbose)(`Cache map parsed from Dockerfile: ${JSON.stringify(cacheMapFromDockerfile)}`);\n        return cacheMapFromDockerfile;\n    } catch (e) {\n        throw new Error(`Failed to parse cache map. Expected JSON, got:\\n${opts[\"cache-map\"]}\\n${e}`);\n    }\n}\nfunction getTargetPath(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return cacheOptions;\n    else {\n        // object is provided\n        if (\"target\" in cacheOptions) return cacheOptions.target;\n        else throw new Error(`Expected the 'target' key in the cache options, got:\\n${cacheOptions}`);\n    }\n}\nfunction getUID(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return \"\";\n    else {\n        // object is provided\n        if (\"uid\" in cacheOptions && cacheOptions.uid !== undefined) return cacheOptions.uid.toString();\n        else return \"\";\n    }\n}\nfunction getGID(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return \"\";\n    else {\n        // object is provided\n        if (\"gid\" in cacheOptions && cacheOptions.gid !== undefined) return cacheOptions.gid.toString();\n        else return \"\";\n    }\n}\nfunction getMountArgsString(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return `type=cache,target=${cacheOptions}`;\n    else {\n        // other options are provided\n        const otherOptions = Object.entries(cacheOptions).map(([key, value])=>`${key}=${value}`).join(\",\");\n        return `type=cache,${otherOptions}`;\n    }\n}\nfunction getBuilder(opts) {\n    return opts[\"builder\"] == null || opts[\"builder\"] == \"\" ? \"default\" : opts[\"builder\"];\n}\n\n},{\"mri\":\"5lGLa\",\"fs\":\"fs\",\"@actions/core/lib/core.js\":\"k7YnK\",\"dockerfile-ast\":\"1irbL\",\"./logger.js\":\"lnguQ\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"5lGLa\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>function(args, opts) {\n        args = args || [];\n        opts = opts || {};\n        var k, arr, arg, name, val, out = {\n            _: []\n        };\n        var i = 0, j = 0, idx = 0, len = args.length;\n        const alibi = opts.alias !== void 0;\n        const strict = opts.unknown !== void 0;\n        const defaults = opts.default !== void 0;\n        opts.alias = opts.alias || {};\n        opts.string = toArr(opts.string);\n        opts.boolean = toArr(opts.boolean);\n        if (alibi) for(k in opts.alias){\n            arr = opts.alias[k] = toArr(opts.alias[k]);\n            for(i = 0; i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);\n        }\n        for(i = opts.boolean.length; i-- > 0;){\n            arr = opts.alias[opts.boolean[i]] || [];\n            for(j = arr.length; j-- > 0;)opts.boolean.push(arr[j]);\n        }\n        for(i = opts.string.length; i-- > 0;){\n            arr = opts.alias[opts.string[i]] || [];\n            for(j = arr.length; j-- > 0;)opts.string.push(arr[j]);\n        }\n        if (defaults) for(k in opts.default){\n            name = typeof opts.default[k];\n            arr = opts.alias[k] = opts.alias[k] || [];\n            if (opts[name] !== void 0) {\n                opts[name].push(k);\n                for(i = 0; i < arr.length; i++)opts[name].push(arr[i]);\n            }\n        }\n        const keys = strict ? Object.keys(opts.alias) : [];\n        for(i = 0; i < len; i++){\n            arg = args[i];\n            if (arg === '--') {\n                out._ = out._.concat(args.slice(++i));\n                break;\n            }\n            for(j = 0; j < arg.length; j++){\n                if (arg.charCodeAt(j) !== 45) break; // \"-\"\n            }\n            if (j === 0) out._.push(arg);\n            else if (arg.substring(j, j + 3) === 'no-') {\n                name = arg.substring(j + 3);\n                if (strict && !~keys.indexOf(name)) return opts.unknown(arg);\n                out[name] = false;\n            } else {\n                for(idx = j + 1; idx < arg.length; idx++){\n                    if (arg.charCodeAt(idx) === 61) break; // \"=\"\n                }\n                name = arg.substring(j, idx);\n                val = arg.substring(++idx) || i + 1 === len || ('' + args[i + 1]).charCodeAt(0) === 45 || args[++i];\n                arr = j === 2 ? [\n                    name\n                ] : name;\n                for(idx = 0; idx < arr.length; idx++){\n                    name = arr[idx];\n                    if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);\n                    toVal(out, name, idx + 1 < arr.length || val, opts);\n                }\n            }\n        }\n        if (defaults) {\n            for(k in opts.default)if (out[k] === void 0) out[k] = opts.default[k];\n        }\n        if (alibi) for(k in out){\n            arr = opts.alias[k] || [];\n            while(arr.length > 0)out[arr.shift()] = out[k];\n        }\n        return out;\n    });\nfunction toArr(any) {\n    return any == null ? [] : Array.isArray(any) ? any : [\n        any\n    ];\n}\nfunction toVal(out, key, val, opts) {\n    var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? '' : String(val) : typeof val === 'boolean' ? val : !!~opts.boolean.indexOf(key) ? val === 'false' ? false : val === 'true' || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;\n    out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [\n        old,\n        nxt\n    ];\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"8h9S8\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"k7YnK\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"e924a1cef16bef69\");\nconst file_command_1 = require(\"16e43487988cdce8\");\nconst utils_1 = require(\"7f8c194a8c8f18e8\");\nconst os = __importStar(require(\"92b8860262e27ba\"));\nconst path = __importStar(require(\"d28a375bd89b68cf\"));\nconst oidc_utils_1 = require(\"7e9da61c1748be9\");\n/**\n * The code to exit an action\n */ var ExitCode;\n(function(ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */ ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */ ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    } else command_1.issueCommand('set-env', {\n        name\n    }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */ function setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */ function addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) file_command_1.issueCommand('PATH', inputPath);\n    else command_1.issueCommand('add-path', {}, inputPath);\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */ function getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);\n    if (options && options.trimWhitespace === false) return val;\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */ function getMultilineInput(name, options) {\n    const inputs = getInput(name, options).split('\\n').filter((x)=>x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */ function getBooleanInput(name, options) {\n    const trueValue = [\n        'true',\n        'True',\n        'TRUE'\n    ];\n    const falseValue = [\n        'false',\n        'False',\n        'FALSE'\n    ];\n    const val = getInput(name, options);\n    if (trueValue.includes(val)) return true;\n    if (falseValue.includes(val)) return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` + `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', {\n        name\n    }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */ function setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */ function setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */ function isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */ function debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */ function error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */ function warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */ function notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */ function info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */ function startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */ function endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */ function group(name, fn) {\n    return __awaiter(this, void 0, void 0, function*() {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        } finally{\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', {\n        name\n    }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */ function getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */ var summary_1 = require(\"e44daa22e4d4d53e\");\nObject.defineProperty(exports, \"summary\", {\n    enumerable: true,\n    get: function() {\n        return summary_1.summary;\n    }\n});\n/**\n * @deprecated use core.summary\n */ var summary_2 = require(\"e44daa22e4d4d53e\");\nObject.defineProperty(exports, \"markdownSummary\", {\n    enumerable: true,\n    get: function() {\n        return summary_2.markdownSummary;\n    }\n});\n\n},{\"e924a1cef16bef69\":\"kZGXI\",\"16e43487988cdce8\":\"gRxw7\",\"7f8c194a8c8f18e8\":\"bO0ir\",\"92b8860262e27ba\":\"os\",\"d28a375bd89b68cf\":\"path\",\"7e9da61c1748be9\":\"b9uNA\",\"e44daa22e4d4d53e\":\"7Zbhg\"}],\"kZGXI\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"3737725acaa42483\"));\nconst utils_1 = require(\"69b2ffcef1696d24\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */ function issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message){\n        if (!command) command = 'missing.command';\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for(const key in this.properties)if (this.properties.hasOwnProperty(key)) {\n                const val = this.properties[key];\n                if (val) {\n                    if (first) first = false;\n                    else cmdStr += ',';\n                    cmdStr += `${key}=${escapeProperty(val)}`;\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A').replace(/:/g, '%3A').replace(/,/g, '%2C');\n}\n\n},{\"3737725acaa42483\":\"os\",\"69b2ffcef1696d24\":\"bO0ir\"}],\"bO0ir\":[function(require,module,exports,__globalThis) {\n\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */ Object.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */ function toCommandValue(input) {\n    if (input === null || input === undefined) return '';\n    else if (typeof input === 'string' || input instanceof String) return input;\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */ function toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) return {};\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n\n},{}],\"gRxw7\":[function(require,module,exports,__globalThis) {\n\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */ const fs = __importStar(require(\"778c221d6defca47\"));\nconst os = __importStar(require(\"9ee56551f05bb7a0\"));\nconst utils_1 = require(\"a1dde01443f9a1e6\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);\n    if (!fs.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n\n},{\"778c221d6defca47\":\"fs\",\"9ee56551f05bb7a0\":\"os\",\"a1dde01443f9a1e6\":\"bO0ir\"}],\"b9uNA\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"6cdaf1fd914e5387\");\nconst auth_1 = require(\"8db37dcf5a5b1463\");\nconst core_1 = require(\"1147ffd9ee1d6042\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [\n            new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())\n        ], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient.getJson(id_token_url).catch((error)=>{\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) throw new Error('Response json body do not have ID Token field');\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            } catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n\n},{\"6cdaf1fd914e5387\":\"bTnEL\",\"8db37dcf5a5b1463\":\"lQXpe\",\"1147ffd9ee1d6042\":\"k7YnK\"}],\"bTnEL\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nconst http = require(\"69cee5eb1e6c891e\");\nconst https = require(\"5135743cad10c017\");\nconst pm = require(\"74ceafcf2537bb1e\");\nlet tunnel;\nvar HttpCodes;\n(function(HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function(Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function(MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */ function getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = [\n    'OPTIONS',\n    'GET',\n    'DELETE',\n    'HEAD'\n];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode){\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message){\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject)=>{\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk)=>{\n                output = Buffer.concat([\n                    output,\n                    chunk\n                ]);\n            });\n            this.message.on('end', ()=>{\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions){\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;\n            if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;\n            if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;\n            if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */ async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */ async request(verb, requestUrl, data, headers) {\n        if (this._disposed) throw new Error('Client has already been disposed.');\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;\n        let numTries = 0;\n        let response;\n        while(numTries < maxTries){\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for(let i = 0; i < this.handlers.length; i++)if (this.handlers[i].canHandleAuthentication(response)) {\n                    authenticationHandler = this.handlers[i];\n                    break;\n                }\n                if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info, data);\n                else // We have received an unauthorized response but have no handlers to handle it.\n                // Let the response return to the caller.\n                return response;\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while(HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0){\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) break;\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for(let header in headers)// header names are case insensitive\n                    if (header.toLowerCase() === 'authorization') delete headers[header];\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) // If not a retry code, return immediately instead of retrying\n            return response;\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */ dispose() {\n        if (this._agent) this._agent.destroy();\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */ requestRaw(info, data) {\n        return new Promise((resolve, reject)=>{\n            let callbackForResult = function(err, res) {\n                if (err) reject(err);\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */ requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        let callbackCalled = false;\n        let handleResult = (err, res)=>{\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg)=>{\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', (sock)=>{\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 180000, ()=>{\n            if (socket) socket.end();\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function(err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') req.write(data, 'utf8');\n        if (data && typeof data !== 'string') {\n            data.on('close', function() {\n                req.end();\n            });\n            data.pipe(req);\n        } else req.end();\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */ getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;\n        info.options.path = (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) info.options.headers['user-agent'] = this.userAgent;\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) this.handlers.forEach((handler)=>{\n            handler.prepareRequest(info.options);\n        });\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = (obj)=>Object.keys(obj).reduce((c, k)=>(c[k.toLowerCase()] = obj[k], c), {});\n        if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = (obj)=>Object.keys(obj).reduce((c, k)=>(c[k.toLowerCase()] = obj[k], c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) agent = this._proxyAgent;\n        if (this._keepAlive && !useProxy) agent = this._agent;\n        // if agent is already assigned use that agent.\n        if (!!agent) return agent;\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) tunnel = require(\"591dff9a34bef599\");\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...(proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    },\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = {\n                keepAlive: this._keepAlive,\n                maxSockets: maxSockets\n            };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) agent = usingSsl ? https.globalAgent : http.globalAgent;\n        if (usingSsl && this._ignoreSslError) // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n        // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n        // we have to cast it to any and change it directly\n        agent.options = Object.assign(agent.options || {}, {\n            rejectUnauthorized: false\n        });\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise((resolve)=>setTimeout(()=>resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) return a;\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject)=>{\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) resolve(response);\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    else obj = JSON.parse(contents);\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            } catch (err) {\n            // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) msg = obj.message;\n                else if (contents && contents.length > 0) // it may be the case that the exception is in the body message as string\n                msg = contents;\n                else msg = 'Failed request: (' + statusCode + ')';\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            } else resolve(response);\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n\n},{\"69cee5eb1e6c891e\":\"http\",\"5135743cad10c017\":\"https\",\"74ceafcf2537bb1e\":\"jyPkM\",\"591dff9a34bef599\":\"fHNgG\"}],\"jyPkM\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) return proxyUrl;\n    let proxyVar;\n    if (usingSsl) proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    else proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    if (proxyVar) proxyUrl = new URL(proxyVar);\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) return false;\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) return false;\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) reqPort = Number(reqUrl.port);\n    else if (reqUrl.protocol === 'http:') reqPort = 80;\n    else if (reqUrl.protocol === 'https:') reqPort = 443;\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [\n        reqUrl.hostname.toUpperCase()\n    ];\n    if (typeof reqPort === 'number') upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy.split(',').map((x)=>x.trim().toUpperCase()).filter((x)=>x)){\n        if (upperReqHosts.some((x)=>x === upperNoProxyItem)) return true;\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n\n},{}],\"fHNgG\":[function(require,module,exports,__globalThis) {\nmodule.exports = require(\"4930519cb3dd45a3\");\n\n},{\"4930519cb3dd45a3\":\"Z7Qtc\"}],\"Z7Qtc\":[function(require,module,exports,__globalThis) {\n'use strict';\nvar net = require(\"5121e3e37efd6d5e\");\nvar tls = require(\"2f892df2fa9f0920\");\nvar http = require(\"d8f61135d445c2eb\");\nvar https = require(\"4422f117af5fb5c5\");\nvar events = require(\"2bf2dc2e245634a1\");\nvar assert = require(\"d682d38a2480f4c\");\nvar util = require(\"8150fd083365f338\");\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\nfunction httpOverHttp(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = http.request;\n    return agent;\n}\nfunction httpsOverHttp(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = http.request;\n    agent.createSocket = createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}\nfunction httpOverHttps(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = https.request;\n    return agent;\n}\nfunction httpsOverHttps(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = https.request;\n    agent.createSocket = createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}\nfunction TunnelingAgent(options) {\n    var self = this;\n    self.options = options || {};\n    self.proxyOptions = self.options.proxy || {};\n    self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n    self.requests = [];\n    self.sockets = [];\n    self.on('free', function onFree(socket, host, port, localAddress) {\n        var options = toOptions(host, port, localAddress);\n        for(var i = 0, len = self.requests.length; i < len; ++i){\n            var pending = self.requests[i];\n            if (pending.host === options.host && pending.port === options.port) {\n                // Detect the request to connect same origin server,\n                // reuse the connection.\n                self.requests.splice(i, 1);\n                pending.request.onSocket(socket);\n                return;\n            }\n        }\n        socket.destroy();\n        self.removeSocket(socket);\n    });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n    var self = this;\n    var options = mergeOptions({\n        request: req\n    }, self.options, toOptions(host, port, localAddress));\n    if (self.sockets.length >= this.maxSockets) {\n        // We are over limit so we'll add it to the queue.\n        self.requests.push(options);\n        return;\n    }\n    // If we are under maxSockets create a new one.\n    self.createSocket(options, function(socket) {\n        socket.on('free', onFree);\n        socket.on('close', onCloseOrRemove);\n        socket.on('agentRemove', onCloseOrRemove);\n        req.onSocket(socket);\n        function onFree() {\n            self.emit('free', socket, options);\n        }\n        function onCloseOrRemove(err) {\n            self.removeSocket(socket);\n            socket.removeListener('free', onFree);\n            socket.removeListener('close', onCloseOrRemove);\n            socket.removeListener('agentRemove', onCloseOrRemove);\n        }\n    });\n};\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n    var self = this;\n    var placeholder = {};\n    self.sockets.push(placeholder);\n    var connectOptions = mergeOptions({}, self.proxyOptions, {\n        method: 'CONNECT',\n        path: options.host + ':' + options.port,\n        agent: false,\n        headers: {\n            host: options.host + ':' + options.port\n        }\n    });\n    if (options.localAddress) connectOptions.localAddress = options.localAddress;\n    if (connectOptions.proxyAuth) {\n        connectOptions.headers = connectOptions.headers || {};\n        connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');\n    }\n    debug('making CONNECT request');\n    var connectReq = self.request(connectOptions);\n    connectReq.useChunkedEncodingByDefault = false; // for v0.6\n    connectReq.once('response', onResponse); // for v0.6\n    connectReq.once('upgrade', onUpgrade); // for v0.6\n    connectReq.once('connect', onConnect); // for v0.7 or later\n    connectReq.once('error', onError);\n    connectReq.end();\n    function onResponse(res) {\n        // Very hacky. This is necessary to avoid http-parser leaks.\n        res.upgrade = true;\n    }\n    function onUpgrade(res, socket, head) {\n        // Hacky.\n        process.nextTick(function() {\n            onConnect(res, socket, head);\n        });\n    }\n    function onConnect(res, socket, head) {\n        connectReq.removeAllListeners();\n        socket.removeAllListeners();\n        if (res.statusCode !== 200) {\n            debug('tunneling socket could not be established, statusCode=%d', res.statusCode);\n            socket.destroy();\n            var error = new Error(\"tunneling socket could not be established, statusCode=\" + res.statusCode);\n            error.code = 'ECONNRESET';\n            options.request.emit('error', error);\n            self.removeSocket(placeholder);\n            return;\n        }\n        if (head.length > 0) {\n            debug('got illegal response body from proxy');\n            socket.destroy();\n            var error = new Error('got illegal response body from proxy');\n            error.code = 'ECONNRESET';\n            options.request.emit('error', error);\n            self.removeSocket(placeholder);\n            return;\n        }\n        debug('tunneling connection has established');\n        self.sockets[self.sockets.indexOf(placeholder)] = socket;\n        return cb(socket);\n    }\n    function onError(cause) {\n        connectReq.removeAllListeners();\n        debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack);\n        var error = new Error(\"tunneling socket could not be established, cause=\" + cause.message);\n        error.code = 'ECONNRESET';\n        options.request.emit('error', error);\n        self.removeSocket(placeholder);\n    }\n};\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n    var pos = this.sockets.indexOf(socket);\n    if (pos === -1) return;\n    this.sockets.splice(pos, 1);\n    var pending = this.requests.shift();\n    if (pending) // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n        pending.request.onSocket(socket);\n    });\n};\nfunction createSecureSocket(options, cb) {\n    var self = this;\n    TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n        var hostHeader = options.request.getHeader('host');\n        var tlsOptions = mergeOptions({}, self.options, {\n            socket: socket,\n            servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n        });\n        // 0 is dummy port for v0.6\n        var secureSocket = tls.connect(0, tlsOptions);\n        self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n        cb(secureSocket);\n    });\n}\nfunction toOptions(host, port, localAddress) {\n    if (typeof host === 'string') return {\n        host: host,\n        port: port,\n        localAddress: localAddress\n    };\n    return host; // for v0.11 or later\n}\nfunction mergeOptions(target) {\n    for(var i = 1, len = arguments.length; i < len; ++i){\n        var overrides = arguments[i];\n        if (typeof overrides === 'object') {\n            var keys = Object.keys(overrides);\n            for(var j = 0, keyLen = keys.length; j < keyLen; ++j){\n                var k = keys[j];\n                if (overrides[k] !== undefined) target[k] = overrides[k];\n            }\n        }\n    }\n    return target;\n}\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') args[0] = 'TUNNEL: ' + args[0];\n    else args.unshift('TUNNEL:');\n    console.error.apply(console, args);\n};\nelse debug = function() {};\nexports.debug = debug; // for test\n\n},{\"5121e3e37efd6d5e\":\"net\",\"2f892df2fa9f0920\":\"tls\",\"d8f61135d445c2eb\":\"http\",\"4422f117af5fb5c5\":\"https\",\"2bf2dc2e245634a1\":\"events\",\"d682d38a2480f4c\":\"assert\",\"8150fd083365f338\":\"util\"}],\"lQXpe\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nclass BasicCredentialHandler {\n    constructor(username, password){\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Basic ' + Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token){\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token){\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n\n},{}],\"7Zbhg\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"883cae28f50a90e7\");\nconst fs_1 = require(\"d52c794fdbfabbb1\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor(){\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */ filePath() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._filePath) return this._filePath;\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            } catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */ wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs).map(([key, value])=>` ${key}=\"${value}\"`).join('');\n        if (!content) return `<${tag}${htmlAttrs}>`;\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */ write(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, {\n                encoding: 'utf8'\n            });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */ clear() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.emptyBuffer().write({\n                overwrite: true\n            });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */ stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */ isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */ emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */ addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */ addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */ addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, lang && {\n            lang\n        });\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */ addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map((item)=>this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */ addTable(rows) {\n        const tableBody = rows.map((row)=>{\n            const cells = row.map((cell)=>{\n                if (typeof cell === 'string') return this.wrap('td', cell);\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, colspan && {\n                    colspan\n                }), rowspan && {\n                    rowspan\n                });\n                return this.wrap(tag, data, attrs);\n            }).join('');\n            return this.wrap('tr', cells);\n        }).join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */ addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */ addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, width && {\n            width\n        }), height && {\n            height\n        });\n        const element = this.wrap('img', null, Object.assign({\n            src,\n            alt\n        }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */ addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = [\n            'h1',\n            'h2',\n            'h3',\n            'h4',\n            'h5',\n            'h6'\n        ].includes(tag) ? tag : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */ addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */ addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */ addQuote(text, cite) {\n        const attrs = Object.assign({}, cite && {\n            cite\n        });\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */ addLink(text, href) {\n        const element = this.wrap('a', text, {\n            href\n        });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */ exports.markdownSummary = _summary;\nexports.summary = _summary;\n\n},{\"883cae28f50a90e7\":\"os\",\"d52c794fdbfabbb1\":\"fs\"}],\"1irbL\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DockerfileParser = exports.DefaultVariables = exports.Directive = exports.Keyword = exports.Workdir = exports.Volume = exports.User = exports.Stopsignal = exports.Shell = exports.Run = exports.PropertyInstruction = exports.Onbuild = exports.ModifiableInstruction = exports.Label = exports.JSONInstruction = exports.Heredoc = exports.Healthcheck = exports.From = exports.Env = exports.Entrypoint = exports.Copy = exports.Cmd = exports.Arg = exports.Add = exports.Variable = exports.Property = exports.ParserDirective = exports.Line = exports.Instruction = exports.Flag = exports.Comment = exports.JSONArgument = exports.Argument = void 0;\nvar argument_1 = require(\"818c00e38db4fcf4\");\nObject.defineProperty(exports, \"Argument\", {\n    enumerable: true,\n    get: function() {\n        return argument_1.Argument;\n    }\n});\nvar jsonArgument_1 = require(\"c08f7534e96127a6\");\nObject.defineProperty(exports, \"JSONArgument\", {\n    enumerable: true,\n    get: function() {\n        return jsonArgument_1.JSONArgument;\n    }\n});\nconst comment_1 = require(\"1222b947cf52db6a\");\nObject.defineProperty(exports, \"Comment\", {\n    enumerable: true,\n    get: function() {\n        return comment_1.Comment;\n    }\n});\nconst parser_1 = require(\"76bd4faa688b3a6\");\nvar flag_1 = require(\"146dd26c02688bdf\");\nObject.defineProperty(exports, \"Flag\", {\n    enumerable: true,\n    get: function() {\n        return flag_1.Flag;\n    }\n});\nconst instruction_1 = require(\"580224f94f990f62\");\nObject.defineProperty(exports, \"Instruction\", {\n    enumerable: true,\n    get: function() {\n        return instruction_1.Instruction;\n    }\n});\nvar line_1 = require(\"b10e9f8eeb123952\");\nObject.defineProperty(exports, \"Line\", {\n    enumerable: true,\n    get: function() {\n        return line_1.Line;\n    }\n});\nconst parserDirective_1 = require(\"48560c9781a127f2\");\nObject.defineProperty(exports, \"ParserDirective\", {\n    enumerable: true,\n    get: function() {\n        return parserDirective_1.ParserDirective;\n    }\n});\nvar property_1 = require(\"32b923ba03725fba\");\nObject.defineProperty(exports, \"Property\", {\n    enumerable: true,\n    get: function() {\n        return property_1.Property;\n    }\n});\nvar variable_1 = require(\"38f5b7215a951c16\");\nObject.defineProperty(exports, \"Variable\", {\n    enumerable: true,\n    get: function() {\n        return variable_1.Variable;\n    }\n});\nvar add_1 = require(\"46fe02f5a4ca95f9\");\nObject.defineProperty(exports, \"Add\", {\n    enumerable: true,\n    get: function() {\n        return add_1.Add;\n    }\n});\nconst arg_1 = require(\"b50e6043532127e\");\nObject.defineProperty(exports, \"Arg\", {\n    enumerable: true,\n    get: function() {\n        return arg_1.Arg;\n    }\n});\nconst cmd_1 = require(\"6151c2d28c8d5622\");\nObject.defineProperty(exports, \"Cmd\", {\n    enumerable: true,\n    get: function() {\n        return cmd_1.Cmd;\n    }\n});\nconst copy_1 = require(\"302e65a20d20846c\");\nObject.defineProperty(exports, \"Copy\", {\n    enumerable: true,\n    get: function() {\n        return copy_1.Copy;\n    }\n});\nconst entrypoint_1 = require(\"3b8f9736d90d33e6\");\nObject.defineProperty(exports, \"Entrypoint\", {\n    enumerable: true,\n    get: function() {\n        return entrypoint_1.Entrypoint;\n    }\n});\nconst env_1 = require(\"73053c83e5457e82\");\nObject.defineProperty(exports, \"Env\", {\n    enumerable: true,\n    get: function() {\n        return env_1.Env;\n    }\n});\nconst from_1 = require(\"fb70244a02539db4\");\nObject.defineProperty(exports, \"From\", {\n    enumerable: true,\n    get: function() {\n        return from_1.From;\n    }\n});\nconst healthcheck_1 = require(\"ce38775557f57e2\");\nObject.defineProperty(exports, \"Healthcheck\", {\n    enumerable: true,\n    get: function() {\n        return healthcheck_1.Healthcheck;\n    }\n});\nvar heredoc_1 = require(\"3fc29578d4056add\");\nObject.defineProperty(exports, \"Heredoc\", {\n    enumerable: true,\n    get: function() {\n        return heredoc_1.Heredoc;\n    }\n});\nvar jsonInstruction_1 = require(\"110dc2f32a5a5c80\");\nObject.defineProperty(exports, \"JSONInstruction\", {\n    enumerable: true,\n    get: function() {\n        return jsonInstruction_1.JSONInstruction;\n    }\n});\nvar label_1 = require(\"ea70ab055c82b9c6\");\nObject.defineProperty(exports, \"Label\", {\n    enumerable: true,\n    get: function() {\n        return label_1.Label;\n    }\n});\nvar modifiableInstruction_1 = require(\"c1e4a9f72f3e4c8a\");\nObject.defineProperty(exports, \"ModifiableInstruction\", {\n    enumerable: true,\n    get: function() {\n        return modifiableInstruction_1.ModifiableInstruction;\n    }\n});\nvar onbuild_1 = require(\"1eb1f87000f1507b\");\nObject.defineProperty(exports, \"Onbuild\", {\n    enumerable: true,\n    get: function() {\n        return onbuild_1.Onbuild;\n    }\n});\nvar propertyInstruction_1 = require(\"f04eacef530f3101\");\nObject.defineProperty(exports, \"PropertyInstruction\", {\n    enumerable: true,\n    get: function() {\n        return propertyInstruction_1.PropertyInstruction;\n    }\n});\nvar run_1 = require(\"efc72f3780a14232\");\nObject.defineProperty(exports, \"Run\", {\n    enumerable: true,\n    get: function() {\n        return run_1.Run;\n    }\n});\nvar shell_1 = require(\"bb2b3970bd5df961\");\nObject.defineProperty(exports, \"Shell\", {\n    enumerable: true,\n    get: function() {\n        return shell_1.Shell;\n    }\n});\nvar stopsignal_1 = require(\"3f106ce05bb305c2\");\nObject.defineProperty(exports, \"Stopsignal\", {\n    enumerable: true,\n    get: function() {\n        return stopsignal_1.Stopsignal;\n    }\n});\nvar user_1 = require(\"26177b9c0e662cb0\");\nObject.defineProperty(exports, \"User\", {\n    enumerable: true,\n    get: function() {\n        return user_1.User;\n    }\n});\nvar volume_1 = require(\"657db89678e27c44\");\nObject.defineProperty(exports, \"Volume\", {\n    enumerable: true,\n    get: function() {\n        return volume_1.Volume;\n    }\n});\nconst workdir_1 = require(\"7c097a1fe36e1e9e\");\nObject.defineProperty(exports, \"Workdir\", {\n    enumerable: true,\n    get: function() {\n        return workdir_1.Workdir;\n    }\n});\nvar Keyword;\n(function(Keyword) {\n    Keyword[\"ADD\"] = \"ADD\";\n    Keyword[\"ARG\"] = \"ARG\";\n    Keyword[\"CMD\"] = \"CMD\";\n    Keyword[\"COPY\"] = \"COPY\";\n    Keyword[\"ENTRYPOINT\"] = \"ENTRYPOINT\";\n    Keyword[\"ENV\"] = \"ENV\";\n    Keyword[\"EXPOSE\"] = \"EXPOSE\";\n    Keyword[\"FROM\"] = \"FROM\";\n    Keyword[\"HEALTHCHECK\"] = \"HEALTHCHECK\";\n    Keyword[\"LABEL\"] = \"LABEL\";\n    Keyword[\"MAINTAINER\"] = \"MAINTAINER\";\n    Keyword[\"ONBUILD\"] = \"ONBUILD\";\n    Keyword[\"RUN\"] = \"RUN\";\n    Keyword[\"SHELL\"] = \"SHELL\";\n    Keyword[\"STOPSIGNAL\"] = \"STOPSIGNAL\";\n    Keyword[\"USER\"] = \"USER\";\n    Keyword[\"VOLUME\"] = \"VOLUME\";\n    Keyword[\"WORKDIR\"] = \"WORKDIR\";\n})(Keyword || (exports.Keyword = Keyword = {}));\nvar Directive;\n(function(Directive) {\n    Directive[\"escape\"] = \"escape\";\n    Directive[\"syntax\"] = \"syntax\";\n})(Directive || (exports.Directive = Directive = {}));\nexports.DefaultVariables = [\n    \"ALL_PROXY\",\n    \"all_proxy\",\n    \"FTP_PROXY\",\n    \"ftp_proxy\",\n    \"HTTP_PROXY\",\n    \"http_proxy\",\n    \"HTTPS_PROXY\",\n    \"https_proxy\",\n    \"NO_PROXY\",\n    \"no_proxy\"\n];\nvar DockerfileParser;\n(function(DockerfileParser) {\n    function parse(content) {\n        let parser = new parser_1.Parser();\n        return parser.parse(content);\n    }\n    DockerfileParser.parse = parse;\n})(DockerfileParser || (exports.DockerfileParser = DockerfileParser = {}));\n\n},{\"818c00e38db4fcf4\":\"j0TZA\",\"c08f7534e96127a6\":\"58ALy\",\"1222b947cf52db6a\":\"5T0KS\",\"76bd4faa688b3a6\":\"aGQ73\",\"146dd26c02688bdf\":\"2WqAd\",\"580224f94f990f62\":\"hMvuU\",\"b10e9f8eeb123952\":\"jax2A\",\"48560c9781a127f2\":\"jIw2h\",\"32b923ba03725fba\":\"gy5Z3\",\"38f5b7215a951c16\":\"eGHet\",\"46fe02f5a4ca95f9\":\"gRGNk\",\"b50e6043532127e\":\"aKTxx\",\"6151c2d28c8d5622\":\"9Gc1y\",\"302e65a20d20846c\":\"b3t88\",\"3b8f9736d90d33e6\":\"a7xJN\",\"73053c83e5457e82\":\"1F4QE\",\"fb70244a02539db4\":\"nTyT0\",\"ce38775557f57e2\":\"bkMBh\",\"3fc29578d4056add\":\"f2Bvm\",\"110dc2f32a5a5c80\":\"jxSFH\",\"ea70ab055c82b9c6\":\"57hgN\",\"c1e4a9f72f3e4c8a\":\"hJrte\",\"1eb1f87000f1507b\":\"8eYDK\",\"f04eacef530f3101\":\"hOqfp\",\"efc72f3780a14232\":\"bBCsY\",\"bb2b3970bd5df961\":\"j6kkx\",\"3f106ce05bb305c2\":\"bxm6V\",\"26177b9c0e662cb0\":\"bSHO0\",\"657db89678e27c44\":\"5fZdP\",\"7c097a1fe36e1e9e\":\"alCEF\"}],\"j0TZA\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Argument = void 0;\nclass Argument {\n    constructor(value, range){\n        this.value = value;\n        this.range = range;\n    }\n    toString() {\n        return this.value;\n    }\n    getRange() {\n        return this.range;\n    }\n    getValue() {\n        return this.value;\n    }\n    isAfter(position) {\n        if (this.range.end.line < position.line) return false;\n        return this.range.start.line > position.line ? true : this.range.start.character > position.character;\n    }\n    isBefore(position) {\n        if (this.range.start.line < position.line) return true;\n        return this.range.end.line > position.line ? false : this.range.end.character < position.character;\n    }\n}\nexports.Argument = Argument;\n\n},{}],\"58ALy\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.JSONArgument = void 0;\nconst argument_1 = require(\"60b94b0b95605351\");\nclass JSONArgument extends argument_1.Argument {\n    constructor(value, range, jsonRange){\n        super(value, range);\n        this.jsonRange = jsonRange;\n    }\n    getJSONRange() {\n        return this.jsonRange;\n    }\n    getJSONValue() {\n        let value = super.getValue();\n        value = value.substring(1, value.length - 1);\n        return value;\n    }\n}\nexports.JSONArgument = JSONArgument;\n\n},{\"60b94b0b95605351\":\"j0TZA\"}],\"5T0KS\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Comment = void 0;\nconst vscode_languageserver_types_1 = require(\"7469fdb9598c3ee1\");\nconst line_1 = require(\"236e9d8672ea26a2\");\nconst util_1 = require(\"d962123f7b2d05e\");\nclass Comment extends line_1.Line {\n    constructor(document, range){\n        super(document, range);\n    }\n    toString() {\n        const content = this.getContent();\n        if (content) return \"# \" + content;\n        return \"#\";\n    }\n    /**\n     * Returns the content of this comment. This excludes leading and\n     * trailing whitespace as well as the # symbol. If the comment only\n     * consists of whitespace, the empty string will be returned.\n     */ getContent() {\n        let range = this.getContentRange();\n        if (range === null) return \"\";\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    /**\n     * Returns a range that includes the content of the comment\n     * excluding any leading and trailing whitespace as well as the #\n     * symbol. May return null if the comment only consists of whitespace\n     * characters.\n     */ getContentRange() {\n        let range = this.getRange();\n        const startOffset = this.document.offsetAt(range.start);\n        let raw = this.document.getText().substring(startOffset, this.document.offsetAt(range.end));\n        let start = -1;\n        let end = -1;\n        // skip the first # symbol\n        for(let i = 1; i < raw.length; i++)if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n            start = i;\n            break;\n        }\n        if (start === -1) return null;\n        // go backwards up to the first # symbol\n        for(let i = raw.length - 1; i >= 1; i--)if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n            end = i + 1;\n            break;\n        }\n        return vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + start), this.document.positionAt(startOffset + end));\n    }\n}\nexports.Comment = Comment;\n\n},{\"7469fdb9598c3ee1\":\"ghSGy\",\"236e9d8672ea26a2\":\"jax2A\",\"d962123f7b2d05e\":\"7JXpr\"}],\"ghSGy\":[function(require,module,exports,__globalThis) {\n(function(factory) {\n    if (typeof module.exports === \"object\") {\n        var v = factory(undefined, exports);\n        if (v !== undefined) module.exports = v;\n    } else if (typeof define === \"function\" && define.amd) define([\n        \"require\",\n        \"exports\"\n    ], factory);\n})(function(require, exports1) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */ 'use strict';\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.TextDocument = exports1.EOL = exports1.WorkspaceFolder = exports1.InlineCompletionContext = exports1.SelectedCompletionInfo = exports1.InlineCompletionTriggerKind = exports1.InlineCompletionList = exports1.InlineCompletionItem = exports1.StringValue = exports1.InlayHint = exports1.InlayHintLabelPart = exports1.InlayHintKind = exports1.InlineValueContext = exports1.InlineValueEvaluatableExpression = exports1.InlineValueVariableLookup = exports1.InlineValueText = exports1.SemanticTokens = exports1.SemanticTokenModifiers = exports1.SemanticTokenTypes = exports1.SelectionRange = exports1.DocumentLink = exports1.FormattingOptions = exports1.CodeLens = exports1.CodeAction = exports1.CodeActionContext = exports1.CodeActionTriggerKind = exports1.CodeActionKind = exports1.DocumentSymbol = exports1.WorkspaceSymbol = exports1.SymbolInformation = exports1.SymbolTag = exports1.SymbolKind = exports1.DocumentHighlight = exports1.DocumentHighlightKind = exports1.SignatureInformation = exports1.ParameterInformation = exports1.Hover = exports1.MarkedString = exports1.CompletionList = exports1.CompletionItem = exports1.CompletionItemLabelDetails = exports1.InsertTextMode = exports1.InsertReplaceEdit = exports1.CompletionItemTag = exports1.InsertTextFormat = exports1.CompletionItemKind = exports1.MarkupContent = exports1.MarkupKind = exports1.TextDocumentItem = exports1.OptionalVersionedTextDocumentIdentifier = exports1.VersionedTextDocumentIdentifier = exports1.TextDocumentIdentifier = exports1.WorkspaceChange = exports1.WorkspaceEdit = exports1.DeleteFile = exports1.RenameFile = exports1.CreateFile = exports1.TextDocumentEdit = exports1.AnnotatedTextEdit = exports1.ChangeAnnotationIdentifier = exports1.ChangeAnnotation = exports1.TextEdit = exports1.Command = exports1.Diagnostic = exports1.CodeDescription = exports1.DiagnosticTag = exports1.DiagnosticSeverity = exports1.DiagnosticRelatedInformation = exports1.FoldingRange = exports1.FoldingRangeKind = exports1.ColorPresentation = exports1.ColorInformation = exports1.Color = exports1.LocationLink = exports1.Location = exports1.Range = exports1.Position = exports1.uinteger = exports1.integer = exports1.URI = exports1.DocumentUri = void 0;\n    var DocumentUri;\n    (function(DocumentUri) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        DocumentUri.is = is;\n    })(DocumentUri || (exports1.DocumentUri = DocumentUri = {}));\n    var URI;\n    (function(URI) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        URI.is = is;\n    })(URI || (exports1.URI = URI = {}));\n    var integer;\n    (function(integer) {\n        integer.MIN_VALUE = -2147483648;\n        integer.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n        }\n        integer.is = is;\n    })(integer || (exports1.integer = integer = {}));\n    var uinteger;\n    (function(uinteger) {\n        uinteger.MIN_VALUE = 0;\n        uinteger.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n        }\n        uinteger.is = is;\n    })(uinteger || (exports1.uinteger = uinteger = {}));\n    /**\n     * The Position namespace provides helper functions to work with\n     * {@link Position} literals.\n     */ var Position;\n    (function(Position) {\n        /**\n         * Creates a new Position literal from the given line and character.\n         * @param line The position's line.\n         * @param character The position's character.\n         */ function create(line, character) {\n            if (line === Number.MAX_VALUE) line = uinteger.MAX_VALUE;\n            if (character === Number.MAX_VALUE) character = uinteger.MAX_VALUE;\n            return {\n                line: line,\n                character: character\n            };\n        }\n        Position.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Position} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n        }\n        Position.is = is;\n    })(Position || (exports1.Position = Position = {}));\n    /**\n     * The Range namespace provides helper functions to work with\n     * {@link Range} literals.\n     */ var Range;\n    (function(Range) {\n        function create(one, two, three, four) {\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) return {\n                start: Position.create(one, two),\n                end: Position.create(three, four)\n            };\n            else if (Position.is(one) && Position.is(two)) return {\n                start: one,\n                end: two\n            };\n            else throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n        }\n        Range.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Range} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n        }\n        Range.is = is;\n    })(Range || (exports1.Range = Range = {}));\n    /**\n     * The Location namespace provides helper functions to work with\n     * {@link Location} literals.\n     */ var Location;\n    (function(Location) {\n        /**\n         * Creates a Location literal.\n         * @param uri The location's uri.\n         * @param range The location's range.\n         */ function create(uri, range) {\n            return {\n                uri: uri,\n                range: range\n            };\n        }\n        Location.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Location} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n        }\n        Location.is = is;\n    })(Location || (exports1.Location = Location = {}));\n    /**\n     * The LocationLink namespace provides helper functions to work with\n     * {@link LocationLink} literals.\n     */ var LocationLink;\n    (function(LocationLink) {\n        /**\n         * Creates a LocationLink literal.\n         * @param targetUri The definition's uri.\n         * @param targetRange The full range of the definition.\n         * @param targetSelectionRange The span of the symbol definition at the target.\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\n         */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n            return {\n                targetUri: targetUri,\n                targetRange: targetRange,\n                targetSelectionRange: targetSelectionRange,\n                originSelectionRange: originSelectionRange\n            };\n        }\n        LocationLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n        }\n        LocationLink.is = is;\n    })(LocationLink || (exports1.LocationLink = LocationLink = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link Color} literals.\n     */ var Color;\n    (function(Color) {\n        /**\n         * Creates a new Color literal.\n         */ function create(red, green, blue, alpha) {\n            return {\n                red: red,\n                green: green,\n                blue: blue,\n                alpha: alpha\n            };\n        }\n        Color.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Color} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\n        }\n        Color.is = is;\n    })(Color || (exports1.Color = Color = {}));\n    /**\n     * The ColorInformation namespace provides helper functions to work with\n     * {@link ColorInformation} literals.\n     */ var ColorInformation;\n    (function(ColorInformation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */ function create(range, color) {\n            return {\n                range: range,\n                color: color\n            };\n        }\n        ColorInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n        }\n        ColorInformation.is = is;\n    })(ColorInformation || (exports1.ColorInformation = ColorInformation = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link ColorPresentation} literals.\n     */ var ColorPresentation;\n    (function(ColorPresentation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */ function create(label, textEdit, additionalTextEdits) {\n            return {\n                label: label,\n                textEdit: textEdit,\n                additionalTextEdits: additionalTextEdits\n            };\n        }\n        ColorPresentation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n        }\n        ColorPresentation.is = is;\n    })(ColorPresentation || (exports1.ColorPresentation = ColorPresentation = {}));\n    /**\n     * A set of predefined range kinds.\n     */ var FoldingRangeKind;\n    (function(FoldingRangeKind) {\n        /**\n         * Folding range for a comment\n         */ FoldingRangeKind.Comment = 'comment';\n        /**\n         * Folding range for an import or include\n         */ FoldingRangeKind.Imports = 'imports';\n        /**\n         * Folding range for a region (e.g. `#region`)\n         */ FoldingRangeKind.Region = 'region';\n    })(FoldingRangeKind || (exports1.FoldingRangeKind = FoldingRangeKind = {}));\n    /**\n     * The folding range namespace provides helper functions to work with\n     * {@link FoldingRange} literals.\n     */ var FoldingRange;\n    (function(FoldingRange) {\n        /**\n         * Creates a new FoldingRange literal.\n         */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n            var result = {\n                startLine: startLine,\n                endLine: endLine\n            };\n            if (Is.defined(startCharacter)) result.startCharacter = startCharacter;\n            if (Is.defined(endCharacter)) result.endCharacter = endCharacter;\n            if (Is.defined(kind)) result.kind = kind;\n            if (Is.defined(collapsedText)) result.collapsedText = collapsedText;\n            return result;\n        }\n        FoldingRange.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n        }\n        FoldingRange.is = is;\n    })(FoldingRange || (exports1.FoldingRange = FoldingRange = {}));\n    /**\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\n     * {@link DiagnosticRelatedInformation} literals.\n     */ var DiagnosticRelatedInformation;\n    (function(DiagnosticRelatedInformation) {\n        /**\n         * Creates a new DiagnosticRelatedInformation literal.\n         */ function create(location, message) {\n            return {\n                location: location,\n                message: message\n            };\n        }\n        DiagnosticRelatedInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n        }\n        DiagnosticRelatedInformation.is = is;\n    })(DiagnosticRelatedInformation || (exports1.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\n    /**\n     * The diagnostic's severity.\n     */ var DiagnosticSeverity;\n    (function(DiagnosticSeverity) {\n        /**\n         * Reports an error.\n         */ DiagnosticSeverity.Error = 1;\n        /**\n         * Reports a warning.\n         */ DiagnosticSeverity.Warning = 2;\n        /**\n         * Reports an information.\n         */ DiagnosticSeverity.Information = 3;\n        /**\n         * Reports a hint.\n         */ DiagnosticSeverity.Hint = 4;\n    })(DiagnosticSeverity || (exports1.DiagnosticSeverity = DiagnosticSeverity = {}));\n    /**\n     * The diagnostic tags.\n     *\n     * @since 3.15.0\n     */ var DiagnosticTag;\n    (function(DiagnosticTag) {\n        /**\n         * Unused or unnecessary code.\n         *\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\n         * an error squiggle.\n         */ DiagnosticTag.Unnecessary = 1;\n        /**\n         * Deprecated or obsolete code.\n         *\n         * Clients are allowed to rendered diagnostics with this tag strike through.\n         */ DiagnosticTag.Deprecated = 2;\n    })(DiagnosticTag || (exports1.DiagnosticTag = DiagnosticTag = {}));\n    /**\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n     *\n     * @since 3.16.0\n     */ var CodeDescription;\n    (function(CodeDescription) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\n        }\n        CodeDescription.is = is;\n    })(CodeDescription || (exports1.CodeDescription = CodeDescription = {}));\n    /**\n     * The Diagnostic namespace provides helper functions to work with\n     * {@link Diagnostic} literals.\n     */ var Diagnostic;\n    (function(Diagnostic) {\n        /**\n         * Creates a new Diagnostic literal.\n         */ function create(range, message, severity, code, source, relatedInformation) {\n            var result = {\n                range: range,\n                message: message\n            };\n            if (Is.defined(severity)) result.severity = severity;\n            if (Is.defined(code)) result.code = code;\n            if (Is.defined(source)) result.source = source;\n            if (Is.defined(relatedInformation)) result.relatedInformation = relatedInformation;\n            return result;\n        }\n        Diagnostic.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n         */ function is(value) {\n            var _a;\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n        }\n        Diagnostic.is = is;\n    })(Diagnostic || (exports1.Diagnostic = Diagnostic = {}));\n    /**\n     * The Command namespace provides helper functions to work with\n     * {@link Command} literals.\n     */ var Command;\n    (function(Command) {\n        /**\n         * Creates a new Command literal.\n         */ function create(title, command) {\n            var args = [];\n            for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];\n            var result = {\n                title: title,\n                command: command\n            };\n            if (Is.defined(args) && args.length > 0) result.arguments = args;\n            return result;\n        }\n        Command.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Command} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n        }\n        Command.is = is;\n    })(Command || (exports1.Command = Command = {}));\n    /**\n     * The TextEdit namespace provides helper function to create replace,\n     * insert and delete edits more easily.\n     */ var TextEdit;\n    (function(TextEdit) {\n        /**\n         * Creates a replace text edit.\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         */ function replace(range, newText) {\n            return {\n                range: range,\n                newText: newText\n            };\n        }\n        TextEdit.replace = replace;\n        /**\n         * Creates an insert text edit.\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         */ function insert(position, newText) {\n            return {\n                range: {\n                    start: position,\n                    end: position\n                },\n                newText: newText\n            };\n        }\n        TextEdit.insert = insert;\n        /**\n         * Creates a delete text edit.\n         * @param range The range of text to be deleted.\n         */ function del(range) {\n            return {\n                range: range,\n                newText: ''\n            };\n        }\n        TextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\n        }\n        TextEdit.is = is;\n    })(TextEdit || (exports1.TextEdit = TextEdit = {}));\n    var ChangeAnnotation;\n    (function(ChangeAnnotation) {\n        function create(label, needsConfirmation, description) {\n            var result = {\n                label: label\n            };\n            if (needsConfirmation !== undefined) result.needsConfirmation = needsConfirmation;\n            if (description !== undefined) result.description = description;\n            return result;\n        }\n        ChangeAnnotation.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        ChangeAnnotation.is = is;\n    })(ChangeAnnotation || (exports1.ChangeAnnotation = ChangeAnnotation = {}));\n    var ChangeAnnotationIdentifier;\n    (function(ChangeAnnotationIdentifier) {\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate);\n        }\n        ChangeAnnotationIdentifier.is = is;\n    })(ChangeAnnotationIdentifier || (exports1.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\n    var AnnotatedTextEdit;\n    (function(AnnotatedTextEdit) {\n        /**\n         * Creates an annotated replace text edit.\n         *\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         * @param annotation The annotation.\n         */ function replace(range, newText, annotation) {\n            return {\n                range: range,\n                newText: newText,\n                annotationId: annotation\n            };\n        }\n        AnnotatedTextEdit.replace = replace;\n        /**\n         * Creates an annotated insert text edit.\n         *\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         * @param annotation The annotation.\n         */ function insert(position, newText, annotation) {\n            return {\n                range: {\n                    start: position,\n                    end: position\n                },\n                newText: newText,\n                annotationId: annotation\n            };\n        }\n        AnnotatedTextEdit.insert = insert;\n        /**\n         * Creates an annotated delete text edit.\n         *\n         * @param range The range of text to be deleted.\n         * @param annotation The annotation.\n         */ function del(range, annotation) {\n            return {\n                range: range,\n                newText: '',\n                annotationId: annotation\n            };\n        }\n        AnnotatedTextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        AnnotatedTextEdit.is = is;\n    })(AnnotatedTextEdit || (exports1.AnnotatedTextEdit = AnnotatedTextEdit = {}));\n    /**\n     * The TextDocumentEdit namespace provides helper function to create\n     * an edit that manipulates a text document.\n     */ var TextDocumentEdit;\n    (function(TextDocumentEdit) {\n        /**\n         * Creates a new `TextDocumentEdit`\n         */ function create(textDocument, edits) {\n            return {\n                textDocument: textDocument,\n                edits: edits\n            };\n        }\n        TextDocumentEdit.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n        }\n        TextDocumentEdit.is = is;\n    })(TextDocumentEdit || (exports1.TextDocumentEdit = TextDocumentEdit = {}));\n    var CreateFile;\n    (function(CreateFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'create',\n                uri: uri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) result.options = options;\n            if (annotation !== undefined) result.annotationId = annotation;\n            return result;\n        }\n        CreateFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        CreateFile.is = is;\n    })(CreateFile || (exports1.CreateFile = CreateFile = {}));\n    var RenameFile;\n    (function(RenameFile) {\n        function create(oldUri, newUri, options, annotation) {\n            var result = {\n                kind: 'rename',\n                oldUri: oldUri,\n                newUri: newUri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) result.options = options;\n            if (annotation !== undefined) result.annotationId = annotation;\n            return result;\n        }\n        RenameFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        RenameFile.is = is;\n    })(RenameFile || (exports1.RenameFile = RenameFile = {}));\n    var DeleteFile;\n    (function(DeleteFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'delete',\n                uri: uri\n            };\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) result.options = options;\n            if (annotation !== undefined) result.annotationId = annotation;\n            return result;\n        }\n        DeleteFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        DeleteFile.is = is;\n    })(DeleteFile || (exports1.DeleteFile = DeleteFile = {}));\n    var WorkspaceEdit;\n    (function(WorkspaceEdit) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {\n                if (Is.string(change.kind)) return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                else return TextDocumentEdit.is(change);\n            }));\n        }\n        WorkspaceEdit.is = is;\n    })(WorkspaceEdit || (exports1.WorkspaceEdit = WorkspaceEdit = {}));\n    var TextEditChangeImpl = /** @class */ function() {\n        function TextEditChangeImpl(edits, changeAnnotations) {\n            this.edits = edits;\n            this.changeAnnotations = changeAnnotations;\n        }\n        TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) edit = TextEdit.insert(position, newText);\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\n            } else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.insert(position, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) return id;\n        };\n        TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) edit = TextEdit.replace(range, newText);\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\n            } else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.replace(range, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) return id;\n        };\n        TextEditChangeImpl.prototype.delete = function(range, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) edit = TextEdit.del(range);\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.del(range, annotation);\n            } else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.del(range, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) return id;\n        };\n        TextEditChangeImpl.prototype.add = function(edit) {\n            this.edits.push(edit);\n        };\n        TextEditChangeImpl.prototype.all = function() {\n            return this.edits;\n        };\n        TextEditChangeImpl.prototype.clear = function() {\n            this.edits.splice(0, this.edits.length);\n        };\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {\n            if (value === undefined) throw new Error(\"Text edit change is not configured to manage change annotations.\");\n        };\n        return TextEditChangeImpl;\n    }();\n    /**\n     * A helper class\n     */ var ChangeAnnotations = /** @class */ function() {\n        function ChangeAnnotations(annotations) {\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\n            this._counter = 0;\n            this._size = 0;\n        }\n        ChangeAnnotations.prototype.all = function() {\n            return this._annotations;\n        };\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n            get: function() {\n                return this._size;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {\n            var id;\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) id = idOrAnnotation;\n            else {\n                id = this.nextId();\n                annotation = idOrAnnotation;\n            }\n            if (this._annotations[id] !== undefined) throw new Error(\"Id \".concat(id, \" is already in use.\"));\n            if (annotation === undefined) throw new Error(\"No annotation provided for id \".concat(id));\n            this._annotations[id] = annotation;\n            this._size++;\n            return id;\n        };\n        ChangeAnnotations.prototype.nextId = function() {\n            this._counter++;\n            return this._counter.toString();\n        };\n        return ChangeAnnotations;\n    }();\n    /**\n     * A workspace change helps constructing changes to a workspace.\n     */ var WorkspaceChange = /** @class */ function() {\n        function WorkspaceChange(workspaceEdit) {\n            var _this = this;\n            this._textEditChanges = Object.create(null);\n            if (workspaceEdit !== undefined) {\n                this._workspaceEdit = workspaceEdit;\n                if (workspaceEdit.documentChanges) {\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    workspaceEdit.documentChanges.forEach(function(change) {\n                        if (TextDocumentEdit.is(change)) {\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                        }\n                    });\n                } else if (workspaceEdit.changes) Object.keys(workspaceEdit.changes).forEach(function(key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            } else this._workspaceEdit = {};\n        }\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n            /**\n             * Returns the underlying {@link WorkspaceEdit} literal\n             * use to be returned from a workspace edit operation like rename.\n             */ get: function() {\n                this.initDocumentChanges();\n                if (this._changeAnnotations !== undefined) {\n                    if (this._changeAnnotations.size === 0) this._workspaceEdit.changeAnnotations = undefined;\n                    else this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n                return this._workspaceEdit;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WorkspaceChange.prototype.getTextEditChange = function(key) {\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n                this.initDocumentChanges();\n                if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n                var textDocument = {\n                    uri: key.uri,\n                    version: key.version\n                };\n                var result = this._textEditChanges[textDocument.uri];\n                if (!result) {\n                    var edits = [];\n                    var textDocumentEdit = {\n                        textDocument: textDocument,\n                        edits: edits\n                    };\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                    this._textEditChanges[textDocument.uri] = result;\n                }\n                return result;\n            } else {\n                this.initChanges();\n                if (this._workspaceEdit.changes === undefined) throw new Error('Workspace edit is not configured for normal text edit changes.');\n                var result = this._textEditChanges[key];\n                if (!result) {\n                    var edits = [];\n                    this._workspaceEdit.changes[key] = edits;\n                    result = new TextEditChangeImpl(edits);\n                    this._textEditChanges[key] = result;\n                }\n                return result;\n            }\n        };\n        WorkspaceChange.prototype.initDocumentChanges = function() {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._changeAnnotations = new ChangeAnnotations();\n                this._workspaceEdit.documentChanges = [];\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        };\n        WorkspaceChange.prototype.initChanges = function() {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) this._workspaceEdit.changes = Object.create(null);\n        };\n        WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) annotation = optionsOrAnnotation;\n            else options = optionsOrAnnotation;\n            var operation;\n            var id;\n            if (annotation === undefined) operation = CreateFile.create(uri, options);\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = CreateFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) return id;\n        };\n        WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) annotation = optionsOrAnnotation;\n            else options = optionsOrAnnotation;\n            var operation;\n            var id;\n            if (annotation === undefined) operation = RenameFile.create(oldUri, newUri, options);\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = RenameFile.create(oldUri, newUri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) return id;\n        };\n        WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) annotation = optionsOrAnnotation;\n            else options = optionsOrAnnotation;\n            var operation;\n            var id;\n            if (annotation === undefined) operation = DeleteFile.create(uri, options);\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = DeleteFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) return id;\n        };\n        return WorkspaceChange;\n    }();\n    exports1.WorkspaceChange = WorkspaceChange;\n    /**\n     * The TextDocumentIdentifier namespace provides helper functions to work with\n     * {@link TextDocumentIdentifier} literals.\n     */ var TextDocumentIdentifier;\n    (function(TextDocumentIdentifier) {\n        /**\n         * Creates a new TextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         */ function create(uri) {\n            return {\n                uri: uri\n            };\n        }\n        TextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri);\n        }\n        TextDocumentIdentifier.is = is;\n    })(TextDocumentIdentifier || (exports1.TextDocumentIdentifier = TextDocumentIdentifier = {}));\n    /**\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link VersionedTextDocumentIdentifier} literals.\n     */ var VersionedTextDocumentIdentifier;\n    (function(VersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new VersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */ function create(uri, version) {\n            return {\n                uri: uri,\n                version: version\n            };\n        }\n        VersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n        }\n        VersionedTextDocumentIdentifier.is = is;\n    })(VersionedTextDocumentIdentifier || (exports1.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\n    /**\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\n     */ var OptionalVersionedTextDocumentIdentifier;\n    (function(OptionalVersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */ function create(uri, version) {\n            return {\n                uri: uri,\n                version: version\n            };\n        }\n        OptionalVersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n        }\n        OptionalVersionedTextDocumentIdentifier.is = is;\n    })(OptionalVersionedTextDocumentIdentifier || (exports1.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\n    /**\n     * The TextDocumentItem namespace provides helper functions to work with\n     * {@link TextDocumentItem} literals.\n     */ var TextDocumentItem;\n    (function(TextDocumentItem) {\n        /**\n         * Creates a new TextDocumentItem literal.\n         * @param uri The document's uri.\n         * @param languageId The document's language identifier.\n         * @param version The document's version number.\n         * @param text The document's text.\n         */ function create(uri, languageId, version, text) {\n            return {\n                uri: uri,\n                languageId: languageId,\n                version: version,\n                text: text\n            };\n        }\n        TextDocumentItem.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n        }\n        TextDocumentItem.is = is;\n    })(TextDocumentItem || (exports1.TextDocumentItem = TextDocumentItem = {}));\n    /**\n     * Describes the content type that a client supports in various\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n     *\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\n     * are reserved for internal usage.\n     */ var MarkupKind;\n    (function(MarkupKind) {\n        /**\n         * Plain text is supported as a content format\n         */ MarkupKind.PlainText = 'plaintext';\n        /**\n         * Markdown is supported as a content format\n         */ MarkupKind.Markdown = 'markdown';\n        /**\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\n         */ function is(value) {\n            var candidate = value;\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n        }\n        MarkupKind.is = is;\n    })(MarkupKind || (exports1.MarkupKind = MarkupKind = {}));\n    var MarkupContent;\n    (function(MarkupContent) {\n        /**\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n        }\n        MarkupContent.is = is;\n    })(MarkupContent || (exports1.MarkupContent = MarkupContent = {}));\n    /**\n     * The kind of a completion entry.\n     */ var CompletionItemKind;\n    (function(CompletionItemKind) {\n        CompletionItemKind.Text = 1;\n        CompletionItemKind.Method = 2;\n        CompletionItemKind.Function = 3;\n        CompletionItemKind.Constructor = 4;\n        CompletionItemKind.Field = 5;\n        CompletionItemKind.Variable = 6;\n        CompletionItemKind.Class = 7;\n        CompletionItemKind.Interface = 8;\n        CompletionItemKind.Module = 9;\n        CompletionItemKind.Property = 10;\n        CompletionItemKind.Unit = 11;\n        CompletionItemKind.Value = 12;\n        CompletionItemKind.Enum = 13;\n        CompletionItemKind.Keyword = 14;\n        CompletionItemKind.Snippet = 15;\n        CompletionItemKind.Color = 16;\n        CompletionItemKind.File = 17;\n        CompletionItemKind.Reference = 18;\n        CompletionItemKind.Folder = 19;\n        CompletionItemKind.EnumMember = 20;\n        CompletionItemKind.Constant = 21;\n        CompletionItemKind.Struct = 22;\n        CompletionItemKind.Event = 23;\n        CompletionItemKind.Operator = 24;\n        CompletionItemKind.TypeParameter = 25;\n    })(CompletionItemKind || (exports1.CompletionItemKind = CompletionItemKind = {}));\n    /**\n     * Defines whether the insert text in a completion item should be interpreted as\n     * plain text or a snippet.\n     */ var InsertTextFormat;\n    (function(InsertTextFormat) {\n        /**\n         * The primary text to be inserted is treated as a plain string.\n         */ InsertTextFormat.PlainText = 1;\n        /**\n         * The primary text to be inserted is treated as a snippet.\n         *\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n         * the end of the snippet. Placeholders with equal identifiers are linked,\n         * that is typing in one will update others too.\n         *\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n         */ InsertTextFormat.Snippet = 2;\n    })(InsertTextFormat || (exports1.InsertTextFormat = InsertTextFormat = {}));\n    /**\n     * Completion item tags are extra annotations that tweak the rendering of a completion\n     * item.\n     *\n     * @since 3.15.0\n     */ var CompletionItemTag;\n    (function(CompletionItemTag) {\n        /**\n         * Render a completion as obsolete, usually using a strike-out.\n         */ CompletionItemTag.Deprecated = 1;\n    })(CompletionItemTag || (exports1.CompletionItemTag = CompletionItemTag = {}));\n    /**\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n     *\n     * @since 3.16.0\n     */ var InsertReplaceEdit;\n    (function(InsertReplaceEdit) {\n        /**\n         * Creates a new insert / replace edit\n         */ function create(newText, insert, replace) {\n            return {\n                newText: newText,\n                insert: insert,\n                replace: replace\n            };\n        }\n        InsertReplaceEdit.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n         */ function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n        }\n        InsertReplaceEdit.is = is;\n    })(InsertReplaceEdit || (exports1.InsertReplaceEdit = InsertReplaceEdit = {}));\n    /**\n     * How whitespace and indentation is handled during completion\n     * item insertion.\n     *\n     * @since 3.16.0\n     */ var InsertTextMode;\n    (function(InsertTextMode) {\n        /**\n         * The insertion or replace strings is taken as it is. If the\n         * value is multi line the lines below the cursor will be\n         * inserted using the indentation defined in the string value.\n         * The client will not apply any kind of adjustments to the\n         * string.\n         */ InsertTextMode.asIs = 1;\n        /**\n         * The editor adjusts leading whitespace of new lines so that\n         * they match the indentation up to the cursor of the line for\n         * which the item is accepted.\n         *\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n         * multi line completion item is indented using 2 tabs and all\n         * following lines inserted will be indented using 2 tabs as well.\n         */ InsertTextMode.adjustIndentation = 2;\n    })(InsertTextMode || (exports1.InsertTextMode = InsertTextMode = {}));\n    var CompletionItemLabelDetails;\n    (function(CompletionItemLabelDetails) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        CompletionItemLabelDetails.is = is;\n    })(CompletionItemLabelDetails || (exports1.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\n    /**\n     * The CompletionItem namespace provides functions to deal with\n     * completion items.\n     */ var CompletionItem;\n    (function(CompletionItem) {\n        /**\n         * Create a completion item and seed it with a label.\n         * @param label The completion item's label\n         */ function create(label) {\n            return {\n                label: label\n            };\n        }\n        CompletionItem.create = create;\n    })(CompletionItem || (exports1.CompletionItem = CompletionItem = {}));\n    /**\n     * The CompletionList namespace provides functions to deal with\n     * completion lists.\n     */ var CompletionList;\n    (function(CompletionList) {\n        /**\n         * Creates a new completion list.\n         *\n         * @param items The completion items.\n         * @param isIncomplete The list is not complete.\n         */ function create(items, isIncomplete) {\n            return {\n                items: items ? items : [],\n                isIncomplete: !!isIncomplete\n            };\n        }\n        CompletionList.create = create;\n    })(CompletionList || (exports1.CompletionList = CompletionList = {}));\n    var MarkedString;\n    (function(MarkedString) {\n        /**\n         * Creates a marked string from plain text.\n         *\n         * @param plainText The plain text.\n         */ function fromPlainText(plainText) {\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n        }\n        MarkedString.fromPlainText = fromPlainText;\n        /**\n         * Checks whether the given value conforms to the {@link MarkedString} type.\n         */ function is(value) {\n            var candidate = value;\n            return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n        }\n        MarkedString.is = is;\n    })(MarkedString || (exports1.MarkedString = MarkedString = {}));\n    var Hover;\n    (function(Hover) {\n        /**\n         * Checks whether the given value conforms to the {@link Hover} interface.\n         */ function is(value) {\n            var candidate = value;\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n        }\n        Hover.is = is;\n    })(Hover || (exports1.Hover = Hover = {}));\n    /**\n     * The ParameterInformation namespace provides helper functions to work with\n     * {@link ParameterInformation} literals.\n     */ var ParameterInformation;\n    (function(ParameterInformation) {\n        /**\n         * Creates a new parameter information literal.\n         *\n         * @param label A label string.\n         * @param documentation A doc string.\n         */ function create(label, documentation) {\n            return documentation ? {\n                label: label,\n                documentation: documentation\n            } : {\n                label: label\n            };\n        }\n        ParameterInformation.create = create;\n    })(ParameterInformation || (exports1.ParameterInformation = ParameterInformation = {}));\n    /**\n     * The SignatureInformation namespace provides helper functions to work with\n     * {@link SignatureInformation} literals.\n     */ var SignatureInformation;\n    (function(SignatureInformation) {\n        function create(label, documentation) {\n            var parameters = [];\n            for(var _i = 2; _i < arguments.length; _i++)parameters[_i - 2] = arguments[_i];\n            var result = {\n                label: label\n            };\n            if (Is.defined(documentation)) result.documentation = documentation;\n            if (Is.defined(parameters)) result.parameters = parameters;\n            else result.parameters = [];\n            return result;\n        }\n        SignatureInformation.create = create;\n    })(SignatureInformation || (exports1.SignatureInformation = SignatureInformation = {}));\n    /**\n     * A document highlight kind.\n     */ var DocumentHighlightKind;\n    (function(DocumentHighlightKind) {\n        /**\n         * A textual occurrence.\n         */ DocumentHighlightKind.Text = 1;\n        /**\n         * Read-access of a symbol, like reading a variable.\n         */ DocumentHighlightKind.Read = 2;\n        /**\n         * Write-access of a symbol, like writing to a variable.\n         */ DocumentHighlightKind.Write = 3;\n    })(DocumentHighlightKind || (exports1.DocumentHighlightKind = DocumentHighlightKind = {}));\n    /**\n     * DocumentHighlight namespace to provide helper functions to work with\n     * {@link DocumentHighlight} literals.\n     */ var DocumentHighlight;\n    (function(DocumentHighlight) {\n        /**\n         * Create a DocumentHighlight object.\n         * @param range The range the highlight applies to.\n         * @param kind The highlight kind\n         */ function create(range, kind) {\n            var result = {\n                range: range\n            };\n            if (Is.number(kind)) result.kind = kind;\n            return result;\n        }\n        DocumentHighlight.create = create;\n    })(DocumentHighlight || (exports1.DocumentHighlight = DocumentHighlight = {}));\n    /**\n     * A symbol kind.\n     */ var SymbolKind;\n    (function(SymbolKind) {\n        SymbolKind.File = 1;\n        SymbolKind.Module = 2;\n        SymbolKind.Namespace = 3;\n        SymbolKind.Package = 4;\n        SymbolKind.Class = 5;\n        SymbolKind.Method = 6;\n        SymbolKind.Property = 7;\n        SymbolKind.Field = 8;\n        SymbolKind.Constructor = 9;\n        SymbolKind.Enum = 10;\n        SymbolKind.Interface = 11;\n        SymbolKind.Function = 12;\n        SymbolKind.Variable = 13;\n        SymbolKind.Constant = 14;\n        SymbolKind.String = 15;\n        SymbolKind.Number = 16;\n        SymbolKind.Boolean = 17;\n        SymbolKind.Array = 18;\n        SymbolKind.Object = 19;\n        SymbolKind.Key = 20;\n        SymbolKind.Null = 21;\n        SymbolKind.EnumMember = 22;\n        SymbolKind.Struct = 23;\n        SymbolKind.Event = 24;\n        SymbolKind.Operator = 25;\n        SymbolKind.TypeParameter = 26;\n    })(SymbolKind || (exports1.SymbolKind = SymbolKind = {}));\n    /**\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\n     *\n     * @since 3.16\n     */ var SymbolTag;\n    (function(SymbolTag) {\n        /**\n         * Render a symbol as obsolete, usually using a strike-out.\n         */ SymbolTag.Deprecated = 1;\n    })(SymbolTag || (exports1.SymbolTag = SymbolTag = {}));\n    var SymbolInformation;\n    (function(SymbolInformation) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the location of the symbol.\n         * @param uri The resource of the location of symbol.\n         * @param containerName The name of the symbol containing the symbol.\n         */ function create(name, kind, range, uri, containerName) {\n            var result = {\n                name: name,\n                kind: kind,\n                location: {\n                    uri: uri,\n                    range: range\n                }\n            };\n            if (containerName) result.containerName = containerName;\n            return result;\n        }\n        SymbolInformation.create = create;\n    })(SymbolInformation || (exports1.SymbolInformation = SymbolInformation = {}));\n    var WorkspaceSymbol;\n    (function(WorkspaceSymbol) {\n        /**\n         * Create a new workspace symbol.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param uri The resource of the location of the symbol.\n         * @param range An options range of the location.\n         * @returns A WorkspaceSymbol.\n         */ function create(name, kind, uri, range) {\n            return range !== undefined ? {\n                name: name,\n                kind: kind,\n                location: {\n                    uri: uri,\n                    range: range\n                }\n            } : {\n                name: name,\n                kind: kind,\n                location: {\n                    uri: uri\n                }\n            };\n        }\n        WorkspaceSymbol.create = create;\n    })(WorkspaceSymbol || (exports1.WorkspaceSymbol = WorkspaceSymbol = {}));\n    var DocumentSymbol;\n    (function(DocumentSymbol) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param detail The detail of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the symbol.\n         * @param selectionRange The selectionRange of the symbol.\n         * @param children Children of the symbol.\n         */ function create(name, detail, kind, range, selectionRange, children) {\n            var result = {\n                name: name,\n                detail: detail,\n                kind: kind,\n                range: range,\n                selectionRange: selectionRange\n            };\n            if (children !== undefined) result.children = children;\n            return result;\n        }\n        DocumentSymbol.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n         */ function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));\n        }\n        DocumentSymbol.is = is;\n    })(DocumentSymbol || (exports1.DocumentSymbol = DocumentSymbol = {}));\n    /**\n     * A set of predefined code action kinds\n     */ var CodeActionKind;\n    (function(CodeActionKind) {\n        /**\n         * Empty kind.\n         */ CodeActionKind.Empty = '';\n        /**\n         * Base kind for quickfix actions: 'quickfix'\n         */ CodeActionKind.QuickFix = 'quickfix';\n        /**\n         * Base kind for refactoring actions: 'refactor'\n         */ CodeActionKind.Refactor = 'refactor';\n        /**\n         * Base kind for refactoring extraction actions: 'refactor.extract'\n         *\n         * Example extract actions:\n         *\n         * - Extract method\n         * - Extract function\n         * - Extract variable\n         * - Extract interface from class\n         * - ...\n         */ CodeActionKind.RefactorExtract = 'refactor.extract';\n        /**\n         * Base kind for refactoring inline actions: 'refactor.inline'\n         *\n         * Example inline actions:\n         *\n         * - Inline function\n         * - Inline variable\n         * - Inline constant\n         * - ...\n         */ CodeActionKind.RefactorInline = 'refactor.inline';\n        /**\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n         *\n         * Example rewrite actions:\n         *\n         * - Convert JavaScript function to class\n         * - Add or remove parameter\n         * - Encapsulate field\n         * - Make method static\n         * - Move method to base class\n         * - ...\n         */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n        /**\n         * Base kind for source actions: `source`\n         *\n         * Source code actions apply to the entire file.\n         */ CodeActionKind.Source = 'source';\n        /**\n         * Base kind for an organize imports source action: `source.organizeImports`\n         */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n        /**\n         * Base kind for auto-fix source actions: `source.fixAll`.\n         *\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n         *\n         * @since 3.15.0\n         */ CodeActionKind.SourceFixAll = 'source.fixAll';\n    })(CodeActionKind || (exports1.CodeActionKind = CodeActionKind = {}));\n    /**\n     * The reason why code actions were requested.\n     *\n     * @since 3.17.0\n     */ var CodeActionTriggerKind;\n    (function(CodeActionTriggerKind) {\n        /**\n         * Code actions were explicitly requested by the user or by an extension.\n         */ CodeActionTriggerKind.Invoked = 1;\n        /**\n         * Code actions were requested automatically.\n         *\n         * This typically happens when current selection in a file changes, but can\n         * also be triggered when file content changes.\n         */ CodeActionTriggerKind.Automatic = 2;\n    })(CodeActionTriggerKind || (exports1.CodeActionTriggerKind = CodeActionTriggerKind = {}));\n    /**\n     * The CodeActionContext namespace provides helper functions to work with\n     * {@link CodeActionContext} literals.\n     */ var CodeActionContext;\n    (function(CodeActionContext) {\n        /**\n         * Creates a new CodeActionContext literal.\n         */ function create(diagnostics, only, triggerKind) {\n            var result = {\n                diagnostics: diagnostics\n            };\n            if (only !== undefined && only !== null) result.only = only;\n            if (triggerKind !== undefined && triggerKind !== null) result.triggerKind = triggerKind;\n            return result;\n        }\n        CodeActionContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n        }\n        CodeActionContext.is = is;\n    })(CodeActionContext || (exports1.CodeActionContext = CodeActionContext = {}));\n    var CodeAction;\n    (function(CodeAction) {\n        function create(title, kindOrCommandOrEdit, kind) {\n            var result = {\n                title: title\n            };\n            var checkKind = true;\n            if (typeof kindOrCommandOrEdit === 'string') {\n                checkKind = false;\n                result.kind = kindOrCommandOrEdit;\n            } else if (Command.is(kindOrCommandOrEdit)) result.command = kindOrCommandOrEdit;\n            else result.edit = kindOrCommandOrEdit;\n            if (checkKind && kind !== undefined) result.kind = kind;\n            return result;\n        }\n        CodeAction.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n        }\n        CodeAction.is = is;\n    })(CodeAction || (exports1.CodeAction = CodeAction = {}));\n    /**\n     * The CodeLens namespace provides helper functions to work with\n     * {@link CodeLens} literals.\n     */ var CodeLens;\n    (function(CodeLens) {\n        /**\n         * Creates a new CodeLens literal.\n         */ function create(range, data) {\n            var result = {\n                range: range\n            };\n            if (Is.defined(data)) result.data = data;\n            return result;\n        }\n        CodeLens.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n        }\n        CodeLens.is = is;\n    })(CodeLens || (exports1.CodeLens = CodeLens = {}));\n    /**\n     * The FormattingOptions namespace provides helper functions to work with\n     * {@link FormattingOptions} literals.\n     */ var FormattingOptions;\n    (function(FormattingOptions) {\n        /**\n         * Creates a new FormattingOptions literal.\n         */ function create(tabSize, insertSpaces) {\n            return {\n                tabSize: tabSize,\n                insertSpaces: insertSpaces\n            };\n        }\n        FormattingOptions.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n        }\n        FormattingOptions.is = is;\n    })(FormattingOptions || (exports1.FormattingOptions = FormattingOptions = {}));\n    /**\n     * The DocumentLink namespace provides helper functions to work with\n     * {@link DocumentLink} literals.\n     */ var DocumentLink;\n    (function(DocumentLink) {\n        /**\n         * Creates a new DocumentLink literal.\n         */ function create(range, target, data) {\n            return {\n                range: range,\n                target: target,\n                data: data\n            };\n        }\n        DocumentLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n        }\n        DocumentLink.is = is;\n    })(DocumentLink || (exports1.DocumentLink = DocumentLink = {}));\n    /**\n     * The SelectionRange namespace provides helper function to work with\n     * SelectionRange literals.\n     */ var SelectionRange;\n    (function(SelectionRange) {\n        /**\n         * Creates a new SelectionRange\n         * @param range the range.\n         * @param parent an optional parent.\n         */ function create(range, parent) {\n            return {\n                range: range,\n                parent: parent\n            };\n        }\n        SelectionRange.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n        }\n        SelectionRange.is = is;\n    })(SelectionRange || (exports1.SelectionRange = SelectionRange = {}));\n    /**\n     * A set of predefined token types. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */ var SemanticTokenTypes;\n    (function(SemanticTokenTypes) {\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\n        /**\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\n         * a specific type like class or enum.\n         */ SemanticTokenTypes[\"type\"] = \"type\";\n        SemanticTokenTypes[\"class\"] = \"class\";\n        SemanticTokenTypes[\"enum\"] = \"enum\";\n        SemanticTokenTypes[\"interface\"] = \"interface\";\n        SemanticTokenTypes[\"struct\"] = \"struct\";\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\n        SemanticTokenTypes[\"variable\"] = \"variable\";\n        SemanticTokenTypes[\"property\"] = \"property\";\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n        SemanticTokenTypes[\"event\"] = \"event\";\n        SemanticTokenTypes[\"function\"] = \"function\";\n        SemanticTokenTypes[\"method\"] = \"method\";\n        SemanticTokenTypes[\"macro\"] = \"macro\";\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\n        SemanticTokenTypes[\"comment\"] = \"comment\";\n        SemanticTokenTypes[\"string\"] = \"string\";\n        SemanticTokenTypes[\"number\"] = \"number\";\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\n        SemanticTokenTypes[\"operator\"] = \"operator\";\n        /**\n         * @since 3.17.0\n         */ SemanticTokenTypes[\"decorator\"] = \"decorator\";\n    })(SemanticTokenTypes || (exports1.SemanticTokenTypes = SemanticTokenTypes = {}));\n    /**\n     * A set of predefined token modifiers. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */ var SemanticTokenModifiers;\n    (function(SemanticTokenModifiers) {\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n        SemanticTokenModifiers[\"static\"] = \"static\";\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n        SemanticTokenModifiers[\"async\"] = \"async\";\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n    })(SemanticTokenModifiers || (exports1.SemanticTokenModifiers = SemanticTokenModifiers = {}));\n    /**\n     * @since 3.16.0\n     */ var SemanticTokens;\n    (function(SemanticTokens) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n        }\n        SemanticTokens.is = is;\n    })(SemanticTokens || (exports1.SemanticTokens = SemanticTokens = {}));\n    /**\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n     *\n     * @since 3.17.0\n     */ var InlineValueText;\n    (function(InlineValueText) {\n        /**\n         * Creates a new InlineValueText literal.\n         */ function create(range, text) {\n            return {\n                range: range,\n                text: text\n            };\n        }\n        InlineValueText.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n        }\n        InlineValueText.is = is;\n    })(InlineValueText || (exports1.InlineValueText = InlineValueText = {}));\n    /**\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n     *\n     * @since 3.17.0\n     */ var InlineValueVariableLookup;\n    (function(InlineValueVariableLookup) {\n        /**\n         * Creates a new InlineValueText literal.\n         */ function create(range, variableName, caseSensitiveLookup) {\n            return {\n                range: range,\n                variableName: variableName,\n                caseSensitiveLookup: caseSensitiveLookup\n            };\n        }\n        InlineValueVariableLookup.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n        }\n        InlineValueVariableLookup.is = is;\n    })(InlineValueVariableLookup || (exports1.InlineValueVariableLookup = InlineValueVariableLookup = {}));\n    /**\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n     *\n     * @since 3.17.0\n     */ var InlineValueEvaluatableExpression;\n    (function(InlineValueEvaluatableExpression) {\n        /**\n         * Creates a new InlineValueEvaluatableExpression literal.\n         */ function create(range, expression) {\n            return {\n                range: range,\n                expression: expression\n            };\n        }\n        InlineValueEvaluatableExpression.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);\n        }\n        InlineValueEvaluatableExpression.is = is;\n    })(InlineValueEvaluatableExpression || (exports1.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\n    /**\n     * The InlineValueContext namespace provides helper functions to work with\n     * {@link InlineValueContext} literals.\n     *\n     * @since 3.17.0\n     */ var InlineValueContext;\n    (function(InlineValueContext) {\n        /**\n         * Creates a new InlineValueContext literal.\n         */ function create(frameId, stoppedLocation) {\n            return {\n                frameId: frameId,\n                stoppedLocation: stoppedLocation\n            };\n        }\n        InlineValueContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\n        }\n        InlineValueContext.is = is;\n    })(InlineValueContext || (exports1.InlineValueContext = InlineValueContext = {}));\n    /**\n     * Inlay hint kinds.\n     *\n     * @since 3.17.0\n     */ var InlayHintKind;\n    (function(InlayHintKind) {\n        /**\n         * An inlay hint that for a type annotation.\n         */ InlayHintKind.Type = 1;\n        /**\n         * An inlay hint that is for a parameter.\n         */ InlayHintKind.Parameter = 2;\n        function is(value) {\n            return value === 1 || value === 2;\n        }\n        InlayHintKind.is = is;\n    })(InlayHintKind || (exports1.InlayHintKind = InlayHintKind = {}));\n    var InlayHintLabelPart;\n    (function(InlayHintLabelPart) {\n        function create(value) {\n            return {\n                value: value\n            };\n        }\n        InlayHintLabelPart.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));\n        }\n        InlayHintLabelPart.is = is;\n    })(InlayHintLabelPart || (exports1.InlayHintLabelPart = InlayHintLabelPart = {}));\n    var InlayHint;\n    (function(InlayHint) {\n        function create(position, label, kind) {\n            var result = {\n                position: position,\n                label: label\n            };\n            if (kind !== undefined) result.kind = kind;\n            return result;\n        }\n        InlayHint.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n        }\n        InlayHint.is = is;\n    })(InlayHint || (exports1.InlayHint = InlayHint = {}));\n    var StringValue;\n    (function(StringValue) {\n        function createSnippet(value) {\n            return {\n                kind: 'snippet',\n                value: value\n            };\n        }\n        StringValue.createSnippet = createSnippet;\n    })(StringValue || (exports1.StringValue = StringValue = {}));\n    var InlineCompletionItem;\n    (function(InlineCompletionItem) {\n        function create(insertText, filterText, range, command) {\n            return {\n                insertText: insertText,\n                filterText: filterText,\n                range: range,\n                command: command\n            };\n        }\n        InlineCompletionItem.create = create;\n    })(InlineCompletionItem || (exports1.InlineCompletionItem = InlineCompletionItem = {}));\n    var InlineCompletionList;\n    (function(InlineCompletionList) {\n        function create(items) {\n            return {\n                items: items\n            };\n        }\n        InlineCompletionList.create = create;\n    })(InlineCompletionList || (exports1.InlineCompletionList = InlineCompletionList = {}));\n    /**\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n     *\n     * @since 3.18.0\n     * @proposed\n     */ var InlineCompletionTriggerKind;\n    (function(InlineCompletionTriggerKind) {\n        /**\n         * Completion was triggered explicitly by a user gesture.\n         */ InlineCompletionTriggerKind.Invoked = 0;\n        /**\n         * Completion was triggered automatically while editing.\n         */ InlineCompletionTriggerKind.Automatic = 1;\n    })(InlineCompletionTriggerKind || (exports1.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\n    var SelectedCompletionInfo;\n    (function(SelectedCompletionInfo) {\n        function create(range, text) {\n            return {\n                range: range,\n                text: text\n            };\n        }\n        SelectedCompletionInfo.create = create;\n    })(SelectedCompletionInfo || (exports1.SelectedCompletionInfo = SelectedCompletionInfo = {}));\n    var InlineCompletionContext;\n    (function(InlineCompletionContext) {\n        function create(triggerKind, selectedCompletionInfo) {\n            return {\n                triggerKind: triggerKind,\n                selectedCompletionInfo: selectedCompletionInfo\n            };\n        }\n        InlineCompletionContext.create = create;\n    })(InlineCompletionContext || (exports1.InlineCompletionContext = InlineCompletionContext = {}));\n    var WorkspaceFolder;\n    (function(WorkspaceFolder) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n        }\n        WorkspaceFolder.is = is;\n    })(WorkspaceFolder || (exports1.WorkspaceFolder = WorkspaceFolder = {}));\n    exports1.EOL = [\n        '\\n',\n        '\\r\\n',\n        '\\r'\n    ];\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */ var TextDocument;\n    (function(TextDocument) {\n        /**\n         * Creates a new ITextDocument literal from the given uri and content.\n         * @param uri The document's uri.\n         * @param languageId The document's language Id.\n         * @param version The document's version.\n         * @param content The document's content.\n         */ function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n        }\n        TextDocument.is = is;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits, function(a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) return a.range.start.character - b.range.start.character;\n                return diff;\n            });\n            var lastModifiedOffset = text.length;\n            for(var i = sortedEdits.length - 1; i >= 0; i--){\n                var e = sortedEdits[i];\n                var startOffset = document.offsetAt(e.range.start);\n                var endOffset = document.offsetAt(e.range.end);\n                if (endOffset <= lastModifiedOffset) text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n                else throw new Error('Overlapping edit');\n                lastModifiedOffset = startOffset;\n            }\n            return text;\n        }\n        TextDocument.applyEdits = applyEdits;\n        function mergeSort(data, compare) {\n            if (data.length <= 1) // sorted\n            return data;\n            var p = data.length / 2 | 0;\n            var left = data.slice(0, p);\n            var right = data.slice(p);\n            mergeSort(left, compare);\n            mergeSort(right, compare);\n            var leftIdx = 0;\n            var rightIdx = 0;\n            var i = 0;\n            while(leftIdx < left.length && rightIdx < right.length){\n                var ret = compare(left[leftIdx], right[rightIdx]);\n                if (ret <= 0) // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n                else // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n            while(leftIdx < left.length)data[i++] = left[leftIdx++];\n            while(rightIdx < right.length)data[i++] = right[rightIdx++];\n            return data;\n        }\n    })(TextDocument || (exports1.TextDocument = TextDocument = {}));\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */ var FullTextDocument = /** @class */ function() {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function() {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function() {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function() {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function(range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function(event, version) {\n            this._content = event.text;\n            this._version = version;\n            this._lineOffsets = undefined;\n        };\n        FullTextDocument.prototype.getLineOffsets = function() {\n            if (this._lineOffsets === undefined) {\n                var lineOffsets = [];\n                var text = this._content;\n                var isLineStart = true;\n                for(var i = 0; i < text.length; i++){\n                    if (isLineStart) {\n                        lineOffsets.push(i);\n                        isLineStart = false;\n                    }\n                    var ch = text.charAt(i);\n                    isLineStart = ch === '\\r' || ch === '\\n';\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') i++;\n                }\n                if (isLineStart && text.length > 0) lineOffsets.push(text.length);\n                this._lineOffsets = lineOffsets;\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function(offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) return Position.create(0, offset);\n            while(low < high){\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) high = mid;\n                else low = mid + 1;\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            return Position.create(line, offset - lineOffsets[line]);\n        };\n        FullTextDocument.prototype.offsetAt = function(position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) return this._content.length;\n            else if (position.line < 0) return 0;\n            var lineOffset = lineOffsets[position.line];\n            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function() {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return FullTextDocument;\n    }();\n    var Is;\n    (function(Is) {\n        var toString = Object.prototype.toString;\n        function defined(value) {\n            return typeof value !== 'undefined';\n        }\n        Is.defined = defined;\n        function undefined1(value) {\n            return typeof value === 'undefined';\n        }\n        Is.undefined = undefined1;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        Is.boolean = boolean;\n        function string(value) {\n            return toString.call(value) === '[object String]';\n        }\n        Is.string = string;\n        function number(value) {\n            return toString.call(value) === '[object Number]';\n        }\n        Is.number = number;\n        function numberRange(value, min, max) {\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\n        }\n        Is.numberRange = numberRange;\n        function integer(value) {\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n        }\n        Is.integer = integer;\n        function uinteger(value) {\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n        }\n        Is.uinteger = uinteger;\n        function func(value) {\n            return toString.call(value) === '[object Function]';\n        }\n        Is.func = func;\n        function objectLiteral(value) {\n            // Strictly speaking class instances pass this check as well. Since the LSP\n            // doesn't use classes we ignore this for now. If we do we need to add something\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n            return value !== null && typeof value === 'object';\n        }\n        Is.objectLiteral = objectLiteral;\n        function typedArray(value, check) {\n            return Array.isArray(value) && value.every(check);\n        }\n        Is.typedArray = typedArray;\n    })(Is || (Is = {}));\n});\n\n},{}],\"jax2A\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Line = void 0;\nclass Line {\n    constructor(document, range){\n        this.document = document;\n        this.range = range;\n    }\n    getRange() {\n        return this.range;\n    }\n    getTextContent() {\n        return this.document.getText().substring(this.document.offsetAt(this.range.start), this.document.offsetAt(this.range.end));\n    }\n    isAfter(line) {\n        return this.range.start.line > line.range.start.line;\n    }\n    isBefore(line) {\n        return this.range.start.line < line;\n    }\n}\nexports.Line = Line;\n\n},{}],\"7JXpr\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Util = void 0;\nclass Util {\n    static isUTF8BOM(char) {\n        const uintArray = Uint8Array.from(Buffer.from(char, \"UTF-8\"));\n        return uintArray[0] === 0xEF && uintArray[1] == 0xBB && uintArray[2] == 0xBF;\n    }\n    static isWhitespace(char) {\n        return char === ' ' || char === '\\t' || Util.isNewline(char);\n    }\n    static isNewline(char) {\n        return char === '\\r' || char === '\\n';\n    }\n    static findLeadingNonWhitespace(content, escapeChar) {\n        whitespaceCheck: for(let i = 0; i < content.length; i++)switch(content.charAt(i)){\n            case ' ':\n            case '\\t':\n                continue;\n            case escapeChar:\n                escapeCheck: for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                        continue;\n                    case '\\r':\n                        // offset one more for \\r\\n\n                        i = j + 1;\n                        continue whitespaceCheck;\n                    case '\\n':\n                        i = j;\n                        continue whitespaceCheck;\n                    default:\n                        break escapeCheck;\n                }\n                // found an escape character and then reached EOF\n                return -1;\n            default:\n                return i;\n        }\n        // only possible if the content is the empty string\n        return -1;\n    }\n    /**\n     * Determines if the given position is contained within the given range.\n     *\n     * @param position the position to check\n     * @param range the range to see if the position is inside of\n     */ static isInsideRange(position, range) {\n        if (range.start.line === range.end.line) return range.start.line === position.line && range.start.character <= position.character && position.character <= range.end.character;\n        else if (range.start.line === position.line) return range.start.character <= position.character;\n        else if (range.end.line === position.line) return position.character <= range.end.character;\n        return range.start.line < position.line && position.line < range.end.line;\n    }\n    static parseHeredocName(value) {\n        value = value.substring(2);\n        if (value.charAt(0) === '-') value = value.substring(1);\n        if (value.charAt(0) === '\"') {\n            if (value.charAt(value.length - 1) !== '\"') return null;\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === '\\'') {\n            if (value.charAt(value.length - 1) !== '\\'') return null;\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === \"<\") return null;\n        return value;\n    }\n}\nexports.Util = Util;\n\n},{}],\"aGQ73\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Parser = void 0;\nconst vscode_languageserver_textdocument_1 = require(\"3eb2e9f72fa842bb\");\nconst vscode_languageserver_types_1 = require(\"34b2e1cd00de16ce\");\nconst comment_1 = require(\"9e92b8b410126e56\");\nconst parserDirective_1 = require(\"777f0037af770a91\");\nconst instruction_1 = require(\"1329dffc7d9471c6\");\nconst add_1 = require(\"5065fff407b0cdf5\");\nconst arg_1 = require(\"aa6e0b7a0eb2c8a9\");\nconst cmd_1 = require(\"62420b33948711ba\");\nconst copy_1 = require(\"44a1387c9f6642f8\");\nconst env_1 = require(\"c3c835dbabebb0c\");\nconst entrypoint_1 = require(\"a1a0bf4df6e06e65\");\nconst from_1 = require(\"ac2ea75013335655\");\nconst healthcheck_1 = require(\"fbf71dd210ee2ad2\");\nconst label_1 = require(\"17f71289f1308509\");\nconst onbuild_1 = require(\"abac336e7fc664aa\");\nconst run_1 = require(\"d4206ac9dc34f56c\");\nconst shell_1 = require(\"341b73fd8ae672e8\");\nconst stopsignal_1 = require(\"44cf25b6f2d37d9\");\nconst workdir_1 = require(\"9247ddaff67cb60c\");\nconst user_1 = require(\"b96409d6175d837f\");\nconst volume_1 = require(\"4febb7a38de581a6\");\nconst dockerfile_1 = require(\"50edac4bf8b150b0\");\nconst util_1 = require(\"f9cdab4223270f96\");\nconst main_1 = require(\"38bd78812b171580\");\nclass Parser {\n    constructor(){\n        this.escapeChar = null;\n    }\n    static createInstruction(document, dockerfile, escapeChar, lineRange, instruction, instructionRange) {\n        switch(instruction.toUpperCase()){\n            case \"ADD\":\n                return new add_1.Add(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ARG\":\n                return new arg_1.Arg(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"CMD\":\n                return new cmd_1.Cmd(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"COPY\":\n                return new copy_1.Copy(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENTRYPOINT\":\n                return new entrypoint_1.Entrypoint(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENV\":\n                return new env_1.Env(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"FROM\":\n                return new from_1.From(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"HEALTHCHECK\":\n                return new healthcheck_1.Healthcheck(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"LABEL\":\n                return new label_1.Label(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ONBUILD\":\n                return new onbuild_1.Onbuild(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"RUN\":\n                return new run_1.Run(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"SHELL\":\n                return new shell_1.Shell(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"STOPSIGNAL\":\n                return new stopsignal_1.Stopsignal(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"WORKDIR\":\n                return new workdir_1.Workdir(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"USER\":\n                return new user_1.User(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"VOLUME\":\n                return new volume_1.Volume(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n        }\n        return new instruction_1.Instruction(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getParserDirectives(document, buffer) {\n        // reset the escape directive in between runs\n        const directives = [];\n        this.escapeChar = '';\n        const offset = util_1.Util.isUTF8BOM(buffer.substring(0, 1)) ? 1 : 0;\n        directiveCheck: for(let i = offset; i < buffer.length; i++)switch(buffer.charAt(i)){\n            case ' ':\n            case '\\t':\n                break;\n            case '\\r':\n            case '\\n':\n                break directiveCheck;\n            case '#':\n                let directiveStart = -1;\n                let directiveEnd = -1;\n                for(let j = i + 1; j < buffer.length; j++){\n                    let char = buffer.charAt(j);\n                    switch(char){\n                        case ' ':\n                        case '\\t':\n                            if (directiveStart !== -1 && directiveEnd === -1) directiveEnd = j;\n                            break;\n                        case '\\r':\n                        case '\\n':\n                            break directiveCheck;\n                        case '=':\n                            let valueStart = -1;\n                            let valueEnd = -1;\n                            if (directiveEnd === -1) directiveEnd = j;\n                            // assume the line ends with the file\n                            let lineEnd = buffer.length;\n                            directiveValue: for(let k = j + 1; k < buffer.length; k++){\n                                char = buffer.charAt(k);\n                                switch(char){\n                                    case '\\r':\n                                    case '\\n':\n                                        if (valueStart !== -1 && valueEnd === -1) valueEnd = k;\n                                        // line break found, reset\n                                        lineEnd = k;\n                                        break directiveValue;\n                                    case '\\t':\n                                    case ' ':\n                                        if (valueStart !== -1 && valueEnd === -1) valueEnd = k;\n                                        continue;\n                                    default:\n                                        if (valueStart === -1) valueStart = k;\n                                        break;\n                                }\n                            }\n                            if (directiveStart === -1) break directiveCheck;\n                            if (valueStart === -1) {\n                                // no non-whitespace characters found, highlight all the characters then\n                                valueStart = j + 1;\n                                valueEnd = lineEnd;\n                            } else if (valueEnd === -1) // reached EOF\n                            valueEnd = buffer.length;\n                            const lineRange = vscode_languageserver_types_1.Range.create(document.positionAt(i), document.positionAt(lineEnd));\n                            const nameRange = vscode_languageserver_types_1.Range.create(document.positionAt(directiveStart), document.positionAt(directiveEnd));\n                            const valueRange = vscode_languageserver_types_1.Range.create(document.positionAt(valueStart), document.positionAt(valueEnd));\n                            directives.push(new parserDirective_1.ParserDirective(document, lineRange, nameRange, valueRange));\n                            directiveStart = -1;\n                            if (buffer.charAt(valueEnd) === '\\r') // skip over the \\r\n                            i = valueEnd + 1;\n                            else i = valueEnd;\n                            continue directiveCheck;\n                        default:\n                            if (directiveStart === -1) directiveStart = j;\n                            break;\n                    }\n                }\n                break;\n            default:\n                break directiveCheck;\n        }\n        return directives;\n    }\n    parse(buffer) {\n        this.document = vscode_languageserver_textdocument_1.TextDocument.create(\"\", \"\", 0, buffer);\n        this.buffer = buffer;\n        let dockerfile = new dockerfile_1.Dockerfile(this.document);\n        let directives = this.getParserDirectives(this.document, this.buffer);\n        let offset = 0;\n        this.escapeChar = '\\\\';\n        if (directives.length > 0) {\n            dockerfile.setDirectives(directives);\n            this.escapeChar = dockerfile.getEscapeCharacter();\n            // start parsing after the directives\n            offset = this.document.offsetAt(vscode_languageserver_types_1.Position.create(directives.length, 0));\n        } else if (util_1.Util.isUTF8BOM(buffer.substring(0, 1))) offset = 1;\n        for(let i = offset; i < this.buffer.length; i++){\n            const char = this.buffer.charAt(i);\n            switch(char){\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '#':\n                    i = this.processComment(dockerfile, i);\n                    break;\n                default:\n                    i = this.processInstruction(dockerfile, char, i);\n                    break;\n            }\n        }\n        dockerfile.organizeComments();\n        return dockerfile;\n    }\n    processInstruction(dockerfile, char, start) {\n        let instruction = char;\n        let instructionEnd = -1;\n        let escapedInstruction = false;\n        instructionCheck: for(let i = start + 1; i < this.buffer.length; i++){\n            char = this.buffer.charAt(i);\n            switch(char){\n                case this.escapeChar:\n                    escapedInstruction = true;\n                    char = this.buffer.charAt(i + 1);\n                    if (char === '\\r' || char === '\\n') {\n                        if (instructionEnd === -1) instructionEnd = i;\n                        i++;\n                    } else if (char === ' ' || char === '\\t') {\n                        for(let j = i + 2; j < this.buffer.length; j++)switch(this.buffer.charAt(j)){\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                i = j;\n                                continue instructionCheck;\n                            default:\n                                // found an argument, mark end of instruction\n                                instructionEnd = i + 1;\n                                instruction = instruction + this.escapeChar;\n                                i = j - 2;\n                                continue instructionCheck;\n                        }\n                        // reached EOF\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        break instructionCheck;\n                    } else {\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        // reset and consider it as one contiguous word\n                        escapedInstruction = false;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escapedInstruction) {\n                        // on an escaped newline, need to search for non-whitespace\n                        escapeCheck: for(let j = i + 1; j < this.buffer.length; j++)switch(this.buffer.charAt(j)){\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                i = j;\n                                continue instructionCheck;\n                            default:\n                                break escapeCheck;\n                        }\n                        escapedInstruction = false;\n                    }\n                    if (instructionEnd === -1) instructionEnd = i;\n                    i = this.processArguments(dockerfile, instruction, instructionEnd, start, i);\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, i));\n                    return i;\n                case '\\r':\n                case '\\n':\n                    if (escapedInstruction) continue;\n                    if (instructionEnd === -1) instructionEnd = i;\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, i, i));\n                    return i;\n                case '#':\n                    if (escapedInstruction) continue;\n                default:\n                    instructionEnd = i + 1;\n                    instruction = instruction + char;\n                    escapedInstruction = false;\n                    break;\n            }\n        }\n        // reached EOF\n        if (instructionEnd === -1) instructionEnd = this.buffer.length;\n        dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, this.buffer.length));\n        return this.buffer.length;\n    }\n    processHeredocs(instruction, offset) {\n        let keyword = instruction.getKeyword();\n        if (keyword === main_1.Keyword.ONBUILD) {\n            instruction = instruction.getTriggerInstruction();\n            if (instruction === null) return offset;\n            keyword = instruction.getKeyword();\n        }\n        if (keyword !== main_1.Keyword.ADD && keyword !== main_1.Keyword.COPY && keyword !== main_1.Keyword.RUN) return offset;\n        const heredocs = [];\n        for (const arg of instruction.getArguments()){\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && value.length > 2) {\n                const name = util_1.Util.parseHeredocName(value);\n                if (name !== null) heredocs.push(name);\n            }\n        }\n        if (heredocs.length > 0) for (const heredoc of heredocs)offset = this.parseHeredoc(heredoc, offset);\n        return offset;\n    }\n    processArguments(dockerfile, instruction, instructionEnd, start, offset) {\n        let escaped = false;\n        argumentsCheck: for(let i = offset + 1; i < this.buffer.length; i++)switch(this.buffer.charAt(i)){\n            case '\\r':\n            case '\\n':\n                if (escaped) continue;\n                return this.processHeredocs(this.createInstruction(dockerfile, instruction, start, instructionEnd, i), i);\n            case this.escapeChar:\n                const next = this.buffer.charAt(i + 1);\n                if (next === '\\n' || next === '\\r') {\n                    escaped = true;\n                    i++;\n                } else if (next === ' ' || next === '\\t') {\n                    for(let j = i + 2; j < this.buffer.length; j++)switch(this.buffer.charAt(j)){\n                        case ' ':\n                        case '\\t':\n                            break;\n                        case '\\r':\n                        case '\\n':\n                            escaped = true;\n                        default:\n                            i = j;\n                            continue argumentsCheck;\n                    }\n                    // reached EOF\n                    return this.buffer.length;\n                }\n                continue;\n            case '#':\n                if (escaped) {\n                    i = this.processComment(dockerfile, i);\n                    continue argumentsCheck;\n                }\n                break;\n            case ' ':\n            case '\\t':\n                break;\n            default:\n                if (escaped) escaped = false;\n                break;\n        }\n        return this.buffer.length;\n    }\n    processComment(dockerfile, start) {\n        let end = this.buffer.length;\n        commentLoop: for(let i = start + 1; i < this.buffer.length; i++)switch(this.buffer.charAt(i)){\n            case '\\r':\n            case '\\n':\n                end = i;\n                break commentLoop;\n        }\n        const range = vscode_languageserver_types_1.Range.create(this.document.positionAt(start), this.document.positionAt(end));\n        dockerfile.addComment(new comment_1.Comment(this.document, range));\n        return end;\n    }\n    parseHeredoc(heredocName, offset) {\n        let startWord = -1;\n        let lineStart = true;\n        for(let i = offset; i < this.buffer.length; i++)switch(this.buffer.charAt(i)){\n            case ' ':\n            case '\\t':\n                lineStart = false;\n                break;\n            case '\\r':\n            case '\\n':\n                if (startWord !== -1 && heredocName === this.buffer.substring(startWord, i)) return i;\n                startWord = -1;\n                lineStart = true;\n                break;\n            default:\n                if (lineStart) {\n                    startWord = i;\n                    lineStart = false;\n                }\n                break;\n        }\n        return this.buffer.length;\n    }\n    createInstruction(dockerfile, instruction, start, instructionEnd, end) {\n        const startPosition = this.document.positionAt(start);\n        const instructionRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(instructionEnd));\n        const lineRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(end));\n        return Parser.createInstruction(this.document, dockerfile, this.escapeChar, lineRange, instruction, instructionRange);\n    }\n}\nexports.Parser = Parser;\n\n},{\"3eb2e9f72fa842bb\":\"fnQzO\",\"34b2e1cd00de16ce\":\"ghSGy\",\"9e92b8b410126e56\":\"5T0KS\",\"777f0037af770a91\":\"jIw2h\",\"1329dffc7d9471c6\":\"hMvuU\",\"5065fff407b0cdf5\":\"gRGNk\",\"aa6e0b7a0eb2c8a9\":\"aKTxx\",\"62420b33948711ba\":\"9Gc1y\",\"44a1387c9f6642f8\":\"b3t88\",\"c3c835dbabebb0c\":\"1F4QE\",\"a1a0bf4df6e06e65\":\"a7xJN\",\"ac2ea75013335655\":\"nTyT0\",\"fbf71dd210ee2ad2\":\"bkMBh\",\"17f71289f1308509\":\"57hgN\",\"abac336e7fc664aa\":\"8eYDK\",\"d4206ac9dc34f56c\":\"bBCsY\",\"341b73fd8ae672e8\":\"j6kkx\",\"44cf25b6f2d37d9\":\"bxm6V\",\"9247ddaff67cb60c\":\"alCEF\",\"b96409d6175d837f\":\"bSHO0\",\"4febb7a38de581a6\":\"5fZdP\",\"50edac4bf8b150b0\":\"040Bk\",\"f9cdab4223270f96\":\"7JXpr\",\"38bd78812b171580\":\"1irbL\"}],\"fnQzO\":[function(require,module,exports,__globalThis) {\nvar __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) {\n        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n(function(factory) {\n    if (typeof module.exports === \"object\") {\n        var v = factory(undefined, exports);\n        if (v !== undefined) module.exports = v;\n    } else if (typeof define === \"function\" && define.amd) define([\n        \"require\",\n        \"exports\"\n    ], factory);\n})(function(require, exports1) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */ 'use strict';\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.TextDocument = void 0;\n    var FullTextDocument = /** @class */ function() {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function() {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function() {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function() {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function(range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function(changes, version) {\n            for(var _i = 0, changes_1 = changes; _i < changes_1.length; _i++){\n                var change = changes_1[_i];\n                if (FullTextDocument.isIncremental(change)) {\n                    // makes sure start is before end\n                    var range = getWellformedRange(change.range);\n                    // update content\n                    var startOffset = this.offsetAt(range.start);\n                    var endOffset = this.offsetAt(range.end);\n                    this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                    // update the offsets\n                    var startLine = Math.max(range.start.line, 0);\n                    var endLine = Math.max(range.end.line, 0);\n                    var lineOffsets = this._lineOffsets;\n                    var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                    if (endLine - startLine === addedLineOffsets.length) for(var i = 0, len = addedLineOffsets.length; i < len; i++)lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    else if (addedLineOffsets.length < 10000) lineOffsets.splice.apply(lineOffsets, __spreadArray([\n                        startLine + 1,\n                        endLine - startLine\n                    ], addedLineOffsets, false));\n                    else this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    var diff = change.text.length - (endOffset - startOffset);\n                    if (diff !== 0) for(var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++)lineOffsets[i] = lineOffsets[i] + diff;\n                } else if (FullTextDocument.isFull(change)) {\n                    this._content = change.text;\n                    this._lineOffsets = undefined;\n                } else throw new Error('Unknown change event received');\n            }\n            this._version = version;\n        };\n        FullTextDocument.prototype.getLineOffsets = function() {\n            if (this._lineOffsets === undefined) this._lineOffsets = computeLineOffsets(this._content, true);\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function(offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) return {\n                line: 0,\n                character: offset\n            };\n            while(low < high){\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) high = mid;\n                else low = mid + 1;\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n            return {\n                line: line,\n                character: offset - lineOffsets[line]\n            };\n        };\n        FullTextDocument.prototype.offsetAt = function(position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) return this._content.length;\n            else if (position.line < 0) return 0;\n            var lineOffset = lineOffsets[position.line];\n            if (position.character <= 0) return lineOffset;\n            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n            var offset = Math.min(lineOffset + position.character, nextLineOffset);\n            return this.ensureBeforeEOL(offset, lineOffset);\n        };\n        FullTextDocument.prototype.ensureBeforeEOL = function(offset, lineOffset) {\n            while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1)))offset--;\n            return offset;\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function() {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.isIncremental = function(event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n        };\n        FullTextDocument.isFull = function(event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n        };\n        return FullTextDocument;\n    }();\n    var TextDocument;\n    (function(TextDocument) {\n        /**\n         * Creates a new text document.\n         *\n         * @param uri The document's uri.\n         * @param languageId  The document's language Id.\n         * @param version The document's initial version number.\n         * @param content The document's content.\n         */ function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Updates a TextDocument by modifying its content.\n         *\n         * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n         * @param changes the changes to apply to the document.\n         * @param version the changes version for the document.\n         * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n         *\n         */ function update(document, changes, version) {\n            if (document instanceof FullTextDocument) {\n                document.update(changes, version);\n                return document;\n            } else throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n        TextDocument.update = update;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) return a.range.start.character - b.range.start.character;\n                return diff;\n            });\n            var lastModifiedOffset = 0;\n            var spans = [];\n            for(var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++){\n                var e = sortedEdits_1[_i];\n                var startOffset = document.offsetAt(e.range.start);\n                if (startOffset < lastModifiedOffset) throw new Error('Overlapping edit');\n                else if (startOffset > lastModifiedOffset) spans.push(text.substring(lastModifiedOffset, startOffset));\n                if (e.newText.length) spans.push(e.newText);\n                lastModifiedOffset = document.offsetAt(e.range.end);\n            }\n            spans.push(text.substr(lastModifiedOffset));\n            return spans.join('');\n        }\n        TextDocument.applyEdits = applyEdits;\n    })(TextDocument || (exports1.TextDocument = TextDocument = {}));\n    function mergeSort(data, compare) {\n        if (data.length <= 1) // sorted\n        return data;\n        var p = data.length / 2 | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while(leftIdx < left.length && rightIdx < right.length){\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n            else // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n        while(leftIdx < left.length)data[i++] = left[leftIdx++];\n        while(rightIdx < right.length)data[i++] = right[rightIdx++];\n        return data;\n    }\n    function computeLineOffsets(text, isAtLineStart, textOffset) {\n        if (textOffset === void 0) textOffset = 0;\n        var result = isAtLineStart ? [\n            textOffset\n        ] : [];\n        for(var i = 0; i < text.length; i++){\n            var ch = text.charCodeAt(i);\n            if (isEOL(ch)) {\n                if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) i++;\n                result.push(textOffset + i + 1);\n            }\n        }\n        return result;\n    }\n    function isEOL(char) {\n        return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;\n    }\n    function getWellformedRange(range) {\n        var start = range.start;\n        var end = range.end;\n        if (start.line > end.line || start.line === end.line && start.character > end.character) return {\n            start: end,\n            end: start\n        };\n        return range;\n    }\n    function getWellformedEdit(textEdit) {\n        var range = getWellformedRange(textEdit.range);\n        if (range !== textEdit.range) return {\n            newText: textEdit.newText,\n            range: range\n        };\n        return textEdit;\n    }\n});\n\n},{}],\"jIw2h\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ParserDirective = void 0;\nconst main_1 = require(\"83344ee6e442f65c\");\nconst line_1 = require(\"628c95531afa43c2\");\nclass ParserDirective extends line_1.Line {\n    constructor(document, range, nameRange, valueRange){\n        super(document, range);\n        this.nameRange = nameRange;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        return \"# \" + this.getName() + '=' + this.getValue();\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    getName() {\n        return this.document.getText().substring(this.document.offsetAt(this.nameRange.start), this.document.offsetAt(this.nameRange.end));\n    }\n    getValue() {\n        return this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n    }\n    getDirective() {\n        const directive = main_1.Directive[this.getName().toLowerCase()];\n        return directive === undefined ? null : directive;\n    }\n}\nexports.ParserDirective = ParserDirective;\n\n},{\"83344ee6e442f65c\":\"1irbL\",\"628c95531afa43c2\":\"jax2A\"}],\"hMvuU\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Instruction = void 0;\nconst vscode_languageserver_types_1 = require(\"75e3371b54792caa\");\nconst util_1 = require(\"fa72f15fb47197d2\");\nconst line_1 = require(\"dc037d211747d0bf\");\nconst argument_1 = require(\"674d83a5e08e316f\");\nconst heredoc_1 = require(\"f30c1c980ba59082\");\nconst variable_1 = require(\"6c1e8830b0f0285c\");\nconst main_1 = require(\"c02c05f3ca580f8f\");\nclass Instruction extends line_1.Line {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range);\n        this.dockerfile = dockerfile;\n        this.escapeChar = escapeChar;\n        this.instruction = instruction;\n        this.instructionRange = instructionRange;\n    }\n    toString() {\n        let value = this.getKeyword();\n        for (let arg of this.getRawArguments()){\n            value += ' ';\n            value += arg.getValue();\n        }\n        return value;\n    }\n    getRangeContent(range) {\n        if (range === null) return null;\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    getInstructionRange() {\n        return this.instructionRange;\n    }\n    getInstruction() {\n        return this.instruction;\n    }\n    getKeyword() {\n        return this.getInstruction().toUpperCase();\n    }\n    getArgumentsRange() {\n        let args = this.getArguments();\n        if (args.length === 0) return null;\n        return vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end);\n    }\n    getArgumentsRanges() {\n        let args = this.getArguments();\n        if (args.length === 0) return [];\n        if (args[0].getRange().start.line === args[args.length - 1].getRange().end.line) return [\n            vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end)\n        ];\n        let ranges = [];\n        let end = -1;\n        let startPosition = args[0].getRange().start;\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(startPosition) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra, this.document.offsetAt(args[args.length - 1].getRange().end) - this.document.offsetAt(range.start));\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        for(let i = 0; i < fullArgs.length; i++){\n            let char = fullArgs.charAt(i);\n            if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') whitespaceCheck: for(let j = i + 2; j < fullArgs.length; j++)switch(fullArgs.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                        continue;\n                    case '\\r':\n                        j++;\n                    case '\\n':\n                        if (startPosition !== null) ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                        startPosition = null;\n                        start = true;\n                        comment = false;\n                        i = j;\n                        break whitespaceCheck;\n                    default:\n                        break whitespaceCheck;\n                }\n                else if (next === '\\r') {\n                    if (startPosition !== null) {\n                        ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                        startPosition = null;\n                    }\n                    start = true;\n                    comment = false;\n                    i += 2;\n                } else if (next === '\\n') {\n                    if (startPosition !== null) ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                    i++;\n                } else i++;\n            } else if (util_1.Util.isNewline(char)) {\n                if (comment) {\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                }\n            } else if (!comment) {\n                if (startPosition === null) {\n                    if (char === '#') {\n                        comment = true;\n                        continue;\n                    }\n                    let position = this.document.positionAt(offset + i);\n                    if (position.character !== 0) startPosition = vscode_languageserver_types_1.Position.create(position.line, 0);\n                }\n                end = i;\n            }\n        }\n        if (startPosition === null) // should only happen if the last argument is on its own line with\n        // no leading whitespace\n        ranges.push(vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + end), this.document.positionAt(offset + end + 1)));\n        else ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n        return ranges;\n    }\n    getRawArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) return null;\n        return this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end));\n    }\n    getArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) return null;\n        let content = \"\";\n        let ranges = this.getArgumentsRanges();\n        let documentText = this.document.getText();\n        for (let range of ranges)content += documentText.substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n        return content;\n    }\n    getArguments() {\n        return this.getRawArguments();\n    }\n    getRawArguments() {\n        let args = [];\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(range.end) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        let found = -1;\n        // determines whether the parser has found a space or tab\n        // whitespace character that's a part of an escaped newline sequence\n        let escapedWhitespaceDetected = false;\n        // determines if the parser is currently in an escaped newline sequence\n        let escaping = false;\n        let escapeMarker = -1;\n        let escapedArg = \"\";\n        for(let i = 0; i < fullArgs.length; i++){\n            let char = fullArgs.charAt(i);\n            if (util_1.Util.isWhitespace(char)) {\n                if (escaping) {\n                    escapedWhitespaceDetected = true;\n                    if (util_1.Util.isNewline(char)) {\n                        // reached a newline, any previously\n                        // detected whitespace should be ignored\n                        escapedWhitespaceDetected = false;\n                        if (comment) {\n                            // reached a newline, no longer in a comment\n                            comment = false;\n                            start = true;\n                        }\n                    }\n                    continue;\n                } else if (found !== -1) {\n                    if (escapeMarker === -1) args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + i))));\n                    else args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                    escapeMarker = -1;\n                    escapedArg = \"\";\n                    found = -1;\n                }\n            } else if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') whitespaceCheck: for(let j = i + 2; j < fullArgs.length; j++){\n                    let newlineCheck = fullArgs.charAt(j);\n                    switch(newlineCheck){\n                        case ' ':\n                        case '\\t':\n                            continue;\n                        case '\\r':\n                            j++;\n                        case '\\n':\n                            comment = false;\n                            escaping = true;\n                            start = true;\n                            if (found !== -1) escapeMarker = i;\n                            i = j;\n                            break whitespaceCheck;\n                        default:\n                            escapeMarker = i;\n                            if (found === -1) i = j - 1;\n                            break whitespaceCheck;\n                    }\n                }\n                else if (next === '\\r') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) escapeMarker = i;\n                    i += 2;\n                } else if (next === '\\n') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) escapeMarker = i;\n                    i++;\n                } else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapeMarker = -1;\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    if (next === '$') escapedArg = escapedArg + char + next;\n                    else if (next === '') break;\n                    else escapedArg = escapedArg + next;\n                    if (found === -1) found = i;\n                    i++;\n                }\n            } else if (!comment) {\n                if (start && char === '#') comment = true;\n                else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    escapeMarker = -1;\n                    escapedArg = escapedArg + char;\n                    if (found === -1) found = i;\n                }\n                // non-whitespace character detected, reset\n                start = false;\n            }\n        }\n        if (found !== -1) {\n            if (escapeMarker === -1) args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + fullArgs.length))));\n            else args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n        }\n        return args;\n    }\n    getExpandedArguments() {\n        let args = this.getArguments();\n        for(let i = 0; i < args.length; i++){\n            const argRange = args[i].getRange();\n            let offset = this.document.offsetAt(argRange.start);\n            const variables = this.parseVariables(offset, args[i].getValue());\n            const swaps = [];\n            let requiresExpansion = false;\n            for (let variable of variables){\n                const value = this.dockerfile.resolveVariable(variable.getName(), variable.getNameRange().start.line);\n                swaps.push(value);\n                requiresExpansion = requiresExpansion || value !== undefined;\n            }\n            if (requiresExpansion) {\n                let expanded = \"\";\n                for(let j = 0; j < swaps.length; j++){\n                    const variableRange = variables[j].getRange();\n                    const start = this.document.offsetAt(variableRange.start);\n                    const end = this.document.offsetAt(variableRange.end);\n                    if (swaps[j]) {\n                        // replace variable with its resolved value\n                        expanded += this.document.getText().substring(offset, start);\n                        expanded += swaps[j];\n                        offset = end;\n                    } else {\n                        expanded += this.document.getText().substring(offset, end);\n                        offset = end;\n                    }\n                }\n                const argEnd = this.document.offsetAt(argRange.end);\n                if (argEnd !== offset) // if the variable's range doesn't match the argument,\n                // append the remaining text\n                expanded += this.document.getText().substring(offset, argEnd);\n                args[i] = new argument_1.Argument(expanded, argRange);\n            }\n        }\n        return args;\n    }\n    getVariables() {\n        const variables = [];\n        const args = this.getRawArguments();\n        for (const arg of args){\n            let range = arg.getRange();\n            let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n            const parsedVariables = this.parseVariables(this.document.offsetAt(arg.getRange().start), rawValue);\n            for (const parsedVariable of parsedVariables)variables.push(parsedVariable);\n        }\n        return variables;\n    }\n    parseVariables(offset, arg) {\n        let variables = [];\n        variableLoop: for(let i = 0; i < arg.length; i++)switch(arg.charAt(i)){\n            case this.escapeChar:\n                if (arg.charAt(i + 1) === '$') i++;\n                break;\n            case '$':\n                if (arg.charAt(i + 1) === '{') {\n                    let escapedString = \"${\";\n                    let escapedName = \"\";\n                    let nameEnd = -1;\n                    let escapedSubstitutionParameter = \"\";\n                    let substitutionStart = -1;\n                    let substitutionEnd = -1;\n                    let modifierRead = -1;\n                    nameLoop: for(let j = i + 2; j < arg.length; j++){\n                        let char = arg.charAt(j);\n                        switch(char){\n                            case this.escapeChar:\n                                for(let k = j + 1; k < arg.length; k++)switch(arg.charAt(k)){\n                                    case ' ':\n                                    case '\\t':\n                                    case '\\r':\n                                        continue;\n                                    case '\\n':\n                                        // escape this newline\n                                        j = k;\n                                        continue nameLoop;\n                                }\n                                break;\n                            case '}':\n                                escapedString += '}';\n                                let modifier = null;\n                                let modifierRange = null;\n                                let substitutionParameter = modifierRead !== -1 ? escapedSubstitutionParameter : null;\n                                let substitutionRange = null;\n                                if (nameEnd === -1) nameEnd = j;\n                                else if (nameEnd + 1 === j) {\n                                    modifier = \"\";\n                                    modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + nameEnd + 1), this.document.positionAt(offset + nameEnd + 1));\n                                } else {\n                                    if (substitutionStart === -1) {\n                                        // no substitution parameter found,\n                                        // but a modifier character existed,\n                                        // just offset the range by 1 from\n                                        // the modifier character\n                                        substitutionStart = modifierRead + 1;\n                                        substitutionEnd = modifierRead + 1;\n                                    } else // offset one more from the last\n                                    // character found\n                                    substitutionEnd = substitutionEnd + 1;\n                                    modifier = arg.substring(modifierRead, modifierRead + 1);\n                                    modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + modifierRead), this.document.positionAt(offset + modifierRead + 1));\n                                    substitutionRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + substitutionStart), this.document.positionAt(offset + substitutionEnd));\n                                }\n                                let start = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 2), this.document.positionAt(offset + nameEnd)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j + 1)), modifier, modifierRange, substitutionParameter, substitutionRange, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), escapedString));\n                                i = j;\n                                continue variableLoop;\n                            case ':':\n                                if (nameEnd === -1) nameEnd = j;\n                                else if (modifierRead !== -1) {\n                                    if (substitutionStart === -1) {\n                                        substitutionStart = j;\n                                        substitutionEnd = j;\n                                    } else substitutionEnd = j;\n                                    escapedSubstitutionParameter += ':';\n                                } else modifierRead = j;\n                                escapedString += ':';\n                                break;\n                            case '\\n':\n                            case '\\r':\n                            case ' ':\n                            case '\\t':\n                                break;\n                            default:\n                                if (nameEnd === -1) escapedName += char;\n                                else if (modifierRead !== -1) {\n                                    if (substitutionStart === -1) {\n                                        substitutionStart = j;\n                                        substitutionEnd = j;\n                                    } else substitutionEnd = j;\n                                    escapedSubstitutionParameter += char;\n                                } else modifierRead = j;\n                                escapedString += char;\n                                break;\n                        }\n                    }\n                    break variableLoop;\n                } else if (util_1.Util.isWhitespace(arg.charAt(i + 1)) || i === arg.length - 1) continue;\n                else {\n                    let escapedName = \"\";\n                    nameLoop: for(let j = i + 1; j < arg.length; j++){\n                        let char = arg.charAt(j);\n                        switch(char){\n                            case '\\r':\n                            case '\\n':\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '$':\n                            case '\\'':\n                            case '\"':\n                                let varStart = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                                i = j - 1;\n                                continue variableLoop;\n                            case this.escapeChar:\n                                for(let k = j + 1; k < arg.length; k++)switch(arg.charAt(k)){\n                                    case ' ':\n                                    case '\\t':\n                                    case '\\r':\n                                        continue;\n                                    case '\\n':\n                                        // escape this newline\n                                        j = k;\n                                        continue nameLoop;\n                                }\n                                // reached EOF after an escape character\n                                let start = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                                break variableLoop;\n                        }\n                        if (char.match(/^[a-z0-9_]+$/i) === null) {\n                            let varStart = this.document.positionAt(offset + i);\n                            variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                            i = j - 1;\n                            continue variableLoop;\n                        }\n                        escapedName += char;\n                    }\n                    let start = this.document.positionAt(offset + i);\n                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + arg.length)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + arg.length)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                }\n                break variableLoop;\n        }\n        return variables;\n    }\n    isBuildVariable(variable, line) {\n        if (this.getKeyword() === main_1.Keyword.FROM) {\n            for (const initialArg of this.dockerfile.getInitialARGs()){\n                const arg = initialArg;\n                const property = arg.getProperty();\n                if (property && variable === property.getName()) return true;\n            }\n            return undefined;\n        }\n        let image = this.dockerfile.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        let envs = image.getENVs();\n        for(let i = envs.length - 1; i >= 0; i--){\n            if (envs[i].isBefore(line)) for (let property of envs[i].getProperties()){\n                if (property.getName() === variable) return false;\n            }\n        }\n        let args = image.getARGs();\n        for(let i = args.length - 1; i >= 0; i--)if (args[i].isBefore(line)) {\n            let property = args[i].getProperty();\n            if (property && property.getName() === variable) return true;\n        }\n        return undefined;\n    }\n    createSingleLineHeredocs(args) {\n        const heredocs = [];\n        // instruction only on one line, if heredocs exist they would be incomplete\n        for (const arg of args){\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && util_1.Util.parseHeredocName(value) !== null) {\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n            }\n        }\n        return heredocs;\n    }\n    getName(nameRange) {\n        const content = this.document.getText(nameRange);\n        let escaping = false;\n        let name = \"\";\n        nameLoop: for(let i = 0; i < content.length; i++){\n            const ch = content.charAt(i);\n            switch(ch){\n                case this.escapeChar:\n                    escaping = true;\n                    for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case ' ':\n                        case '\\t':\n                            break;\n                        case '\\r':\n                            i = j + 1;\n                            continue nameLoop;\n                        case '\\n':\n                            i = j;\n                            continue nameLoop;\n                        default:\n                            name += content.charAt(j);\n                            i = j;\n                            continue nameLoop;\n                    }\n                    break;\n                case '#':\n                    if (escaping) for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case '\\n':\n                            i = j;\n                            continue nameLoop;\n                    }\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    if (escaping) break;\n                default:\n                    name += ch;\n                    break;\n            }\n        }\n        return name;\n    }\n    getNameRange(startRange) {\n        const content = this.document.getText(startRange);\n        let endFound = false;\n        let searchHyphen = false;\n        let start = -1;\n        let end = -1;\n        let escaping = false;\n        let quote = null;\n        contentLoop: for(let i = 0; i < content.length; i++){\n            const ch = content.charAt(i);\n            switch(ch){\n                case '\"':\n                case '\\'':\n                    if (quote === ch) break contentLoop;\n                    quote = ch;\n                    continue;\n                case this.escapeChar:\n                    for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case '\\n':\n                            escaping = true;\n                            j = i;\n                            continue contentLoop;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '<':\n                    if (endFound) searchHyphen = true;\n                    else endFound = true;\n                    break;\n                case '-':\n                    if (searchHyphen) {\n                        searchHyphen = false;\n                        break;\n                    }\n                case '#':\n                    if (escaping) for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case '\\n':\n                            i = j;\n                            continue contentLoop;\n                    }\n                default:\n                    if (start === -1) start = i;\n                    if (quote !== null) {\n                        end = i + 1;\n                        break;\n                    }\n                    break contentLoop;\n            }\n        }\n        if (start === -1) return vscode_languageserver_types_1.Range.create(startRange.end, startRange.end);\n        const nameStart = this.document.positionAt(this.document.offsetAt(startRange.start) + start);\n        const nameEnd = quote !== null ? this.document.positionAt(this.document.offsetAt(startRange.start) + end) : startRange.end;\n        return vscode_languageserver_types_1.Range.create(nameStart, nameEnd);\n    }\n    getHeredocs() {\n        const args = this.getArguments();\n        if (args.length === 0) return [];\n        const heredocs = [];\n        const range = this.getRange();\n        if (range.start.line === range.end.line) // instruction only on one line, if heredocs exist they would be incomplete\n        return this.createSingleLineHeredocs(args);\n        const heredocDefinitions = [];\n        let heredocsProcessed = false;\n        let escaping = false;\n        let contentStart = -1;\n        let contentEnd = -1;\n        let lineStart = -1;\n        let currentHeredoc = 0;\n        const startOffset = this.document.offsetAt(args[0].getRange().start);\n        const content = this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end));\n        contentLoop: for(let i = 0; i < content.length; i++)switch(content.charAt(i)){\n            case this.escapeChar:\n                escaping = true;\n                for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                        break;\n                    case '\\r':\n                        j++;\n                    case '\\n':\n                        i = j;\n                        continue contentLoop;\n                    default:\n                        i = j;\n                        continue contentLoop;\n                }\n                break;\n            case '\\r':\n                break;\n            case '\\n':\n                if (escaping) break;\n                if (heredocsProcessed) {\n                    if (contentStart === -1) contentStart = i;\n                    contentEnd = i;\n                    const arg = heredocDefinitions[currentHeredoc];\n                    const startRange = arg.getRange();\n                    const nameRange = this.getNameRange(startRange);\n                    const name = this.getName(nameRange);\n                    const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), this.document.positionAt(startOffset + i)));\n                    if (delimiterRange !== null) {\n                        const contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + lineStart - 1));\n                        heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n                        contentStart = -1;\n                        currentHeredoc++;\n                    }\n                    lineStart = -1;\n                } else {\n                    // found a newline that hasn't been escaped,\n                    // must be in a heredoc\n                    const offsetLimit = startOffset + i;\n                    for (const arg of args){\n                        // check if this argument is on the initial line of the instruction,\n                        // note that it may not all be on the same line due to escaped newlines,\n                        // because of that we need to use offset checks instead of line checks\n                        // as an argument being on a different line in the document does not\n                        // imply it is on a different line from the Dockerfile's point of view\n                        if (this.document.offsetAt(arg.getRange().start) < offsetLimit) {\n                            if (arg.getValue().startsWith(\"<<\")) heredocDefinitions.push(arg);\n                        } else break;\n                    }\n                    heredocsProcessed = true;\n                    lineStart = -1;\n                    continue contentLoop;\n                }\n                break;\n            case ' ':\n            case '\\t':\n                if (escaping) break;\n            case '#':\n                if (escaping) for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                    case '\\n':\n                        i = j;\n                        continue contentLoop;\n                }\n            default:\n                if (escaping) escaping = false;\n                if (heredocsProcessed) {\n                    if (contentStart === -1) contentStart = i;\n                    if (lineStart === -1) lineStart = i;\n                }\n                break;\n        }\n        if (heredocsProcessed) {\n            const arg = heredocDefinitions[currentHeredoc];\n            const startRange = arg.getRange();\n            const nameRange = this.getNameRange(startRange);\n            const name = this.getName(nameRange);\n            let contentRange = null;\n            // check if the last line of this instruction matches the name of the last heredoc\n            const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), range.end));\n            if (delimiterRange === null) contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), range.end);\n            else if (contentEnd !== -1) contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + contentEnd));\n            heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n            currentHeredoc++;\n            for(let i = currentHeredoc; i < heredocDefinitions.length; i++){\n                const arg = heredocDefinitions[currentHeredoc];\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n                currentHeredoc++;\n            }\n        } else // instruction only on one line, if heredocs exist they would be incomplete\n        return this.createSingleLineHeredocs(args);\n        return heredocs;\n    }\n    getDelimiterRange(startArg, name, candidateRange) {\n        const text = this.document.getText(candidateRange);\n        if (startArg.getValue().startsWith(\"<<-\")) {\n            // remove tabs in the front\n            let index = 0;\n            while(text.charAt(index) === '\\t')index++;\n            if (text.substring(index) === name) return vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(candidateRange.start.line, index), candidateRange.end);\n            return null;\n        }\n        return text === name ? candidateRange : null;\n    }\n}\nexports.Instruction = Instruction;\n\n},{\"75e3371b54792caa\":\"ghSGy\",\"fa72f15fb47197d2\":\"7JXpr\",\"dc037d211747d0bf\":\"jax2A\",\"674d83a5e08e316f\":\"j0TZA\",\"f30c1c980ba59082\":\"f2Bvm\",\"6c1e8830b0f0285c\":\"eGHet\",\"c02c05f3ca580f8f\":\"1irbL\"}],\"f2Bvm\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Heredoc = void 0;\n/**\n * Heredoc represents a here-document that has been embedded in a\n * Dockerfile.\n *\n * This API is experimental and subject to change.\n */ class Heredoc {\n    constructor(startRange, name, nameRange, contentRange, endRange){\n        this.startRange = startRange;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.contentRange = contentRange;\n        this.endRange = endRange;\n    }\n    /**\n     * Returns the name of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */ getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range of the start operator and the name. If the\n     * here-document is initialized with <<EOT then the start range would\n     * encompass all five characters.\n     *\n     * This API is experimental and subject to change.\n     */ getStartRange() {\n        return this.startRange;\n    }\n    /**\n     * Returns the range of this here-document's name that is declared at\n     * the beginning of the here-document with the operator. If the\n     * here-document is initialized with <<EOT then the name range would\n     * encompass the latter three \"EOT\" characters.\n     *\n     * This API is experimental and subject to change.\n     */ getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the content of this here-document. This may\n     * be null if the here-document has no content because:\n     * - the start range is the only thing that was declared\n     * - the end range was declared immediately and there is no content\n     *\n     * This API is experimental and subject to change.\n     */ getContentRange() {\n        return this.contentRange;\n    }\n    /**\n     * Returns the range of the here-document's name on a line that\n     * represents the end of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */ getDelimiterRange() {\n        return this.endRange;\n    }\n}\nexports.Heredoc = Heredoc;\n\n},{}],\"eGHet\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Variable = void 0;\nclass Variable {\n    constructor(name, nameRange, range, modifier, modifierRange, substitutionParameter, substitutionRange, defined, buildVariable, stringValue){\n        this.name = name;\n        this.nameRange = nameRange;\n        this.range = range;\n        this.modifier = modifier;\n        this.modifierRange = modifierRange;\n        this.substitutionParameter = substitutionParameter;\n        this.substitutionRange = substitutionRange;\n        this.defined = defined;\n        this.buildVariable = buildVariable;\n        this.stringValue = stringValue;\n    }\n    toString() {\n        return this.stringValue;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the entire variable. This includes the symbols for\n     * the declaration of the variable such as the $, {, and } symbols.\n     *\n     * @return the range in the document that this variable encompasses in its\n     *         entirety\n     */ getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the modifier character that has been set for\n     * specifying how this variable should be expanded and resolved.\n     * If this variable is ${variable:+value} then the modifier\n     * character is '+'. Will be the empty string if the variable is\n     * declared as ${variable:}. Otherwise, will be null if this\n     * variable will not use variable substitution at all (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's modifier character, or the empty\n     *         string if it does not have one, or null if this\n     *         variable will not use variable substitution\n     */ getModifier() {\n        return this.modifier;\n    }\n    getModifierRange() {\n        return this.modifierRange;\n    }\n    /**\n     * Returns the parameter that will be used for substitution if\n     * this variable uses modifiers to define how its value should be\n     * resolved. If this variable is ${variable:+value} then the\n     * substitution value will be 'value'. Will be the empty string\n     * if the variable is declared as ${variable:+} or some other\n     * variant where the only thing that follows the modifier\n     * character (excluding considerations of escape characters and\n     * so on) is the variable's closing bracket. May be null if this\n     * variable does not have a modifier character defined (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's substitution parameter, or the empty\n     *         string if it does not have one, or null if there is\n     *         not one defined\n     */ getSubstitutionParameter() {\n        return this.substitutionParameter;\n    }\n    getSubstitutionRange() {\n        return this.substitutionRange;\n    }\n    /**\n     * Returns whether this variable has been defined or not.\n     *\n     * @return true if this variable has been defined, false otherwise\n     */ isDefined() {\n        return this.defined;\n    }\n    isBuildVariable() {\n        return this.buildVariable === true;\n    }\n    isEnvironmentVariable() {\n        return this.buildVariable === false;\n    }\n}\nexports.Variable = Variable;\n\n},{}],\"gRGNk\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Add = void 0;\nconst jsonInstruction_1 = require(\"45edbc923db84bc5\");\nclass Add extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n}\nexports.Add = Add;\n\n},{\"45edbc923db84bc5\":\"jxSFH\"}],\"jxSFH\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.JSONInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"b67afa726af51201\");\nconst argument_1 = require(\"92c9241da20c9f3\");\nconst jsonArgument_1 = require(\"87f92bbce16b9f06\");\nconst modifiableInstruction_1 = require(\"96353d5546ff94dc\");\nclass JSONInstruction extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.openingBracket = null;\n        this.closingBracket = null;\n        this.jsonStrings = [];\n        const argsContent = this.getRawArgumentsContent();\n        if (argsContent === null) return;\n        const args = this.getArguments();\n        if (args.length === 1 && args[0].getValue() === \"[]\") {\n            let argRange = args[0].getRange();\n            this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character, argRange.start.line, argRange.start.character + 1));\n            this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character + 1, argRange.end.line, argRange.end.character));\n            return;\n        } else if (args.length === 2 && args[0].getValue() === '[' && args[1].getValue() === ']') {\n            this.openingBracket = args[0];\n            this.closingBracket = args[1];\n            return;\n        }\n        const argsOffset = document.offsetAt(this.getArgumentsRange().start);\n        let start = -1;\n        let last = \"\";\n        let quoted = false;\n        let escapedArg = \"\";\n        argsCheck: for(let i = 0; i < argsContent.length; i++){\n            let char = argsContent.charAt(i);\n            switch(char){\n                case '[':\n                    if (last === \"\") {\n                        this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        last = '[';\n                    } else if (quoted) escapedArg = escapedArg + char;\n                    else break argsCheck;\n                    break;\n                case '\"':\n                    if (last === '[' || last === ',') {\n                        start = i;\n                        quoted = true;\n                        last = '\"';\n                        escapedArg = escapedArg + char;\n                        continue;\n                    } else if (last === '\"') {\n                        if (quoted) {\n                            escapedArg = escapedArg + char;\n                            // quoted string done\n                            quoted = false;\n                            this.jsonStrings.push(new jsonArgument_1.JSONArgument(escapedArg, vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start), document.positionAt(argsOffset + i + 1)), vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start + 1), document.positionAt(argsOffset + i))));\n                            escapedArg = \"\";\n                        } else break argsCheck;\n                    } else break argsCheck;\n                    break;\n                case ',':\n                    if (quoted) escapedArg = escapedArg + char;\n                    else {\n                        if (last === '\"') last = ',';\n                        else break argsCheck;\n                    }\n                    break;\n                case ']':\n                    if (quoted) escapedArg = escapedArg + char;\n                    else if (last !== \"\") {\n                        this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        break argsCheck;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    break;\n                case '\\\\':\n                    if (quoted) switch(argsContent.charAt(i + 1)){\n                        case '\"':\n                        case '\\\\':\n                            escapedArg = escapedArg + argsContent.charAt(i + 1);\n                            i++;\n                            continue;\n                        case ' ':\n                        case '\\t':\n                            escapeCheck: for(let j = i + 2; j < argsContent.length; j++)switch(argsContent.charAt(j)){\n                                case '\\r':\n                                    // offset one more for \\r\\n\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    continue argsCheck;\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    break escapeCheck;\n                            }\n                            break;\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            i++;\n                        default:\n                            i++;\n                            continue;\n                    }\n                    else escapeCheck: for(let j = i + 1; j < argsContent.length; j++)switch(argsContent.charAt(j)){\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            j++;\n                        case '\\n':\n                            i = j;\n                            continue argsCheck;\n                        case ' ':\n                        case '\\t':\n                            break;\n                        default:\n                            break escapeCheck;\n                    }\n                    break argsCheck;\n                default:\n                    if (!quoted) break argsCheck;\n                    escapedArg = escapedArg + char;\n                    break;\n            }\n        }\n    }\n    stopSearchingForFlags(_value) {\n        return true;\n    }\n    getOpeningBracket() {\n        return this.openingBracket;\n    }\n    getJSONStrings() {\n        return this.jsonStrings;\n    }\n    getClosingBracket() {\n        return this.closingBracket;\n    }\n}\nexports.JSONInstruction = JSONInstruction;\n\n},{\"b67afa726af51201\":\"ghSGy\",\"92c9241da20c9f3\":\"j0TZA\",\"87f92bbce16b9f06\":\"58ALy\",\"96353d5546ff94dc\":\"hJrte\"}],\"hJrte\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ModifiableInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"855ac039bce5641c\");\nconst flag_1 = require(\"709209d535932d47\");\nconst instruction_1 = require(\"e9069bd7c795ab09\");\nclass ModifiableInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getFlags() {\n        if (!this.flags) {\n            this.flags = [];\n            for (let arg of this.getArguments()){\n                let value = arg.getValue();\n                if (this.stopSearchingForFlags(value)) return this.flags;\n                else if (value.indexOf(\"--\") === 0) {\n                    let range = arg.getRange();\n                    let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n                    let nameIndex = value.indexOf('=');\n                    let index = rawValue.indexOf('=');\n                    let firstMatch = false;\n                    let secondMatch = false;\n                    let startIndex = -1;\n                    nameSearchLoop: for(let i = 0; i < rawValue.length; i++)switch(rawValue.charAt(i)){\n                        case '\\\\':\n                        case ' ':\n                        case '\\t':\n                        case '\\r':\n                        case '\\n':\n                            break;\n                        case '-':\n                            if (secondMatch) {\n                                startIndex = i;\n                                break nameSearchLoop;\n                            } else if (firstMatch) secondMatch = true;\n                            else firstMatch = true;\n                            break;\n                        default:\n                            startIndex = i;\n                            break nameSearchLoop;\n                    }\n                    let nameStart = this.document.positionAt(this.document.offsetAt(range.start) + startIndex);\n                    if (index === -1) this.flags.push(new flag_1.Flag(this.document, range, value.substring(2), vscode_languageserver_types_1.Range.create(nameStart, range.end), null, null));\n                    else if (index === value.length - 1) {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, index), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), \"\", vscode_languageserver_types_1.Range.create(range.end, range.end)));\n                    } else {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, nameIndex), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), value.substring(nameIndex + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(this.document.offsetAt(range.start) + index + 1), range.end)));\n                    }\n                }\n            }\n        }\n        return this.flags;\n    }\n    getArguments() {\n        const args = super.getArguments();\n        const flags = this.getFlags();\n        if (flags.length === 0) return args;\n        for(let i = 0; i < flags.length; i++)args.shift();\n        return args;\n    }\n}\nexports.ModifiableInstruction = ModifiableInstruction;\n\n},{\"855ac039bce5641c\":\"ghSGy\",\"709209d535932d47\":\"2WqAd\",\"e9069bd7c795ab09\":\"hMvuU\"}],\"2WqAd\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Flag = void 0;\nconst vscode_languageserver_types_1 = require(\"4b50d54787c41ee7\");\nconst flagOption_1 = require(\"b99c8b3ac173456d\");\nclass Flag {\n    constructor(document, range, name, nameRange, value, valueRange){\n        this.options = [];\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n        if (this.value !== null) {\n            let offset = document.offsetAt(valueRange.start);\n            let nameStart = -1;\n            let valueStart = -1;\n            let hasOptions = false;\n            for(let i = 0; i < value.length; i++)switch(value.charAt(i)){\n                case '=':\n                    hasOptions = true;\n                    if (valueStart === -1) {\n                        valueStart = i + 1;\n                        break;\n                    }\n                    break;\n                case ',':\n                    this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, i));\n                    nameStart = -1;\n                    valueStart = -1;\n                    break;\n                default:\n                    if (nameStart === -1) nameStart = i;\n                    break;\n            }\n            if (hasOptions && nameStart !== -1) this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, value.length));\n        }\n    }\n    createFlagOption(document, content, documentOffset, nameStart, valueStart, valueEnd) {\n        const optionRange = vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueEnd));\n        if (valueStart === -1) return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueEnd), optionRange, null, null);\n        return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueStart - 1), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueStart - 1)), content.substring(valueStart, valueEnd), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + valueStart), document.positionAt(documentOffset + valueEnd)));\n    }\n    toString() {\n        if (this.valueRange) return \"--\" + this.name + \"=\" + this.value;\n        return \"--\" + this.name;\n    }\n    /**\n     * Returns the range that encompasses this entire flag. This includes the\n     * -- prefix in the beginning to the last character of the flag's value (if\n     * it has been defined).\n     *\n     * @return the entire range of this flag\n     */ getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the name of this flag. The name does not include the -- prefix.\n     * Thus, for HEALTHCHECK's --interval flag, interval is the flag's name and\n     * not --interval.\n     *\n     * @return this flag's name\n     */ getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range that encompasses the flag's name\n     *\n     * @return the range containing the flag's name\n     */ getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the value that has been set to this flag. May be null if the\n     * flag is invalid and has no value set like a --start-period. If the flag\n     * is instead a --start-period= with an equals sign then the flag's value\n     * is the empty string.\n     *\n     * @return this flag's value if it has been defined, null otherwise\n     */ getValue() {\n        return this.value;\n    }\n    /**\n     * Returns the range that encompasses this flag's value. If no value has\n     * been set then null will be returned.\n     *\n     * @return the range containing this flag's value, or null if the flag\n     *         has no value defined\n     */ getValueRange() {\n        return this.valueRange;\n    }\n    getOption(name) {\n        for (const option of this.options){\n            if (option.getName() === name) return option;\n        }\n        return null;\n    }\n    getOptions() {\n        return this.options;\n    }\n    hasOptions() {\n        return this.options.length > 0;\n    }\n}\nexports.Flag = Flag;\n\n},{\"4b50d54787c41ee7\":\"ghSGy\",\"b99c8b3ac173456d\":\"epAH1\"}],\"epAH1\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.FlagOption = void 0;\nclass FlagOption {\n    constructor(range, name, nameRange, value, valueRange){\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        if (this.valueRange !== null) return this.name + \"=\" + this.value;\n        return this.name;\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n}\nexports.FlagOption = FlagOption;\n\n},{}],\"aKTxx\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Arg = void 0;\nconst property_1 = require(\"80085cc42a36e81\");\nconst propertyInstruction_1 = require(\"7526e7dfe4901c29\");\nclass Arg extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.property = null;\n        const args = this.getPropertyArguments();\n        if (args.length === 1) this.property = new property_1.Property(this.document, this.escapeChar, args[0]);\n        else this.property = null;\n    }\n    /**\n     * Returns the variable defined by this ARG. This may be null if\n     * this ARG instruction is malformed and has no variable\n     * declaration.\n     */ getProperty() {\n        return this.property;\n    }\n}\nexports.Arg = Arg;\n\n},{\"80085cc42a36e81\":\"gy5Z3\",\"7526e7dfe4901c29\":\"hOqfp\"}],\"gy5Z3\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Property = void 0;\nconst vscode_languageserver_types_1 = require(\"e172fc4caa74424\");\nconst util_1 = require(\"554d16feb7eb1735\");\nclass Property {\n    constructor(document, escapeChar, arg, arg2){\n        this.assignmentOperatorRange = null;\n        this.assignmentOperator = null;\n        this.valueRange = null;\n        this.value = null;\n        this.document = document;\n        this.escapeChar = escapeChar;\n        this.nameRange = Property.getNameRange(document, arg);\n        let value = document.getText().substring(document.offsetAt(this.nameRange.start), document.offsetAt(this.nameRange.end));\n        this.name = Property.getValue(value, escapeChar);\n        if (arg2) {\n            this.valueRange = arg2.getRange();\n            value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n            this.value = Property.getValue(value, escapeChar);\n            this.range = vscode_languageserver_types_1.Range.create(this.nameRange.start, this.valueRange.end);\n        } else {\n            let argRange = arg.getRange();\n            if (this.nameRange.start.line === argRange.start.line && this.nameRange.start.character === argRange.start.character && this.nameRange.end.line === argRange.end.line && this.nameRange.end.character === argRange.end.character) ;\n            else {\n                this.valueRange = Property.getValueRange(document, arg);\n                value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n                this.value = Property.getValue(value, escapeChar);\n                this.assignmentOperatorRange = vscode_languageserver_types_1.Range.create(this.nameRange.end, this.valueRange.start);\n                this.assignmentOperator = \"=\";\n            }\n            this.range = argRange;\n        }\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    /**\n     * Retrieves the operator used for delimiting between the name and\n     * value of this property. This will either be the \"=\" character\n     * or null if a character was not used or if this property has no\n     * value defined.\n     */ getAssignmentOperator() {\n        return this.assignmentOperator;\n    }\n    getAssignmentOperatorRange() {\n        return this.assignmentOperatorRange;\n    }\n    /**\n     * Returns the value of this property including any enclosing\n     * single or double quotes and relevant escape characters.\n     * Escaped newlines and its associated contiguous whitespace\n     * characters however will not be returned as they are deemed to\n     * be uninteresting to clients trying to return a Dockerfile.\n     *\n     * @return the unescaped value of this property or null if this\n     *         property has no associated value\n     */ getUnescapedValue() {\n        if (this.valueRange === null) return null;\n        let escaped = false;\n        let rawValue = \"\";\n        let value = this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n        rawLoop: for(let i = 0; i < value.length; i++){\n            let char = value.charAt(i);\n            switch(char){\n                case this.escapeChar:\n                    for(let j = i + 1; j < value.length; j++)switch(value.charAt(j)){\n                        case '\\r':\n                            j++;\n                        case '\\n':\n                            escaped = true;\n                            i = j;\n                            continue rawLoop;\n                        case ' ':\n                        case '\\t':\n                            break;\n                        default:\n                            rawValue = rawValue + char;\n                            continue rawLoop;\n                    }\n                    // this happens if there's only whitespace after the escape character\n                    rawValue = rawValue + char;\n                    break;\n                case '\\r':\n                case '\\n':\n                    break;\n                case ' ':\n                case '\\t':\n                    if (!escaped) rawValue = rawValue + char;\n                    break;\n                case '#':\n                    if (escaped) for(let j = i + 1; j < value.length; j++)switch(value.charAt(j)){\n                        case '\\r':\n                            j++;\n                        case '\\n':\n                            i = j;\n                            continue rawLoop;\n                    }\n                    else rawValue = rawValue + char;\n                    break;\n                default:\n                    rawValue = rawValue + char;\n                    escaped = false;\n                    break;\n            }\n        }\n        return rawValue;\n    }\n    static getNameRange(document, arg) {\n        let value = arg.getValue();\n        let index = value.indexOf('=');\n        if (index !== -1) {\n            let initial = value.charAt(0);\n            let before = value.charAt(index - 1);\n            // check if content before the equals sign are in quotes\n            // \"var\"=value\n            // 'var'=value\n            // otherwise, just assume it's a standard definition\n            // var=value\n            if (initial === '\"' && before === '\"' || initial === '\\'' && before === '\\'' || initial !== '\"' && initial !== '\\'') return vscode_languageserver_types_1.Range.create(arg.getRange().start, document.positionAt(document.offsetAt(arg.getRange().start) + index));\n        }\n        // no '=' found, just defined the property's name\n        return arg.getRange();\n    }\n    static getValueRange(document, arg) {\n        return vscode_languageserver_types_1.Range.create(document.positionAt(document.offsetAt(arg.getRange().start) + arg.getValue().indexOf('=') + 1), document.positionAt(document.offsetAt(arg.getRange().end)));\n    }\n    /**\n     * Returns the actual value of this key-value pair. The value will\n     * have its escape characters removed if applicable. If the value\n     * spans multiple lines and there are comments nested within the\n     * lines, they too will be removed.\n     *\n     * @return the value that this key-value pair will actually be, may\n     *         be null if no value is defined, may be the empty string\n     *         if the value only consists of whitespace\n     */ static getValue(value, escapeChar) {\n        let escaped = false;\n        const skip = util_1.Util.findLeadingNonWhitespace(value, escapeChar);\n        if (skip !== 0 && value.charAt(skip) === '#') // need to skip over comments\n        escaped = true;\n        value = value.substring(skip);\n        let first = value.charAt(0);\n        let last = value.charAt(value.length - 1);\n        let literal = first === '\\'' || first === '\"';\n        let inSingle = first === '\\'' && last === '\\'';\n        let inDouble = false;\n        if (first === '\"') for(let i = 1; i < value.length; i++){\n            if (value.charAt(i) === escapeChar) i++;\n            else if (value.charAt(i) === '\"' && i === value.length - 1) inDouble = true;\n        }\n        if (inSingle || inDouble) value = value.substring(1, value.length - 1);\n        let commentCheck = -1;\n        let escapedValue = \"\";\n        let start = 0;\n        parseValue: for(let i = 0; i < value.length; i++){\n            let char = value.charAt(i);\n            switch(char){\n                case escapeChar:\n                    if (i + 1 === value.length) {\n                        escapedValue = escapedValue + escapeChar;\n                        break parseValue;\n                    }\n                    char = value.charAt(i + 1);\n                    if (char === ' ' || char === '\\t') whitespaceCheck: for(let j = i + 2; j < value.length; j++){\n                        let char2 = value.charAt(j);\n                        switch(char2){\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                escaped = true;\n                                i = j;\n                                continue parseValue;\n                            default:\n                                if (!inDouble && !inSingle && !literal) {\n                                    if (char2 === escapeChar) {\n                                        // add the escaped character\n                                        escapedValue = escapedValue + char;\n                                        // now start parsing from the next escape character\n                                        i = i + 1;\n                                    } else {\n                                        // the expectation is that this j = i + 2 here\n                                        escapedValue = escapedValue + char + char2;\n                                        i = j;\n                                    }\n                                    continue parseValue;\n                                }\n                                break whitespaceCheck;\n                        }\n                    }\n                    if (inDouble) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        } else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        } else if (char !== '\"') {\n                            if (char === escapeChar) i++;\n                            escapedValue = escapedValue + escapeChar;\n                        }\n                        continue parseValue;\n                    } else if (inSingle || literal) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        } else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        } else escapedValue = escapedValue + escapeChar;\n                        continue parseValue;\n                    } else if (char === escapeChar) {\n                        // double escape, append one and move on\n                        escapedValue = escapedValue + escapeChar;\n                        i++;\n                    } else if (char === '\\r') {\n                        escaped = true;\n                        // offset one more for \\r\\n\n                        i = i + 2;\n                    } else if (char === '\\n') {\n                        escaped = true;\n                        i++;\n                        start = i;\n                    } else {\n                        // any other escapes are simply ignored\n                        escapedValue = escapedValue + char;\n                        i++;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escaped && commentCheck === -1) commentCheck = i;\n                    escapedValue = escapedValue + char;\n                    break;\n                case '\\r':\n                    i++;\n                case '\\n':\n                    if (escaped && commentCheck !== -1) {\n                        // rollback and remove the whitespace that was previously appended\n                        escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck - 1));\n                        commentCheck = -1;\n                    }\n                    break;\n                case '#':\n                    // a newline was escaped and now there's a comment\n                    if (escaped) {\n                        if (commentCheck !== -1) {\n                            // rollback and remove the whitespace that was previously appended\n                            escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck));\n                            commentCheck = -1;\n                        }\n                        newlineCheck: for(let j = i + 1; j < value.length; j++)switch(value.charAt(j)){\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                i = j;\n                                break newlineCheck;\n                        }\n                        continue parseValue;\n                    }\n                default:\n                    if (escaped) {\n                        escaped = false;\n                        commentCheck = -1;\n                    }\n                    escapedValue = escapedValue + char;\n                    break;\n            }\n        }\n        return escapedValue;\n    }\n}\nexports.Property = Property;\n\n},{\"e172fc4caa74424\":\"ghSGy\",\"554d16feb7eb1735\":\"7JXpr\"}],\"hOqfp\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PropertyInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"fb005c0263efbd46\");\nconst instruction_1 = require(\"ae3a92d2c36b7ea3\");\nconst property_1 = require(\"39497e57ce0ffacf\");\nconst argument_1 = require(\"2f89de63f1f8e904\");\nconst util_1 = require(\"ca53fbc43fccdebf\");\nclass PropertyInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.properties = undefined;\n    }\n    getProperties() {\n        if (this.properties === undefined) {\n            let args = this.getPropertyArguments();\n            if (args.length === 0) this.properties = [];\n            else if (args.length === 1) this.properties = [\n                new property_1.Property(this.document, this.escapeChar, args[0])\n            ];\n            else if (args.length === 2) {\n                if (args[0].getValue().indexOf('=') === -1) this.properties = [\n                    new property_1.Property(this.document, this.escapeChar, args[0], args[1])\n                ];\n                else this.properties = [\n                    new property_1.Property(this.document, this.escapeChar, args[0]),\n                    new property_1.Property(this.document, this.escapeChar, args[1])\n                ];\n            } else if (args[0].getValue().indexOf('=') === -1) {\n                let text = this.document.getText();\n                let start = args[1].getRange().start;\n                let end = args[args.length - 1].getRange().end;\n                text = text.substring(this.document.offsetAt(start), this.document.offsetAt(end));\n                this.properties = [\n                    new property_1.Property(this.document, this.escapeChar, args[0], new argument_1.Argument(text, vscode_languageserver_types_1.Range.create(args[1].getRange().start, args[args.length - 1].getRange().end)))\n                ];\n            } else {\n                this.properties = [];\n                for(let i = 0; i < args.length; i++)this.properties.push(new property_1.Property(this.document, this.escapeChar, args[i]));\n            }\n        }\n        return this.properties;\n    }\n    /**\n     * Goes from the back of the string and returns the first\n     * non-whitespace character that is found. If an escape character\n     * is found with newline characters, the escape character will\n     * not be considered a non-whitespace character and its index in\n     * the string will not be returned.\n     *\n     * @param content the string to search through\n     * @return the index in the string for the first non-whitespace\n     *         character when searching from the end of the string\n     */ findTrailingNonWhitespace(content) {\n        // loop back to find the first non-whitespace character\n        let index = content.length;\n        whitespaceCheck: for(let i = content.length - 1; i >= 0; i--)switch(content.charAt(i)){\n            case ' ':\n            case '\\t':\n                continue;\n            case '\\n':\n                if (content.charAt(i - 1) === '\\r') i = i - 1;\n            case '\\r':\n                newlineCheck: for(let j = i - 1; j >= 0; j--)switch(content.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                    case '\\r':\n                    case '\\n':\n                    case this.escapeChar:\n                        continue;\n                    default:\n                        index = j;\n                        break newlineCheck;\n                }\n                break whitespaceCheck;\n            default:\n                index = i;\n                break whitespaceCheck;\n        }\n        return index;\n    }\n    getPropertyArguments() {\n        const args = [];\n        let range = this.getInstructionRange();\n        let instructionNameEndOffset = this.document.offsetAt(range.end);\n        let extra = instructionNameEndOffset - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let start = util_1.Util.findLeadingNonWhitespace(fullArgs, this.escapeChar);\n        if (start === -1) // only whitespace found, no arguments\n        return [];\n        const startPosition = this.document.positionAt(instructionNameEndOffset + start);\n        // records whether the parser has just processed an escaped newline or not,\n        // if our starting position is not on the same line as the instruction then\n        // the start of the content is already on an escaped line\n        let escaped = range.start.line !== startPosition.line;\n        // flag to track if the last character was an escape character\n        let endingEscape = false;\n        // position before the first escape character was hit\n        let mark = -1;\n        let end = this.findTrailingNonWhitespace(fullArgs);\n        content = fullArgs.substring(start, end + 1);\n        let argStart = escaped ? -1 : 0;\n        let spaced = false;\n        argumentLoop: for(let i = 0; i < content.length; i++){\n            let char = content.charAt(i);\n            switch(char){\n                case this.escapeChar:\n                    if (i + 1 === content.length) {\n                        endingEscape = true;\n                        break argumentLoop;\n                    }\n                    if (!escaped) mark = i;\n                    switch(content.charAt(i + 1)){\n                        case ' ':\n                        case '\\t':\n                            if (!util_1.Util.isWhitespace(content.charAt(i + 2))) {\n                                // space was escaped, continue as normal\n                                i = i + 1;\n                                continue argumentLoop;\n                            }\n                            // whitespace encountered, need to figure out if it extends to EOL\n                            whitespaceCheck: for(let j = i + 2; j < content.length; j++)switch(content.charAt(j)){\n                                case '\\r':\n                                    // offset one more for \\r\\n\n                                    j++;\n                                case '\\n':\n                                    // whitespace only, safe to skip\n                                    escaped = true;\n                                    i = j;\n                                    continue argumentLoop;\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    // whitespace doesn't extend to EOL, create an argument\n                                    args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i + 2))));\n                                    argStart = j;\n                                    break whitespaceCheck;\n                            }\n                            // go back and start processing the encountered non-whitespace character\n                            i = argStart - 1;\n                            continue argumentLoop;\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            i++;\n                        case '\\n':\n                            // immediately followed by a newline, skip the newline\n                            escaped = true;\n                            i = i + 1;\n                            continue argumentLoop;\n                        case this.escapeChar:\n                            // double escape found, skip it and move on\n                            if (argStart === -1) argStart = i;\n                            i = i + 1;\n                            continue argumentLoop;\n                        default:\n                            if (argStart === -1) argStart = i;\n                            continue argumentLoop;\n                    }\n                case '\\'':\n                case '\"':\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    if (argStart === -1) argStart = i;\n                    for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case char:\n                            if (content.charAt(j + 1) !== ' ' && content.charAt(j + 1) !== '') {\n                                // there is more content after this quote,\n                                // continue so that it is all processed as\n                                // one single argument\n                                i = j;\n                                continue argumentLoop;\n                            }\n                            args.push(new argument_1.Argument(content.substring(argStart, j + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + j + 1))));\n                            i = j;\n                            argStart = -1;\n                            continue argumentLoop;\n                        case this.escapeChar:\n                            j++;\n                            break;\n                    }\n                    break argumentLoop;\n                case ' ':\n                case '\\t':\n                    if (escaped) // consider there to be a space only if an argument\n                    // is not spanning multiple lines\n                    {\n                        if (argStart !== -1) spaced = true;\n                    } else if (argStart !== -1) {\n                        args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i))));\n                        argStart = -1;\n                    }\n                    break;\n                case '\\r':\n                    // offset one more for \\r\\n\n                    i++;\n                case '\\n':\n                    spaced = false;\n                    break;\n                case '#':\n                    if (escaped) {\n                        // a newline was escaped and now there's a comment\n                        for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                i = j;\n                                spaced = false;\n                                continue argumentLoop;\n                        }\n                        // went to the end without finding a newline,\n                        // the comment was the last line in the instruction,\n                        // just stop parsing, create an argument if needed\n                        if (argStart !== -1) {\n                            let value = content.substring(argStart, mark);\n                            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n                            argStart = -1;\n                        }\n                        break argumentLoop;\n                    } else if (argStart === -1) argStart = i;\n                    break;\n                default:\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    escaped = false;\n                    if (argStart === -1) argStart = i;\n                    // variable detected\n                    if (char === '$' && content.charAt(i + 1) === '{') {\n                        let singleQuotes = false;\n                        let doubleQuotes = false;\n                        let escaped = false;\n                        for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                            case this.escapeChar:\n                                escaped = true;\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                break;\n                            case '\\'':\n                                singleQuotes = !singleQuotes;\n                                escaped = false;\n                                break;\n                            case '\"':\n                                doubleQuotes = !doubleQuotes;\n                                escaped = false;\n                                break;\n                            case ' ':\n                            case '\\t':\n                                if (escaped || singleQuotes || doubleQuotes) break;\n                                i = j - 1;\n                                continue argumentLoop;\n                            case '}':\n                                i = j;\n                                continue argumentLoop;\n                            default:\n                                escaped = false;\n                                break;\n                        }\n                        break argumentLoop;\n                    }\n                    break;\n            }\n        }\n        if (argStart !== -1 && argStart !== content.length) {\n            let end = endingEscape ? content.length - 1 : content.length;\n            let value = content.substring(argStart, end);\n            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + end))));\n        }\n        return args;\n    }\n    createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start) {\n        if (argStart !== -1) args.push(new argument_1.Argument(content.substring(argStart, mark), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n    }\n}\nexports.PropertyInstruction = PropertyInstruction;\n\n},{\"fb005c0263efbd46\":\"ghSGy\",\"ae3a92d2c36b7ea3\":\"hMvuU\",\"39497e57ce0ffacf\":\"gy5Z3\",\"2f89de63f1f8e904\":\"j0TZA\",\"ca53fbc43fccdebf\":\"7JXpr\"}],\"9Gc1y\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Cmd = void 0;\nconst jsonInstruction_1 = require(\"fadbfdfa374dda06\");\nclass Cmd extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Cmd = Cmd;\n\n},{\"fadbfdfa374dda06\":\"jxSFH\"}],\"b3t88\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Copy = void 0;\nconst jsonInstruction_1 = require(\"65144230b131ca44\");\nclass Copy extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getFromFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"from\" ? flags[0] : null;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */ getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Copy = Copy;\n\n},{\"65144230b131ca44\":\"jxSFH\"}],\"1F4QE\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Env = void 0;\nconst propertyInstruction_1 = require(\"3dd682269c8a52ed\");\nclass Env extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Env = Env;\n\n},{\"3dd682269c8a52ed\":\"hOqfp\"}],\"a7xJN\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Entrypoint = void 0;\nconst jsonInstruction_1 = require(\"f651b847cf9bdc2\");\nclass Entrypoint extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Entrypoint = Entrypoint;\n\n},{\"f651b847cf9bdc2\":\"jxSFH\"}],\"nTyT0\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.From = void 0;\nconst vscode_languageserver_types_1 = require(\"5b86d61a77060318\");\nconst modifiableInstruction_1 = require(\"3fab8faba231e372\");\nclass From extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getImage() {\n        return this.getRangeContent(this.getImageRange());\n    }\n    /**\n     * Returns the name of the image that will be used as the base image.\n     *\n     * @return the base image's name, or null if unspecified\n     */ getImageName() {\n        return this.getRangeContent(this.getImageNameRange());\n    }\n    /**\n     * Returns the range that covers the name of the image used by\n     * this instruction.\n     *\n     * @return the range of the name of this instruction's argument,\n     *         or null if no image has been specified\n     */ getImageNameRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let registryRange = this.getRegistryRange();\n            if (registryRange) range.start = this.document.positionAt(this.document.offsetAt(registryRange.end) + 1);\n            let tagRange = this.getImageTagRange();\n            let digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n            } else range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            return range;\n        }\n        return null;\n    }\n    /**\n     * Returns the range that covers the image argument of this\n     * instruction. This includes the tag or digest of the image if\n     * it has been specified by the instruction.\n     *\n     * @return the range of the image argument, or null if no image\n     *         has been specified\n     */ getImageRange() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0].getRange() : null;\n    }\n    getImageTag() {\n        return this.getRangeContent(this.getImageTagRange());\n    }\n    /**\n     * Returns the range in the document that the tag of the base\n     * image encompasses.\n     *\n     * @return the base image's tag's range in the document, or null\n     *         if no tag has been specified\n     */ getImageTagRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const rangeStartOffset = this.document.offsetAt(range.start);\n            const content = this.getRangeContent(range);\n            const atIndex = this.indexOf(rangeStartOffset, content, '@');\n            const slashIndex = content.indexOf('/');\n            if (atIndex === -1) {\n                const colonIndex = this.lastIndexOf(rangeStartOffset, content, ':');\n                if (colonIndex > slashIndex) return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + colonIndex + 1, range.end.line, range.end.character);\n            }\n            const subcontent = content.substring(0, atIndex);\n            const subcolonIndex = subcontent.indexOf(':');\n            if (subcolonIndex === -1) return null;\n            if (slashIndex === -1) // slash not found suggests no registry and no namespace defined\n            return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + atIndex));\n            // both colon and slash found, check if it is a port\n            if (subcolonIndex < slashIndex) return null;\n            return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + subcontent.length));\n        }\n        return null;\n    }\n    getImageDigest() {\n        return this.getRangeContent(this.getImageDigestRange());\n    }\n    /**\n     * Returns the range in the document that the digest of the base\n     * image encompasses.\n     *\n     * @return the base image's digest's range in the document, or null\n     *         if no digest has been specified\n     */ getImageDigestRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let content = this.getRangeContent(range);\n            let index = this.lastIndexOf(this.document.offsetAt(range.start), content, '@');\n            if (index !== -1) return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + index + 1, range.end.line, range.end.character);\n        }\n        return null;\n    }\n    indexOf(documentOffset, content, searchString) {\n        let index = content.indexOf(searchString);\n        const variables = this.getVariables();\n        for(let i = 0; i < variables.length; i++){\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                const offset = this.document.offsetAt(variableRange.end) - documentOffset;\n                const substring = content.substring(offset);\n                const subIndex = substring.indexOf(searchString);\n                if (subIndex === -1) return -1;\n                index = subIndex + offset;\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    lastIndexOf(documentOffset, content, searchString) {\n        let index = content.lastIndexOf(searchString);\n        const variables = this.getVariables();\n        for(let i = 0; i < variables.length; i++){\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                index = content.substring(0, index).lastIndexOf(searchString);\n                if (index === -1) return -1;\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    getRegistry() {\n        return this.getRangeContent(this.getRegistryRange());\n    }\n    getRegistryRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const tagRange = this.getImageTagRange();\n            const digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n            } else range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            const content = this.getRangeContent(range);\n            const rangeStart = this.document.offsetAt(range.start);\n            const startingSlashIndex = this.indexOf(rangeStart, content, '/');\n            if (startingSlashIndex === -1) return null;\n            const portIndex = this.indexOf(rangeStart, content, ':');\n            const dotIndex = this.indexOf(rangeStart, content, '.');\n            // hostname detected\n            if (portIndex !== -1 || dotIndex !== -1) return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n            const registry = content.substring(0, startingSlashIndex);\n            // localhost registry detected\n            if (registry === 'localhost') return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n        }\n        return null;\n    }\n    getBuildStage() {\n        let range = this.getBuildStageRange();\n        return range === null ? null : this.getRangeContent(range);\n    }\n    getBuildStageRange() {\n        let args = this.getArguments();\n        if (args.length > 2 && args[1].getValue().toUpperCase() === \"AS\") return args[2].getRange();\n        return null;\n    }\n    getPlatformFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"platform\" ? flags[0] : null;\n    }\n}\nexports.From = From;\n\n},{\"5b86d61a77060318\":\"ghSGy\",\"3fab8faba231e372\":\"hJrte\"}],\"bkMBh\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Healthcheck = void 0;\nconst modifiableInstruction_1 = require(\"665598fff2f000a9\");\nclass Healthcheck extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        argument = argument.toUpperCase();\n        return argument === \"CMD\" || argument === \"NONE\";\n    }\n    getSubcommand() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0] : null;\n    }\n}\nexports.Healthcheck = Healthcheck;\n\n},{\"665598fff2f000a9\":\"hJrte\"}],\"57hgN\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Label = void 0;\nconst propertyInstruction_1 = require(\"2a3c43ab2d532e31\");\nconst util_1 = require(\"5d28f2c31403599f\");\nclass Label extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getVariables() {\n        const variables = super.getVariables();\n        const properties = this.getProperties();\n        // iterate over all of this LABEL's properties\n        for (const property of properties){\n            const value = property.getUnescapedValue();\n            // check if the value is contained in single quotes,\n            // single quotes would indicate a literal value\n            if (value !== null && value.length > 2 && value.charAt(0) === '\\'' && value.charAt(value.length - 1) === '\\'') {\n                const range = property.getValueRange();\n                for(let i = 0; i < variables.length; i++)// if a variable is in a single quote, remove it from the list\n                if (util_1.Util.isInsideRange(variables[i].getRange().start, range)) {\n                    variables.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        return variables;\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Label = Label;\n\n},{\"2a3c43ab2d532e31\":\"hOqfp\",\"5d28f2c31403599f\":\"7JXpr\"}],\"8eYDK\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Onbuild = void 0;\nconst vscode_languageserver_types_1 = require(\"8cc927a606bbcc1f\");\nconst parser_1 = require(\"929a3cd6b7bd5151\");\nconst instruction_1 = require(\"5311b0a026532a3\");\nclass Onbuild extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getTrigger() {\n        let trigger = this.getTriggerWord();\n        return trigger === null ? null : trigger.toUpperCase();\n    }\n    getTriggerWord() {\n        return this.getRangeContent(this.getTriggerRange());\n    }\n    getTriggerRange() {\n        let args = this.getArguments();\n        return args.length > 0 ? args[0].getRange() : null;\n    }\n    getTriggerInstruction() {\n        let triggerRange = this.getTriggerRange();\n        if (triggerRange === null) return null;\n        let args = this.getArguments();\n        return parser_1.Parser.createInstruction(this.document, this.dockerfile, this.escapeChar, vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end), this.getTriggerWord(), triggerRange);\n    }\n}\nexports.Onbuild = Onbuild;\n\n},{\"8cc927a606bbcc1f\":\"ghSGy\",\"929a3cd6b7bd5151\":\"aGQ73\",\"5311b0a026532a3\":\"hMvuU\"}],\"bBCsY\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Run = void 0;\nconst jsonInstruction_1 = require(\"d3870bc430335c64\");\nclass Run extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */ getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Run = Run;\n\n},{\"d3870bc430335c64\":\"jxSFH\"}],\"j6kkx\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Shell = void 0;\nconst jsonInstruction_1 = require(\"dc6aa9db0db2b2a4\");\nclass Shell extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Shell = Shell;\n\n},{\"dc6aa9db0db2b2a4\":\"jxSFH\"}],\"bxm6V\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Stopsignal = void 0;\nconst instruction_1 = require(\"e3fce526f69f22f\");\nclass Stopsignal extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Stopsignal = Stopsignal;\n\n},{\"e3fce526f69f22f\":\"hMvuU\"}],\"alCEF\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Workdir = void 0;\nconst instruction_1 = require(\"95b77616cbe9ddd8\");\nclass Workdir extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    /**\n     * Returns the path that has been defined. Note that this path may\n     * be absolute or relative depending on what was written in the\n     * instruction.\n     *\n     * @return the working directory's path, or null if this\n     *         instruction has no arguments\n     */ getPath() {\n        return this.getArgumentsContent();\n    }\n    /**\n     * Returns the absolute path that this instruction resolves to. The\n     * function will inspect prior WORKDIR instructions in the current\n     * image or another build stage in the Dockerfile to try to\n     * determine this.\n     *\n     * @return the absolute path of the working directory, or null if\n     *         this instruction has no arguments, or undefined if it\n     *         cannot be determined because only relative paths could be\n     *         found\n     */ getAbsolutePath() {\n        const path = this.getPath();\n        if (path === null || path.startsWith(\"/\")) return path;\n        const startLine = this.getRange().start.line;\n        const hierarchy = this.dockerfile.getStageHierarchy(startLine);\n        for(let i = hierarchy.length - 1; i >= 0; i--){\n            const workdirs = hierarchy[i].getWORKDIRs();\n            for(let j = workdirs.length - 1; j >= 0; j--)if (workdirs[j].getRange().start.line < startLine) {\n                const parent = workdirs[j].getAbsolutePath();\n                if (parent === undefined || parent === null) return undefined;\n                return parent.endsWith(\"/\") ? parent + path : parent + \"/\" + path;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Workdir = Workdir;\n\n},{\"95b77616cbe9ddd8\":\"hMvuU\"}],\"bSHO0\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.User = void 0;\nconst instruction_1 = require(\"1c67107403f9045a\");\nclass User extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.User = User;\n\n},{\"1c67107403f9045a\":\"hMvuU\"}],\"5fZdP\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Volume = void 0;\nconst jsonInstruction_1 = require(\"2200bfdb26148310\");\nclass Volume extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Volume = Volume;\n\n},{\"2200bfdb26148310\":\"jxSFH\"}],\"040Bk\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Dockerfile = void 0;\nconst vscode_languageserver_types_1 = require(\"9b3d375bed950159\");\nconst ast = require(\"d891ee5557672a0b\");\nconst imageTemplate_1 = require(\"372addc62e869cb6\");\nconst from_1 = require(\"3861ba9aa1dc6c84\");\nconst util_1 = require(\"e6e9b77f8d4a922b\");\nconst main_1 = require(\"d891ee5557672a0b\");\nclass Dockerfile extends imageTemplate_1.ImageTemplate {\n    constructor(document){\n        super();\n        this.initialInstructions = new imageTemplate_1.ImageTemplate();\n        this.buildStages = [];\n        this.directives = [];\n        /**\n         * Whether a FROM instruction has been added to this Dockerfile or not.\n         */ this.foundFrom = false;\n        this.document = document;\n    }\n    getEscapeCharacter() {\n        for (const directive of this.directives)if (directive.getDirective() === ast.Directive.escape) {\n            const value = directive.getValue();\n            if (value === '\\\\' || value === '`') return value;\n        }\n        return '\\\\';\n    }\n    getInitialARGs() {\n        return this.initialInstructions.getARGs();\n    }\n    getContainingImage(position) {\n        let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), this.document.positionAt(this.document.getText().length));\n        if (!util_1.Util.isInsideRange(position, range)) // not inside the document, invalid position\n        return null;\n        if (this.initialInstructions.getComments().length > 0 || this.initialInstructions.getInstructions().length > 0) {\n            if (util_1.Util.isInsideRange(position, this.initialInstructions.getRange())) return this.initialInstructions;\n        }\n        for (const buildStage of this.buildStages){\n            if (util_1.Util.isInsideRange(position, buildStage.getRange())) return buildStage;\n        }\n        return this;\n    }\n    addInstruction(instruction) {\n        if (instruction.getKeyword() === main_1.Keyword.FROM) {\n            this.currentBuildStage = new imageTemplate_1.ImageTemplate();\n            this.buildStages.push(this.currentBuildStage);\n            this.foundFrom = true;\n        } else if (!this.foundFrom) this.initialInstructions.addInstruction(instruction);\n        if (this.foundFrom) this.currentBuildStage.addInstruction(instruction);\n        super.addInstruction(instruction);\n    }\n    setDirectives(directives) {\n        this.directives = directives;\n    }\n    getDirective() {\n        return this.directives.length === 0 ? null : this.directives[0];\n    }\n    getDirectives() {\n        return this.directives;\n    }\n    resolveVariable(variable, line) {\n        for (let from of this.getFROMs()){\n            let range = from.getRange();\n            if (range.start.line <= line && line <= range.end.line) {\n                // resolve the FROM variable against the initial ARGs\n                let initialARGs = new imageTemplate_1.ImageTemplate();\n                for (let instruction of this.initialInstructions.getARGs())initialARGs.addInstruction(instruction);\n                return initialARGs.resolveVariable(variable, line);\n            }\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) return undefined;\n        let resolvedVariable = image.resolveVariable(variable, line);\n        if (resolvedVariable === null) {\n            // refers to an uninitialized ARG variable,\n            // try resolving it against the initial ARGs then\n            let initialARGs = new imageTemplate_1.ImageTemplate();\n            for (let instruction of this.initialInstructions.getARGs())initialARGs.addInstruction(instruction);\n            return initialARGs.resolveVariable(variable, line);\n        }\n        return resolvedVariable;\n    }\n    getAvailableVariables(currentLine) {\n        if (this.getInstructionAt(currentLine) instanceof from_1.From) {\n            let variables = [];\n            for (let arg of this.getInitialARGs()){\n                let property = arg.getProperty();\n                if (property) variables.push(property.getName());\n            }\n            return variables;\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(currentLine, 0));\n        return image ? image.getAvailableVariables(currentLine) : [];\n    }\n    getParentStage(image) {\n        const templateFrom = image.getFROM();\n        const imageName = templateFrom === null ? null : templateFrom.getImageName();\n        if (imageName === null) return null;\n        for (const from of this.getFROMs())if (from.getBuildStage() === imageName) {\n            const range = from.getRange();\n            // on the same line then it's an image that shares the name as the build stage\n            if (range.start.line === templateFrom.getRange().start.line) return null;\n            return this.getContainingImage(range.start);\n        }\n        return null;\n    }\n    getStageHierarchy(line) {\n        const image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) return [];\n        const stages = [\n            image\n        ];\n        let stage = this.getParentStage(image);\n        while(stage !== null){\n            stages.splice(0, 0, stage);\n            stage = this.getParentStage(stage);\n        }\n        return stages;\n    }\n    getAvailableWorkingDirectories(line) {\n        const availableDirectories = new Set();\n        for (const image of this.getStageHierarchy(line)){\n            for (const workdir of image.getWORKDIRs())if (workdir.getRange().end.line < line) {\n                let directory = workdir.getAbsolutePath();\n                if (directory !== undefined && directory !== null) {\n                    if (!directory.endsWith(\"/\")) directory += \"/\";\n                    availableDirectories.add(directory);\n                }\n            }\n        }\n        return Array.from(availableDirectories);\n    }\n    /**\n     * Internally reorganize the comments in the Dockerfile and allocate\n     * them to the relevant build stages that they belong to.\n     */ organizeComments() {\n        const comments = this.getComments();\n        for(let i = 0; i < comments.length; i++)if (util_1.Util.isInsideRange(comments[i].getRange().end, this.initialInstructions.getRange())) this.initialInstructions.addComment(comments[i]);\n        else {\n            for (const buildStage of this.buildStages)if (util_1.Util.isInsideRange(comments[i].getRange().start, buildStage.getRange())) buildStage.addComment(comments[i]);\n        }\n    }\n    getRange() {\n        const comments = this.getComments();\n        const instructions = this.getInstructions();\n        let range = null;\n        if (comments.length === 0) {\n            if (instructions.length > 0) range = vscode_languageserver_types_1.Range.create(instructions[0].getRange().start, instructions[instructions.length - 1].getRange().end);\n        } else if (instructions.length === 0) range = vscode_languageserver_types_1.Range.create(comments[0].getRange().start, comments[comments.length - 1].getRange().end);\n        else {\n            const commentStart = comments[0].getRange().start;\n            const commentEnd = comments[comments.length - 1].getRange().end;\n            const instructionStart = instructions[0].getRange().start;\n            const instructionEnd = instructions[instructions.length - 1].getRange().end;\n            if (commentStart.line < instructionStart.line) {\n                if (commentEnd.line < instructionEnd.line) range = vscode_languageserver_types_1.Range.create(commentStart, instructionEnd);\n                range = vscode_languageserver_types_1.Range.create(commentStart, commentEnd);\n            } else if (commentEnd.line < instructionEnd.line) range = vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n            else range = vscode_languageserver_types_1.Range.create(instructionStart, commentEnd);\n        }\n        if (range === null) {\n            if (this.directives.length === 0) return null;\n            return this.directives[0].getRange();\n        } else if (this.directives.length === 0) return range;\n        return vscode_languageserver_types_1.Range.create(this.directives[0].getRange().start, range.end);\n    }\n}\nexports.Dockerfile = Dockerfile;\n\n},{\"9b3d375bed950159\":\"ghSGy\",\"d891ee5557672a0b\":\"1irbL\",\"372addc62e869cb6\":\"dfryE\",\"3861ba9aa1dc6c84\":\"nTyT0\",\"e6e9b77f8d4a922b\":\"7JXpr\"}],\"dfryE\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ImageTemplate = void 0;\nconst vscode_languageserver_types_1 = require(\"637eaa8a1fc84367\");\nconst arg_1 = require(\"8d6e1611976d457\");\nconst cmd_1 = require(\"7049fdb6ce6cfe77\");\nconst copy_1 = require(\"18fb214fae92c2ad\");\nconst env_1 = require(\"ed7edb89b8b53c18\");\nconst entrypoint_1 = require(\"404b55dc97f3131e\");\nconst from_1 = require(\"8a1e47b88288dfaa\");\nconst healthcheck_1 = require(\"67d1d9c7cde52290\");\nconst onbuild_1 = require(\"434b828c9fd563cf\");\nconst util_1 = require(\"94e3edfa252cd826\");\nconst workdir_1 = require(\"97943bcfae78dd09\");\nclass ImageTemplate {\n    constructor(){\n        this.comments = [];\n        this.instructions = [];\n    }\n    addComment(comment) {\n        this.comments.push(comment);\n    }\n    getComments() {\n        return this.comments;\n    }\n    addInstruction(instruction) {\n        this.instructions.push(instruction);\n    }\n    getInstructions() {\n        return this.instructions;\n    }\n    getInstructionAt(line) {\n        for (let instruction of this.instructions){\n            if (util_1.Util.isInsideRange(vscode_languageserver_types_1.Position.create(line, 0), instruction.getRange())) return instruction;\n        }\n        return null;\n    }\n    /**\n     * Gets all the ARG instructions that are defined in this image.\n     */ getARGs() {\n        let args = [];\n        for (let instruction of this.instructions)if (instruction instanceof arg_1.Arg) args.push(instruction);\n        return args;\n    }\n    /**\n     * Gets all the CMD instructions that are defined in this image.\n     */ getCMDs() {\n        let cmds = [];\n        for (let instruction of this.instructions)if (instruction instanceof cmd_1.Cmd) cmds.push(instruction);\n        return cmds;\n    }\n    /**\n     * Gets all the COPY instructions that are defined in this image.\n     */ getCOPYs() {\n        let copies = [];\n        for (let instruction of this.instructions)if (instruction instanceof copy_1.Copy) copies.push(instruction);\n        return copies;\n    }\n    /**\n     * Gets all the ENTRYPOINT instructions that are defined in this image.\n     */ getENTRYPOINTs() {\n        let froms = [];\n        for (let instruction of this.instructions)if (instruction instanceof entrypoint_1.Entrypoint) froms.push(instruction);\n        return froms;\n    }\n    /**\n     * Gets all the ENV instructions that are defined in this image.\n     */ getENVs() {\n        let args = [];\n        for (let instruction of this.instructions)if (instruction instanceof env_1.Env) args.push(instruction);\n        return args;\n    }\n    getFROM() {\n        for (const instruction of this.instructions){\n            if (instruction instanceof from_1.From) return instruction;\n        }\n        return null;\n    }\n    /**\n     * Gets all the FROM instructions that are defined in this image.\n     */ getFROMs() {\n        let froms = [];\n        for (let instruction of this.instructions)if (instruction instanceof from_1.From) froms.push(instruction);\n        return froms;\n    }\n    /**\n     * Gets all the HEALTHCHECK instructions that are defined in this image.\n     */ getHEALTHCHECKs() {\n        let froms = [];\n        for (let instruction of this.instructions)if (instruction instanceof healthcheck_1.Healthcheck) froms.push(instruction);\n        return froms;\n    }\n    getWORKDIRs() {\n        const workdirs = [];\n        for (const instruction of this.instructions)if (instruction instanceof workdir_1.Workdir) workdirs.push(instruction);\n        return workdirs;\n    }\n    getOnbuildTriggers() {\n        let triggers = [];\n        for (let instruction of this.instructions)if (instruction instanceof onbuild_1.Onbuild) {\n            let trigger = instruction.getTriggerInstruction();\n            if (trigger) triggers.push(trigger);\n        }\n        return triggers;\n    }\n    getAvailableVariables(currentLine) {\n        const variables = [];\n        for (const arg of this.getARGs())if (arg.isBefore(currentLine)) {\n            const property = arg.getProperty();\n            if (property) {\n                const variable = property.getName();\n                if (variables.indexOf(variable) === -1) variables.push(variable);\n            }\n        }\n        for (const env of this.getENVs()){\n            if (env.isBefore(currentLine)) for (const property of env.getProperties()){\n                const variable = property.getName();\n                if (variables.indexOf(variable) === -1) variables.push(variable);\n            }\n        }\n        return variables;\n    }\n    /**\n     * Resolves a variable with the given name at the specified line\n     * to its value. If null is returned, then the variable has been\n     * defined but no value was given. If undefined is returned, then\n     * a variable with the given name has not been defined yet as of\n     * the given line.\n     *\n     * @param variable the name of the variable to resolve\n     * @param line the line number that the variable is on, zero-based\n     * @return the value of the variable as defined by an ARG or ENV\n     *         instruction, or null if no value has been specified, or\n     *         undefined if a variable with the given name has not\n     *         been defined\n     */ resolveVariable(variable, line) {\n        let envs = this.getENVs();\n        for(let i = envs.length - 1; i >= 0; i--){\n            if (envs[i].isBefore(line)) for (let property of envs[i].getProperties()){\n                if (property.getName() === variable) return property.getValue();\n            }\n        }\n        let args = this.getARGs();\n        for(let i = args.length - 1; i >= 0; i--)if (args[i].isBefore(line)) {\n            let property = args[i].getProperty();\n            if (property && property.getName() === variable) return property.getValue();\n        }\n        return undefined;\n    }\n    getRange() {\n        const instructions = this.getInstructions();\n        if (instructions.length === 0) // all templates should have instructions, this only happens for\n        // the initial set of instruction\n        return vscode_languageserver_types_1.Range.create(0, 0, 0, 0);\n        const instructionStart = instructions[0].getRange().start;\n        const instructionEnd = instructions[instructions.length - 1].getRange().end;\n        return vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n    }\n    contains(position) {\n        const range = this.getRange();\n        if (range === null) return false;\n        return util_1.Util.isInsideRange(position, range);\n    }\n}\nexports.ImageTemplate = ImageTemplate;\n\n},{\"637eaa8a1fc84367\":\"ghSGy\",\"8d6e1611976d457\":\"aKTxx\",\"7049fdb6ce6cfe77\":\"9Gc1y\",\"18fb214fae92c2ad\":\"b3t88\",\"ed7edb89b8b53c18\":\"1F4QE\",\"404b55dc97f3131e\":\"a7xJN\",\"8a1e47b88288dfaa\":\"nTyT0\",\"67d1d9c7cde52290\":\"bkMBh\",\"434b828c9fd563cf\":\"8eYDK\",\"94e3edfa252cd826\":\"7JXpr\",\"97943bcfae78dd09\":\"alCEF\"}],\"lnguQ\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"configureLogger\", ()=>configureLogger);\nparcelHelpers.export(exports, \"logInfo\", ()=>logInfo);\nparcelHelpers.export(exports, \"logNotice\", ()=>logNotice);\nparcelHelpers.export(exports, \"logWarning\", ()=>logWarning);\nparcelHelpers.export(exports, \"logError\", ()=>logError);\nparcelHelpers.export(exports, \"logDebug\", ()=>logDebug);\nparcelHelpers.export(exports, \"logVerbose\", ()=>logVerbose);\nparcelHelpers.export(exports, \"logGroup\", ()=>logGroup);\nparcelHelpers.export(exports, \"isVerboseEnabled\", ()=>isVerboseEnabled);\nvar _coreJs = require(\"@actions/core/lib/core.js\");\nvar _asyncHooks = require(\"async_hooks\");\nlet verboseEnabled = false;\n// Async context for group prefixes\nconst groupContext = new (0, _asyncHooks.AsyncLocalStorage)();\nfunction callCore(fn, fallback) {\n    try {\n        fn();\n    } catch (error) {\n        fallback();\n    }\n}\nconst isActionsRuntime = process.env.GITHUB_ACTIONS === \"true\";\nfunction formatMessageForConsole(message) {\n    const groupName = groupContext.getStore();\n    return groupName ? `[${groupName}] ${message}` : message;\n}\nfunction configureLogger(options) {\n    verboseEnabled = options.verbose;\n    if (verboseEnabled) logVerbose(\"Verbose logging enabled\");\n    else logDebug(\"Verbose logging disabled\");\n}\nfunction logInfo(message) {\n    callCore(()=>(0, _coreJs.info)(message), ()=>console.log(formatMessageForConsole(message)));\n}\nfunction logNotice(message) {\n    callCore(()=>(0, _coreJs.notice)(message), ()=>console.log(formatMessageForConsole(message)));\n}\nfunction logWarning(message) {\n    callCore(()=>(0, _coreJs.warning)(message), ()=>console.warn(formatMessageForConsole(message)));\n}\nfunction logError(message) {\n    const text = message instanceof Error ? message.message : message;\n    callCore(()=>(0, _coreJs.error)(text), ()=>console.error(formatMessageForConsole(text)));\n}\nfunction logDebug(message) {\n    callCore(()=>(0, _coreJs.debug)(message), ()=>console.debug(formatMessageForConsole(message)));\n}\nfunction logVerbose(message) {\n    if (!verboseEnabled) return;\n    const verboseMessage = `[verbose] ${message}`;\n    if (isActionsRuntime) {\n        callCore(()=>(0, _coreJs.debug)(verboseMessage), ()=>console.debug(formatMessageForConsole(verboseMessage)));\n        if (!(0, _coreJs.isDebug)()) callCore(()=>(0, _coreJs.info)(verboseMessage), ()=>console.log(formatMessageForConsole(verboseMessage)));\n    } else console.debug(formatMessageForConsole(verboseMessage));\n}\nasync function createNativeGroup(name, fn) {\n    return groupContext.run(name, fn);\n}\nasync function logGroup(name, fn) {\n    if (isActionsRuntime) try {\n        // In Actions environment, use core.group without context (Actions handles grouping)\n        return await (0, _coreJs.group)(name, fn);\n    } catch (error) {\n        // Fallback to manual wrapper if core.group fails\n        return await createNativeGroup(name, fn);\n    }\n    else // Non-Actions environment - use native wrapper with context\n    return await createNativeGroup(name, fn);\n}\nfunction isVerboseEnabled() {\n    return verboseEnabled;\n}\n\n},{\"@actions/core/lib/core.js\":\"k7YnK\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\",\"async_hooks\":\"async_hooks\"}],\"kHqLa\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"run\", ()=>run);\nparcelHelpers.export(exports, \"runPiped\", ()=>runPiped);\nparcelHelpers.export(exports, \"runWithInput\", ()=>runWithInput);\nvar _spawnPlease = require(\"spawn-please\");\nvar _spawnPleaseDefault = parcelHelpers.interopDefault(_spawnPlease);\nvar _childProcess = require(\"child_process\");\nvar _childProcessDefault = parcelHelpers.interopDefault(_childProcess);\nvar _loggerJs = require(\"./logger.js\");\nasync function run(command, args) {\n    const commandString = formatCommand(command, args);\n    (0, _loggerJs.logVerbose)(`Executing command: ${commandString}`);\n    try {\n        const result = await (0, _spawnPleaseDefault.default)(command, args);\n        (0, _loggerJs.logVerbose)(`Command succeeded: ${commandString}`);\n        return result;\n    } catch (error) {\n        (0, _loggerJs.logError)(`Error running command: ${commandString}`);\n        if (error instanceof Error && error.stack) (0, _loggerJs.logVerbose)(error.stack);\n        throw error;\n    }\n}\nasync function runPiped([command1, args1], [command2, args2]) {\n    const commandString = `${formatCommand(command1, args1)} | ${formatCommand(command2, args2)}`;\n    (0, _loggerJs.logVerbose)(`Executing piped command: ${commandString}`);\n    const cp1 = (0, _childProcessDefault.default).spawn(command1, args1, {\n        stdio: [\n            'inherit',\n            'pipe',\n            'inherit'\n        ]\n    });\n    const cp2 = (0, _childProcessDefault.default).spawn(command2, args2, {\n        stdio: [\n            'pipe',\n            'inherit',\n            'inherit'\n        ]\n    });\n    cp1.stdout.pipe(cp2.stdin);\n    await Promise.all([\n        assertSuccess(cp1, formatCommand(command1, args1)),\n        assertSuccess(cp2, formatCommand(command2, args2))\n    ]);\n    (0, _loggerJs.logVerbose)(`Piped command succeeded: ${commandString}`);\n}\nasync function runWithInput(command, args, input) {\n    const commandString = formatCommand(command, args);\n    (0, _loggerJs.logVerbose)(`Executing command with stdin: ${commandString}`);\n    const child = (0, _childProcessDefault.default).spawn(command, args, {\n        stdio: [\n            'pipe',\n            'inherit',\n            'inherit'\n        ]\n    });\n    child.stdin.on('error', (error)=>{\n        (0, _loggerJs.logError)(`Failed to write to stdin for ${commandString}: ${error}`);\n    });\n    child.stdin.write(input);\n    child.stdin.end();\n    try {\n        await assertSuccess(child, commandString);\n        (0, _loggerJs.logVerbose)(`Command with stdin succeeded: ${commandString}`);\n    } catch (error) {\n        if (error instanceof Error && error.stack) (0, _loggerJs.logVerbose)(error.stack);\n        throw error;\n    }\n}\nfunction assertSuccess(cp, command) {\n    return new Promise((resolve, reject)=>{\n        cp.on('error', (error)=>{\n            (0, _loggerJs.logError)(`Process error: ${command}`);\n            if (error instanceof Error && error.stack) (0, _loggerJs.logVerbose)(error.stack);\n            reject(error);\n        });\n        cp.on('close', (code)=>{\n            if (code !== 0) {\n                const error = new Error(`process exited with code ${code}`);\n                (0, _loggerJs.logError)(`${command} failed: ${error.message}`);\n                reject(error);\n            }\n            (0, _loggerJs.logVerbose)(`Process exited successfully: ${command}`);\n            resolve();\n        });\n    });\n}\nfunction formatCommand(command, args) {\n    return [\n        command,\n        ...args\n    ].join(' ').trim();\n}\n\n},{\"spawn-please\":\"7zP4I\",\"child_process\":\"child_process\",\"./logger.js\":\"lnguQ\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"7zP4I\":[function(require,module,exports,__globalThis) {\nconst spawn = require(\"8fbf49fd88b8ce1a\");\n/** Spawns a child process, as long as you ask nicely.\n * \n * @param {string} command - The shell command to execute.\n * @param {string[]} [args] - An array of arguments that are given after the command.\n * @param {{ rejectOnError?: boolean, stdin?: string, stderr?: (data: string) => void, stdout?: (data: string) => void }} [options] - Options.\n * @param {any} [spawnOptions] - Options that are passed directly to child_process.spawn. Also supports stdin: string.\n * @returns {Promise<{ stdout: string, stderr: string }>}\n */ const spawnPlease = (command, args, options = {}, spawnOptions = {})=>{\n    // defaults\n    if (options.rejectOnError === undefined) options.rejectOnError = true;\n    let stdout = '';\n    let stderr = '';\n    const child = spawn(command, args, spawnOptions);\n    return new Promise((resolve, reject)=>{\n        if (options.stdin !== undefined && options.stdin != null) child.stdin.write(options.stdin);\n        child.stdin.end();\n        child.stdout.on('data', (data)=>{\n            stdout += data;\n            if (options.stdout) options.stdout(data);\n        });\n        child.stderr.on('data', (data)=>{\n            stderr += data;\n            if (options.stderr) options.stderr(data);\n        });\n        if (options.rejectOnError) child.addListener('error', reject);\n        child.on('close', (code)=>{\n            if (code !== 0 && options.rejectOnError) reject(stderr);\n            else resolve({\n                stdout,\n                stderr\n            });\n        });\n    });\n};\nmodule.exports = spawnPlease;\n\n},{\"8fbf49fd88b8ce1a\":\"gOFfe\"}],\"gOFfe\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst cp = require(\"5db4eea157dc6abd\");\nconst parse = require(\"f459d4faad83418d\");\nconst enoent = require(\"5967fe713a07bdb3\");\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n    return spawned;\n}\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n    return result;\n}\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n\n},{\"5db4eea157dc6abd\":\"child_process\",\"f459d4faad83418d\":\"hSOoE\",\"5967fe713a07bdb3\":\"e03Rd\"}],\"hSOoE\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst path = require(\"bb49ff520c0c29ab\");\nconst resolveCommand = require(\"cf8451362f6c35b9\");\nconst escape = require(\"f76fb8d716c0dfc3\");\nconst readShebang = require(\"91585cdbf7f6adf6\");\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n    const shebang = parsed.file && readShebang(parsed.file);\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n        return resolveCommand(parsed);\n    }\n    return parsed.file;\n}\nfunction parseNonShell(parsed) {\n    if (!isWin) return parsed;\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));\n        const shellCommand = [\n            parsed.command\n        ].concat(parsed.args).join(' ');\n        parsed.args = [\n            '/d',\n            '/s',\n            '/c',\n            `\"${shellCommand}\"`\n        ];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n    return parsed;\n}\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args\n        }\n    };\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\nmodule.exports = parse;\n\n},{\"bb49ff520c0c29ab\":\"path\",\"cf8451362f6c35b9\":\"iyIqb\",\"f76fb8d716c0dfc3\":\"kqk3O\",\"91585cdbf7f6adf6\":\"9LoJM\"}],\"iyIqb\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst path = require(\"23fb8fe1b2d52b3\");\nconst which = require(\"f9b07d03c0b43245\");\nconst getPathKey = require(\"ef7a99e848f61b11\");\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) try {\n        process.chdir(parsed.options.cwd);\n    } catch (err) {\n    /* Empty */ }\n    let resolved;\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({\n                env\n            })],\n            pathExt: withoutPathExt ? path.delimiter : undefined\n        });\n    } catch (e) {\n    /* Empty */ } finally{\n        if (shouldSwitchCwd) process.chdir(cwd);\n    }\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    return resolved;\n}\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\nmodule.exports = resolveCommand;\n\n},{\"23fb8fe1b2d52b3\":\"path\",\"f9b07d03c0b43245\":\"g0W6J\",\"ef7a99e848f61b11\":\"7G1S5\"}],\"g0W6J\":[function(require,module,exports,__globalThis) {\nconst isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';\nconst path = require(\"1c762486b04d50e4\");\nconst COLON = isWindows ? ';' : ':';\nconst isexe = require(\"e2e7d3eebf2f2d35\");\nconst getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {\n        code: 'ENOENT'\n    });\nconst getPathInfo = (cmd, opt)=>{\n    const colon = opt.colon || COLON;\n    // If it has a slash, then we don't bother searching the pathenv.\n    // just check the file itself, and that's it.\n    const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [\n        ''\n    ] : [\n        // windows always checks the cwd first\n        ...isWindows ? [\n            process.cwd()\n        ] : [],\n        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ '').split(colon)\n    ];\n    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';\n    const pathExt = isWindows ? pathExtExe.split(colon) : [\n        ''\n    ];\n    if (isWindows) {\n        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');\n    }\n    return {\n        pathEnv,\n        pathExt,\n        pathExtExe\n    };\n};\nconst which = (cmd, opt, cb)=>{\n    if (typeof opt === 'function') {\n        cb = opt;\n        opt = {};\n    }\n    if (!opt) opt = {};\n    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n    const found = [];\n    const step = (i)=>new Promise((resolve, reject)=>{\n            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));\n            const ppRaw = pathEnv[i];\n            const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n            const pCmd = path.join(pathPart, cmd);\n            const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n            resolve(subStep(p, i, 0));\n        });\n    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{\n            if (ii === pathExt.length) return resolve(step(i + 1));\n            const ext = pathExt[ii];\n            isexe(p + ext, {\n                pathExt: pathExtExe\n            }, (er, is)=>{\n                if (!er && is) {\n                    if (opt.all) found.push(p + ext);\n                    else return resolve(p + ext);\n                }\n                return resolve(subStep(p, i, ii + 1));\n            });\n        });\n    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);\n};\nconst whichSync = (cmd, opt)=>{\n    opt = opt || {};\n    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n    const found = [];\n    for(let i = 0; i < pathEnv.length; i++){\n        const ppRaw = pathEnv[i];\n        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n        const pCmd = path.join(pathPart, cmd);\n        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n        for(let j = 0; j < pathExt.length; j++){\n            const cur = p + pathExt[j];\n            try {\n                const is = isexe.sync(cur, {\n                    pathExt: pathExtExe\n                });\n                if (is) {\n                    if (opt.all) found.push(cur);\n                    else return cur;\n                }\n            } catch (ex) {}\n        }\n    }\n    if (opt.all && found.length) return found;\n    if (opt.nothrow) return null;\n    throw getNotFoundError(cmd);\n};\nmodule.exports = which;\nwhich.sync = whichSync;\n\n},{\"1c762486b04d50e4\":\"path\",\"e2e7d3eebf2f2d35\":\"1pcPz\"}],\"1pcPz\":[function(require,module,exports,__globalThis) {\nvar fs = require(\"17f23b75862c81ed\");\nvar core;\nif (process.platform === 'win32' || global.TESTING_WINDOWS) core = require(\"b33dbc941d5fe763\");\nelse core = require(\"5d6b0a3a2e570368\");\nmodule.exports = isexe;\nisexe.sync = sync;\nfunction isexe(path, options, cb) {\n    if (typeof options === 'function') {\n        cb = options;\n        options = {};\n    }\n    if (!cb) {\n        if (typeof Promise !== 'function') throw new TypeError('callback not provided');\n        return new Promise(function(resolve, reject) {\n            isexe(path, options || {}, function(er, is) {\n                if (er) reject(er);\n                else resolve(is);\n            });\n        });\n    }\n    core(path, options || {}, function(er, is) {\n        // ignore EACCES because that just means we aren't allowed to run it\n        if (er) {\n            if (er.code === 'EACCES' || options && options.ignoreErrors) {\n                er = null;\n                is = false;\n            }\n        }\n        cb(er, is);\n    });\n}\nfunction sync(path, options) {\n    // my kingdom for a filtered catch\n    try {\n        return core.sync(path, options || {});\n    } catch (er) {\n        if (options && options.ignoreErrors || er.code === 'EACCES') return false;\n        else throw er;\n    }\n}\n\n},{\"17f23b75862c81ed\":\"fs\",\"b33dbc941d5fe763\":\"cwCNN\",\"5d6b0a3a2e570368\":\"hTVe9\"}],\"cwCNN\":[function(require,module,exports,__globalThis) {\nmodule.exports = isexe;\nisexe.sync = sync;\nvar fs = require(\"fa970ff537f37d97\");\nfunction checkPathExt(path, options) {\n    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;\n    if (!pathext) return true;\n    pathext = pathext.split(';');\n    if (pathext.indexOf('') !== -1) return true;\n    for(var i = 0; i < pathext.length; i++){\n        var p = pathext[i].toLowerCase();\n        if (p && path.substr(-p.length).toLowerCase() === p) return true;\n    }\n    return false;\n}\nfunction checkStat(stat, path, options) {\n    if (!stat.isSymbolicLink() && !stat.isFile()) return false;\n    return checkPathExt(path, options);\n}\nfunction isexe(path, options, cb) {\n    fs.stat(path, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, path, options));\n    });\n}\nfunction sync(path, options) {\n    return checkStat(fs.statSync(path), path, options);\n}\n\n},{\"fa970ff537f37d97\":\"fs\"}],\"hTVe9\":[function(require,module,exports,__globalThis) {\nmodule.exports = isexe;\nisexe.sync = sync;\nvar fs = require(\"ccfd6a39e8d0b5a7\");\nfunction isexe(path, options, cb) {\n    fs.stat(path, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, options));\n    });\n}\nfunction sync(path, options) {\n    return checkStat(fs.statSync(path), options);\n}\nfunction checkStat(stat, options) {\n    return stat.isFile() && checkMode(stat, options);\n}\nfunction checkMode(stat, options) {\n    var mod = stat.mode;\n    var uid = stat.uid;\n    var gid = stat.gid;\n    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();\n    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();\n    var u = parseInt('100', 8);\n    var g = parseInt('010', 8);\n    var o = parseInt('001', 8);\n    var ug = u | g;\n    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;\n    return ret;\n}\n\n},{\"ccfd6a39e8d0b5a7\":\"fs\"}],\"7G1S5\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst pathKey = (options = {})=>{\n    const environment = options.env || process.env;\n    const platform = options.platform || process.platform;\n    if (platform !== 'win32') return 'PATH';\n    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';\n};\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n\n},{}],\"kqk3O\":[function(require,module,exports,__globalThis) {\n'use strict';\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n    return arg;\n}\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n    // All other backslashes occur literally\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, '^$1');\n    return arg;\n}\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n\n},{}],\"9LoJM\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst fs = require(\"2fc5e4232a07a9d2\");\nconst shebangCommand = require(\"c4e857260abf33c0\");\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n    let fd;\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) {}\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\nmodule.exports = readShebang;\n\n},{\"2fc5e4232a07a9d2\":\"fs\",\"c4e857260abf33c0\":\"drkAo\"}],\"drkAo\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst shebangRegex = require(\"9df9c2d321a8ee95\");\nmodule.exports = (string = '')=>{\n    const match = string.match(shebangRegex);\n    if (!match) return null;\n    const [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n    const binary = path.split('/').pop();\n    if (binary === 'env') return argument;\n    return argument ? `${binary} ${argument}` : binary;\n};\n\n},{\"9df9c2d321a8ee95\":\"gq3Q3\"}],\"gq3Q3\":[function(require,module,exports,__globalThis) {\n'use strict';\nmodule.exports = /^#!(.*)/;\n\n},{}],\"e03Rd\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst isWin = process.platform === 'win32';\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args\n    });\n}\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) return;\n    const originalEmit = cp.emit;\n    cp.emit = function(name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n            if (err) return originalEmit.call(cp, 'error', err);\n        }\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, 'spawn');\n    return null;\n}\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, 'spawnSync');\n    return null;\n}\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError\n};\n\n},{}],\"14eXt\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"extractCaches\", ()=>extractCaches);\nvar _fs = require(\"fs\");\nvar _path = require(\"path\");\nvar _pathDefault = parcelHelpers.interopDefault(_path);\nvar _optsJs = require(\"./opts.js\");\nvar _runJs = require(\"./run.js\");\nvar _loggerJs = require(\"./logger.js\");\nasync function extractCachesBatch(cacheMap, scratchDir, containerImage, builder) {\n    return await (0, _loggerJs.logGroup)(`Extract all caches in batch`, async ()=>{\n        const imageTag = `dance:extract-batch`;\n        const containerName = `cache-container-batch`;\n        (0, _loggerJs.logInfo)(`Preparing batch cache extraction for ${Object.keys(cacheMap).length} cache(s) using builder '${builder}'.`);\n        // Prepare Timestamp for Layer Cache Busting\n        const date = new Date().toISOString();\n        await (0, _fs.promises).rm(scratchDir, {\n            recursive: true,\n            force: true\n        });\n        await (0, _fs.promises).mkdir(scratchDir, {\n            recursive: true\n        });\n        await (0, _fs.promises).writeFile((0, _pathDefault.default).join(scratchDir, 'buildstamp'), date);\n        // Prepare Dancefile to Access All Caches\n        const cacheEntries = Object.entries(cacheMap);\n        const mountArgs = cacheEntries.map(([_, cacheOptions])=>(0, _optsJs.getMountArgsString)(cacheOptions)).join(' ');\n        // Create RUN commands to copy each cache to a numbered subdirectory\n        const copyCommands = cacheEntries.map(([cacheSource, cacheOptions], index)=>{\n            const targetPath = (0, _optsJs.getTargetPath)(cacheOptions);\n            const cacheId = `cache-${index}`;\n            return `mkdir -p \"/var/dance-cache/${cacheId}/\" && cp -p -R ${targetPath}/. \"/var/dance-cache/${cacheId}/\" || true`;\n        }).join(' && ');\n        const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    ${copyCommands}\n`;\n        (0, _loggerJs.logVerbose)(`Dancefile for batch extraction generated:\\n${dancefileContent}`);\n        // Extract Data into Docker Image\n        await (0, _runJs.runWithInput)('docker', [\n            'buildx',\n            'build',\n            '--builder',\n            builder,\n            '-f',\n            '-',\n            '--tag',\n            imageTag,\n            '--load',\n            scratchDir\n        ], dancefileContent);\n        // Create Extraction Container\n        try {\n            await (0, _runJs.run)('docker', [\n                'rm',\n                '-f',\n                containerName\n            ]);\n        } catch (error) {\n        // Ignore error if container does not exist\n        }\n        await (0, _runJs.run)('docker', [\n            'create',\n            '-ti',\n            '--name',\n            containerName,\n            imageTag\n        ]);\n        // Extract all caches in one operation\n        await (0, _runJs.runPiped)([\n            'docker',\n            [\n                'cp',\n                '-L',\n                `${containerName}:/var/dance-cache`,\n                '-'\n            ]\n        ], [\n            'tar',\n            [\n                '-H',\n                'posix',\n                '-x',\n                '-C',\n                scratchDir\n            ]\n        ]);\n        // Move each cache from scratch to its target location\n        for (const [cacheSource, _] of cacheEntries){\n            const index = cacheEntries.findIndex(([source, _])=>source === cacheSource);\n            const cacheId = `cache-${index}`;\n            const sourcePath = (0, _pathDefault.default).join(scratchDir, 'dance-cache', cacheId);\n            await (0, _fs.promises).mkdir((0, _pathDefault.default).dirname(cacheSource), {\n                recursive: true\n            });\n            try {\n                await (0, _runJs.run)('sudo', [\n                    'rm',\n                    '-rf',\n                    cacheSource\n                ]);\n            } catch (error) {\n                (0, _loggerJs.logWarning)(`Failed to clean existing cache directory '${cacheSource}' with sudo. Attempting fallback without sudo.`);\n                try {\n                    await (0, _fs.promises).rm(cacheSource, {\n                        recursive: true,\n                        force: true\n                    });\n                } catch (cleanupError) {\n                    (0, _loggerJs.logError)(`Unable to remove existing cache directory '${cacheSource}': ${cleanupError}`);\n                    throw cleanupError;\n                }\n            }\n            try {\n                await (0, _fs.promises).rename(sourcePath, cacheSource);\n                (0, _loggerJs.logInfo)(`Cache extraction completed for source '${cacheSource}'.`);\n            } catch (error) {\n                if (error.code === 'ENOENT') {\n                    await (0, _fs.promises).mkdir(cacheSource, {\n                        recursive: true\n                    });\n                    (0, _loggerJs.logVerbose)(`Cache extraction produced no files for '${cacheSource}'. Directory created.`);\n                } else {\n                    (0, _loggerJs.logError)(`Failed to move extracted cache from '${sourcePath}' to '${cacheSource}': ${error}`);\n                    throw error;\n                }\n            }\n        }\n        // Clean up container and scratch directory\n        try {\n            await (0, _runJs.run)('docker', [\n                'rm',\n                '-f',\n                containerName\n            ]);\n        } catch (error) {\n            // Ignore cleanup errors\n            (0, _loggerJs.logVerbose)(`Failed to clean up container '${containerName}': ${error}`);\n        }\n        try {\n            await (0, _fs.promises).rm(scratchDir, {\n                recursive: true,\n                force: true\n            });\n        } catch (error) {\n            // Ignore cleanup errors\n            (0, _loggerJs.logVerbose)(`Failed to clean up scratch directory '${scratchDir}': ${error}`);\n        }\n        (0, _loggerJs.logInfo)(`Batch cache extraction completed for ${Object.keys(cacheMap).length} cache(s).`);\n    });\n}\nasync function extractCaches(opts) {\n    if (opts[\"skip-extraction\"]) {\n        (0, _loggerJs.logInfo)(\"skip-extraction is set. Skipping extraction step...\");\n        return;\n    }\n    const cacheMap = await (0, _optsJs.getCacheMap)(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n    const builder = (0, _optsJs.getBuilder)(opts);\n    // Extract all caches in a single batch operation\n    (0, _loggerJs.logInfo)(`Extracting ${Object.keys(cacheMap).length} cache mount(s) using image '${containerImage}'.`);\n    if (Object.keys(cacheMap).length === 0) {\n        (0, _loggerJs.logInfo)(\"No caches to extract.\");\n        return;\n    }\n    await extractCachesBatch(cacheMap, scratchDir, containerImage, builder);\n}\n\n},{\"fs\":\"fs\",\"path\":\"path\",\"./opts.js\":\"bjlzi\",\"./run.js\":\"kHqLa\",\"./logger.js\":\"lnguQ\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}]},[\"7sz5b\"], \"7sz5b\", \"parcelRequire86b4\", {\"fs\": __parcelExternal0,\"os\": __parcelExternal1,\"path\": __parcelExternal2,\"http\": __parcelExternal3,\"https\": __parcelExternal4,\"net\": __parcelExternal5,\"tls\": __parcelExternal6,\"events\": __parcelExternal7,\"assert\": __parcelExternal8,\"util\": __parcelExternal9,\"async_hooks\": __parcelExternal10,\"child_process\": __parcelExternal11,})\nlet {} = parcelRequire86b4(\"7sz5b\");\nexport {};\n\n//# sourceMappingURL=index.js.map\n","import { promises as fs } from \"fs\";\nimport os from \"os\";\nimport { injectCaches } from \"./inject-cache.js\";\nimport { extractCaches } from \"./extract-cache.js\";\nimport { help, parseOpts } from \"./opts.js\";\nimport { configureLogger, logError, logInfo, logVerbose } from \"./logger.js\";\n\nasync function main(args: string[]) {\n  const opts = parseOpts(args);\n\n  configureLogger({ verbose: opts.verbose });\n\n  if (opts.help) {\n    logInfo(\"Displaying help information...\");\n    return help();\n  }\n\n  if (opts.extract) {\n    // Run the post step\n    logInfo(\"Starting cache extraction workflow...\");\n    await extractCaches(opts);\n  } else {\n    // Otherwise, this is the main step\n    if (process.env.GITHUB_STATE !== undefined) {\n      await fs.appendFile(process.env.GITHUB_STATE, `POST=true${os.EOL}`);\n    }\n    logInfo(\"Starting cache injection workflow...\");\n    await injectCaches(opts);\n  }\n}\n\nmain(process.argv)\n    .catch(err => {\n        logError(err instanceof Error ? err : String(err));\n        if (err instanceof Error && err.stack) {\n            logVerbose(err.stack);\n        }\n        process.exit(1);\n    });\n","import { promises as fs } from \"fs\";\nimport path from 'path';\nimport { CacheOptions, Opts, getCacheMap, getMountArgsString, getTargetPath, getUID, getGID, getBuilder } from './opts.js';\nimport { run, runWithInput } from './run.js';\nimport { logGroup, logInfo, logNotice, logVerbose, logWarning } from './logger.js';\n\nfunction createJobId(cacheSource: string): string {\n    const slug = cacheSource\n        .replace(/^[\\\\/]+/, '')\n        .replace(/[\\\\/]+/g, '-')\n        .replace(/[^a-zA-Z0-9_.-]/g, '-')\n        .toLowerCase()\n        .slice(-40);\n    const unique = Math.random().toString(36).slice(2, 10);\n    return `${slug || 'cache'}-${unique}`;\n}\n\nasync function injectCache(cacheSource: string, cacheOptions: CacheOptions, scratchDir: string, containerImage: string, builder: string) {\n    return await logGroup(`Inject cache for ${cacheSource}`, async () => {\n        const jobId = createJobId(cacheSource);\n        const jobScratchDir = path.join(scratchDir, jobId);\n        const imageTag = `dance:inject-${jobId}`;\n\n        logInfo(`Preparing cache injection for source '${cacheSource}' using builder '${builder}'.`);\n\n        await fs.rm(jobScratchDir, { recursive: true, force: true });\n        await fs.mkdir(jobScratchDir, { recursive: true });\n\n        // Prepare Cache Source Directory\n        await fs.mkdir(cacheSource, { recursive: true });\n        logVerbose(`Working directory prepared at '${cacheSource}'.`);\n\n        // Prepare Timestamp for Layer Cache Busting\n        const date = new Date().toISOString();\n        await fs.writeFile(path.join(cacheSource, 'buildstamp'), date);\n        logVerbose(`Build timestamp written for cache busting: ${date}.`);\n\n        const targetPath = getTargetPath(cacheOptions);\n        const mountArgs = getMountArgsString(cacheOptions);\n\n        // If UID OR GID are set, then add chown to restore files ownership.\n        let ownershipCommand = \"\";\n        const uid = getUID(cacheOptions);\n        const gid = getGID(cacheOptions);\n        if (uid !== \"\" || gid !== \"\") {\n            ownershipCommand = `&& chown -R ${uid}:${gid} ${targetPath}`\n        }\n\n        // Prepare Dancefile to Access Caches\n        const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    --mount=type=bind,source=.,target=/var/dance-cache \\\n    cp -p -R /var/dance-cache/. ${targetPath} ${ownershipCommand} || true\n`;\n        logVerbose(`Dancefile for injection generated:\\n${dancefileContent}`);\n\n        // Inject Data into Docker Cache\n        logInfo(`Running docker buildx to inject cache for '${cacheSource}'.`);\n        await runWithInput('docker', ['buildx', 'build', '--builder', builder ,'-f', '-', '--tag', imageTag, cacheSource], dancefileContent);\n\n        // Clean Directories\n        try {\n            await fs.rm(cacheSource, { recursive: true, force: true });\n        } catch (err) {\n            // Ignore Cleaning Errors\n            logNotice(`Error while cleaning cache source directory at '${cacheSource}': ${err}. Ignoring...`);\n        }\n\n        await fs.rm(jobScratchDir, { recursive: true, force: true });\n\n        logInfo(`Cache injection completed for source '${cacheSource}'.`);\n    });\n}\n\n\nexport async function injectCaches(opts: Opts) {\n    const cacheMap = await getCacheMap(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n\n    const builder = getBuilder(opts);\n    logInfo(`Injecting ${Object.keys(cacheMap).length} cache mount(s) using image '${containerImage}'.`);\n    // Inject Caches for each source-target pair\n    const tasks = Object.entries(cacheMap).map(([cacheSource, cacheOptions]) =>\n        injectCache(cacheSource, cacheOptions, scratchDir, containerImage, builder)\n            .catch(error => {\n                logWarning(`Cache injection failed for '${cacheSource}': ${error}`);\n                throw error;\n            })\n    );\n\n    await Promise.all(tasks);\n}\n","import mri from 'mri';\nimport { promises as fs } from 'fs';\nimport { getInput, warning } from '@actions/core/lib/core.js';\nimport { DockerfileParser, ModifiableInstruction } from 'dockerfile-ast';\nimport { logInfo, logVerbose } from './logger.js';\n\nexport type Opts = {\n  \"extract\": boolean\n  \"cache-map\": string\n  \"dockerfile\": string\n  \"cache-dir\": string | null\n  \"scratch-dir\": string\n  \"skip-extraction\": boolean\n  \"utility-image\": string\n  \"builder\"?: string\n  \"verbose\": boolean\n  help: boolean\n  /** @deprecated Use `cache-map` instead */\n  \"cache-source\"?: string\n  /** @deprecated Use `cache-map` instead */\n  \"cache-target\"?: string\n}\n\nexport function parseOpts(args: string[]): mri.Argv<Opts> {\n  const opts = mri<Opts>(args, {\n    default: {\n      \"cache-map\": getInput(\"cache-map\") || \"{}\",\n      \"dockerfile\": getInput(\"dockerfile\") || \"Dockerfile\",\n      \"cache-dir\": getInput(\"cache-dir\") || null,\n      \"scratch-dir\": getInput(\"scratch-dir\") || \"scratch\",\n      \"skip-extraction\": (getInput(\"skip-extraction\") || \"false\") === \"true\",\n      \"extract\": process.env[`STATE_POST`] !== undefined,\n      \"utility-image\": getInput(\"utility-image\") || \"ghcr.io/containerd/busybox:latest\",\n      \"builder\": getInput(\"builder\") || \"default\",\n      \"verbose\": (getInput(\"verbose\") || \"false\") === \"true\",\n      \"help\": false,\n    },\n    string: [\"cache-map\", \"dockerfile\", \"cache-dir\", \"scratch-dir\", \"cache-source\", \"cache-target\", \"utility-image\", \"builder\"],\n    boolean: [\"skip-extraction\", \"help\", \"extract\", \"verbose\"],\n    alias: {\n      \"help\": [\"h\"],\n    },\n  })\n\n  if (opts[\"cache-source\"] && opts[\"cache-target\"]) {\n    warning(\"The `cache-source` and `cache-target` options are deprecated. Use `cache-map` instead.\")\n\n    opts[\"cache-map\"] = JSON.stringify({\n      [opts[\"cache-source\"]]: opts[\"cache-target\"],\n    });\n  }\n\n  return opts;\n}\n\nexport function help() {\n  console.log(`build-cache-dance [options]\nSave 'RUN --mount=type=cache' caches on GitHub Actions or other CI platforms\n\nOptions:\n  --extract      Extract the cache from the docker container (extract step). Otherwise, inject the cache (main step)\n  --cache-map    The map of actions source paths to container destination paths or mount arguments\n  --dockerfile   The Dockerfile to use for auto-discovery of the cache-map. Default: 'Dockerfile'\n  --cache-dir    The root directory where cache content is injected from/extracted to when using auto-discovery of the cache-map.\n  --scratch-dir  Where the action is stores some temporary files for its processing. Default: 'scratch'\n  --skip-extraction  Skip the extraction of the cache from the docker container\n  --utility-image  The container image to use for injecting and extracting the cache. Default: 'ghcr.io/containerd/busybox:latest'\n  --builder      The name of the buildx builder to use for the cache injection\n  --verbose      Enable verbose logging output\n  --help         Show this help\n`);\n}\n\nexport type SourcePath = string\nexport type TargetPath = string\nexport type ToStringable = {\n  toString(): string;\n}\nexport type CacheOptions = TargetPath | { target: TargetPath } & Record<string, ToStringable>\nexport type CacheMap = Record<SourcePath, CacheOptions>\n\nasync function getCacheMapFromDockerfile(dockerfilePath: string, bindRoot: string | null): Promise<CacheMap> {\n  const dockerfileContent = await fs.readFile(dockerfilePath, \"utf-8\");\n  const dockerfile = DockerfileParser.parse(dockerfileContent);\n\n  const cacheMap: CacheMap = {};\n\n  const runInstructions = dockerfile.getInstructions().filter(i => i.getKeyword() == 'RUN') as Array<ModifiableInstruction>;\n  for (const run of runInstructions) {\n    for (const flag of run.getFlags()) {\n      if (flag.getName() == 'mount' && flag.getOption('type')?.getValue() == 'cache') {\n        // Extract the `id` flag which defaults to `target` when `id` is not set\n        // https://docs.docker.com/reference/dockerfile/#run---mounttypecache\n        const id = flag.getOption('id')?.getValue() || flag.getOption('target')?.getValue();\n        if (id == null) {\n          throw new Error('cache mount must define id or target: ' + flag.toString() + ' in ' + run.toString());\n        }\n\n        // The directory on the host to inject/extract the cache mount data from\n        const bindDir = bindRoot !== null ? `${bindRoot}/${id}` : id\n\n        // The target in this action does not matter as long as it is\n        // different than /var/dance-cache of course\n        const target = \"/var/cache-target\";\n\n        cacheMap[bindDir] = {\n          id,\n          target,\n        };\n      }\n    }\n  }\n\n  return cacheMap;\n}\n\nexport async function getCacheMap(opts: Opts): Promise<CacheMap> {\n  try {\n    const cacheMap = JSON.parse(opts[\"cache-map\"]) as CacheMap;\n    if (Object.keys(cacheMap).length !== 0) {\n      return cacheMap;\n    }\n\n    logInfo(`No cache map provided. Trying to parse the Dockerfile to find the cache mount instructions...`);\n    const cacheMapFromDockerfile = await getCacheMapFromDockerfile(opts[\"dockerfile\"], opts[\"cache-dir\"]);\n    logVerbose(`Cache map parsed from Dockerfile: ${JSON.stringify(cacheMapFromDockerfile)}`);\n    return cacheMapFromDockerfile;\n  } catch (e) {\n    throw new Error(`Failed to parse cache map. Expected JSON, got:\\n${opts[\"cache-map\"]}\\n${e}`);\n  }\n}\n\nexport function getTargetPath(cacheOptions: CacheOptions): TargetPath {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return cacheOptions;\n  } else {\n    // object is provided\n    if (\"target\" in cacheOptions) {\n      return cacheOptions.target;\n    } else {\n      throw new Error(`Expected the 'target' key in the cache options, got:\\n${cacheOptions}`);\n    }\n  }\n}\n\nexport function getUID(cacheOptions: CacheOptions): string {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return \"\";\n  } else {\n    // object is provided\n    if (\"uid\" in cacheOptions && cacheOptions.uid !== undefined) {\n      return cacheOptions.uid.toString();\n    } else {\n      return \"\";\n    }\n  }\n}\n\nexport function getGID(cacheOptions: CacheOptions): string {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return \"\";\n  } else {\n    // object is provided\n    if (\"gid\" in cacheOptions && cacheOptions.gid !== undefined) {\n      return cacheOptions.gid.toString();\n    } else {\n      return \"\";\n    }\n  }\n}\n\n/**\n * Convert a cache options to a string that is passed to --mount=\n * @param CacheOptions The cache options to convert to a string\n */\nexport function getMountArgsString(cacheOptions: CacheOptions): string {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return `type=cache,target=${cacheOptions}`;\n  } else {\n    // other options are provided\n    const otherOptions = Object.entries(cacheOptions).map(([key, value]) => `${key}=${value}`).join(\",\");\n    return `type=cache,${otherOptions}`;\n  }\n}\n\nexport function getBuilder(opts: Opts): string {\n    return opts[\"builder\"] == null || opts[\"builder\"] == \"\" ? \"default\" : opts[\"builder\"];\n}\n","function toArr(any) {\n\treturn any == null ? [] : Array.isArray(any) ? any : [any];\n}\n\nfunction toVal(out, key, val, opts) {\n\tvar x, old=out[key], nxt=(\n\t\t!!~opts.string.indexOf(key) ? (val == null || val === true ? '' : String(val))\n\t\t: typeof val === 'boolean' ? val\n\t\t: !!~opts.boolean.indexOf(key) ? (val === 'false' ? false : val === 'true' || (out._.push((x = +val,x * 0 === 0) ? x : val),!!val))\n\t\t: (x = +val,x * 0 === 0) ? x : val\n\t);\n\tout[key] = old == null ? nxt : (Array.isArray(old) ? old.concat(nxt) : [old, nxt]);\n}\n\nexport default function (args, opts) {\n\targs = args || [];\n\topts = opts || {};\n\n\tvar k, arr, arg, name, val, out={ _:[] };\n\tvar i=0, j=0, idx=0, len=args.length;\n\n\tconst alibi = opts.alias !== void 0;\n\tconst strict = opts.unknown !== void 0;\n\tconst defaults = opts.default !== void 0;\n\n\topts.alias = opts.alias || {};\n\topts.string = toArr(opts.string);\n\topts.boolean = toArr(opts.boolean);\n\n\tif (alibi) {\n\t\tfor (k in opts.alias) {\n\t\t\tarr = opts.alias[k] = toArr(opts.alias[k]);\n\t\t\tfor (i=0; i < arr.length; i++) {\n\t\t\t\t(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=opts.boolean.length; i-- > 0;) {\n\t\tarr = opts.alias[opts.boolean[i]] || [];\n\t\tfor (j=arr.length; j-- > 0;) opts.boolean.push(arr[j]);\n\t}\n\n\tfor (i=opts.string.length; i-- > 0;) {\n\t\tarr = opts.alias[opts.string[i]] || [];\n\t\tfor (j=arr.length; j-- > 0;) opts.string.push(arr[j]);\n\t}\n\n\tif (defaults) {\n\t\tfor (k in opts.default) {\n\t\t\tname = typeof opts.default[k];\n\t\t\tarr = opts.alias[k] = opts.alias[k] || [];\n\t\t\tif (opts[name] !== void 0) {\n\t\t\t\topts[name].push(k);\n\t\t\t\tfor (i=0; i < arr.length; i++) {\n\t\t\t\t\topts[name].push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst keys = strict ? Object.keys(opts.alias) : [];\n\n\tfor (i=0; i < len; i++) {\n\t\targ = args[i];\n\n\t\tif (arg === '--') {\n\t\t\tout._ = out._.concat(args.slice(++i));\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j=0; j < arg.length; j++) {\n\t\t\tif (arg.charCodeAt(j) !== 45) break; // \"-\"\n\t\t}\n\n\t\tif (j === 0) {\n\t\t\tout._.push(arg);\n\t\t} else if (arg.substring(j, j + 3) === 'no-') {\n\t\t\tname = arg.substring(j + 3);\n\t\t\tif (strict && !~keys.indexOf(name)) {\n\t\t\t\treturn opts.unknown(arg);\n\t\t\t}\n\t\t\tout[name] = false;\n\t\t} else {\n\t\t\tfor (idx=j+1; idx < arg.length; idx++) {\n\t\t\t\tif (arg.charCodeAt(idx) === 61) break; // \"=\"\n\t\t\t}\n\n\t\t\tname = arg.substring(j, idx);\n\t\t\tval = arg.substring(++idx) || (i+1 === len || (''+args[i+1]).charCodeAt(0) === 45 || args[++i]);\n\t\t\tarr = (j === 2 ? [name] : name);\n\n\t\t\tfor (idx=0; idx < arr.length; idx++) {\n\t\t\t\tname = arr[idx];\n\t\t\t\tif (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);\n\t\t\t\ttoVal(out, name, (idx + 1 < arr.length) || val, opts);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (defaults) {\n\t\tfor (k in opts.default) {\n\t\t\tif (out[k] === void 0) {\n\t\t\t\tout[k] = opts.default[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alibi) {\n\t\tfor (k in out) {\n\t\t\tarr = opts.alias[k] || [];\n\t\t\twhile (arr.length > 0) {\n\t\t\t\tout[arr.shift()] = out[k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n",null,null,null,null,null,null,null,null,null,null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...((proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    }),\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' +\n                Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n",null,null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DockerfileParser = exports.DefaultVariables = exports.Directive = exports.Keyword = exports.Workdir = exports.Volume = exports.User = exports.Stopsignal = exports.Shell = exports.Run = exports.PropertyInstruction = exports.Onbuild = exports.ModifiableInstruction = exports.Label = exports.JSONInstruction = exports.Heredoc = exports.Healthcheck = exports.From = exports.Env = exports.Entrypoint = exports.Copy = exports.Cmd = exports.Arg = exports.Add = exports.Variable = exports.Property = exports.ParserDirective = exports.Line = exports.Instruction = exports.Flag = exports.Comment = exports.JSONArgument = exports.Argument = void 0;\nvar argument_1 = require(\"./argument\");\nObject.defineProperty(exports, \"Argument\", { enumerable: true, get: function () { return argument_1.Argument; } });\nvar jsonArgument_1 = require(\"./jsonArgument\");\nObject.defineProperty(exports, \"JSONArgument\", { enumerable: true, get: function () { return jsonArgument_1.JSONArgument; } });\nconst comment_1 = require(\"./comment\");\nObject.defineProperty(exports, \"Comment\", { enumerable: true, get: function () { return comment_1.Comment; } });\nconst parser_1 = require(\"./parser\");\nvar flag_1 = require(\"./flag\");\nObject.defineProperty(exports, \"Flag\", { enumerable: true, get: function () { return flag_1.Flag; } });\nconst instruction_1 = require(\"./instruction\");\nObject.defineProperty(exports, \"Instruction\", { enumerable: true, get: function () { return instruction_1.Instruction; } });\nvar line_1 = require(\"./line\");\nObject.defineProperty(exports, \"Line\", { enumerable: true, get: function () { return line_1.Line; } });\nconst parserDirective_1 = require(\"./parserDirective\");\nObject.defineProperty(exports, \"ParserDirective\", { enumerable: true, get: function () { return parserDirective_1.ParserDirective; } });\nvar property_1 = require(\"./property\");\nObject.defineProperty(exports, \"Property\", { enumerable: true, get: function () { return property_1.Property; } });\nvar variable_1 = require(\"./variable\");\nObject.defineProperty(exports, \"Variable\", { enumerable: true, get: function () { return variable_1.Variable; } });\nvar add_1 = require(\"./instructions/add\");\nObject.defineProperty(exports, \"Add\", { enumerable: true, get: function () { return add_1.Add; } });\nconst arg_1 = require(\"./instructions/arg\");\nObject.defineProperty(exports, \"Arg\", { enumerable: true, get: function () { return arg_1.Arg; } });\nconst cmd_1 = require(\"./instructions/cmd\");\nObject.defineProperty(exports, \"Cmd\", { enumerable: true, get: function () { return cmd_1.Cmd; } });\nconst copy_1 = require(\"./instructions/copy\");\nObject.defineProperty(exports, \"Copy\", { enumerable: true, get: function () { return copy_1.Copy; } });\nconst entrypoint_1 = require(\"./instructions/entrypoint\");\nObject.defineProperty(exports, \"Entrypoint\", { enumerable: true, get: function () { return entrypoint_1.Entrypoint; } });\nconst env_1 = require(\"./instructions/env\");\nObject.defineProperty(exports, \"Env\", { enumerable: true, get: function () { return env_1.Env; } });\nconst from_1 = require(\"./instructions/from\");\nObject.defineProperty(exports, \"From\", { enumerable: true, get: function () { return from_1.From; } });\nconst healthcheck_1 = require(\"./instructions/healthcheck\");\nObject.defineProperty(exports, \"Healthcheck\", { enumerable: true, get: function () { return healthcheck_1.Healthcheck; } });\nvar heredoc_1 = require(\"./heredoc\");\nObject.defineProperty(exports, \"Heredoc\", { enumerable: true, get: function () { return heredoc_1.Heredoc; } });\nvar jsonInstruction_1 = require(\"./jsonInstruction\");\nObject.defineProperty(exports, \"JSONInstruction\", { enumerable: true, get: function () { return jsonInstruction_1.JSONInstruction; } });\nvar label_1 = require(\"./instructions/label\");\nObject.defineProperty(exports, \"Label\", { enumerable: true, get: function () { return label_1.Label; } });\nvar modifiableInstruction_1 = require(\"./modifiableInstruction\");\nObject.defineProperty(exports, \"ModifiableInstruction\", { enumerable: true, get: function () { return modifiableInstruction_1.ModifiableInstruction; } });\nvar onbuild_1 = require(\"./instructions/onbuild\");\nObject.defineProperty(exports, \"Onbuild\", { enumerable: true, get: function () { return onbuild_1.Onbuild; } });\nvar propertyInstruction_1 = require(\"./propertyInstruction\");\nObject.defineProperty(exports, \"PropertyInstruction\", { enumerable: true, get: function () { return propertyInstruction_1.PropertyInstruction; } });\nvar run_1 = require(\"./instructions/run\");\nObject.defineProperty(exports, \"Run\", { enumerable: true, get: function () { return run_1.Run; } });\nvar shell_1 = require(\"./instructions/shell\");\nObject.defineProperty(exports, \"Shell\", { enumerable: true, get: function () { return shell_1.Shell; } });\nvar stopsignal_1 = require(\"./instructions/stopsignal\");\nObject.defineProperty(exports, \"Stopsignal\", { enumerable: true, get: function () { return stopsignal_1.Stopsignal; } });\nvar user_1 = require(\"./instructions/user\");\nObject.defineProperty(exports, \"User\", { enumerable: true, get: function () { return user_1.User; } });\nvar volume_1 = require(\"./instructions/volume\");\nObject.defineProperty(exports, \"Volume\", { enumerable: true, get: function () { return volume_1.Volume; } });\nconst workdir_1 = require(\"./instructions/workdir\");\nObject.defineProperty(exports, \"Workdir\", { enumerable: true, get: function () { return workdir_1.Workdir; } });\nvar Keyword;\n(function (Keyword) {\n    Keyword[\"ADD\"] = \"ADD\";\n    Keyword[\"ARG\"] = \"ARG\";\n    Keyword[\"CMD\"] = \"CMD\";\n    Keyword[\"COPY\"] = \"COPY\";\n    Keyword[\"ENTRYPOINT\"] = \"ENTRYPOINT\";\n    Keyword[\"ENV\"] = \"ENV\";\n    Keyword[\"EXPOSE\"] = \"EXPOSE\";\n    Keyword[\"FROM\"] = \"FROM\";\n    Keyword[\"HEALTHCHECK\"] = \"HEALTHCHECK\";\n    Keyword[\"LABEL\"] = \"LABEL\";\n    Keyword[\"MAINTAINER\"] = \"MAINTAINER\";\n    Keyword[\"ONBUILD\"] = \"ONBUILD\";\n    Keyword[\"RUN\"] = \"RUN\";\n    Keyword[\"SHELL\"] = \"SHELL\";\n    Keyword[\"STOPSIGNAL\"] = \"STOPSIGNAL\";\n    Keyword[\"USER\"] = \"USER\";\n    Keyword[\"VOLUME\"] = \"VOLUME\";\n    Keyword[\"WORKDIR\"] = \"WORKDIR\";\n})(Keyword || (exports.Keyword = Keyword = {}));\nvar Directive;\n(function (Directive) {\n    Directive[\"escape\"] = \"escape\";\n    Directive[\"syntax\"] = \"syntax\";\n})(Directive || (exports.Directive = Directive = {}));\nexports.DefaultVariables = [\n    \"ALL_PROXY\", \"all_proxy\",\n    \"FTP_PROXY\", \"ftp_proxy\",\n    \"HTTP_PROXY\", \"http_proxy\",\n    \"HTTPS_PROXY\", \"https_proxy\",\n    \"NO_PROXY\", \"no_proxy\"\n];\nvar DockerfileParser;\n(function (DockerfileParser) {\n    function parse(content) {\n        let parser = new parser_1.Parser();\n        return parser.parse(content);\n    }\n    DockerfileParser.parse = parse;\n})(DockerfileParser || (exports.DockerfileParser = DockerfileParser = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Argument = void 0;\nclass Argument {\n    constructor(value, range) {\n        this.value = value;\n        this.range = range;\n    }\n    toString() {\n        return this.value;\n    }\n    getRange() {\n        return this.range;\n    }\n    getValue() {\n        return this.value;\n    }\n    isAfter(position) {\n        if (this.range.end.line < position.line) {\n            return false;\n        }\n        return this.range.start.line > position.line ? true : this.range.start.character > position.character;\n    }\n    isBefore(position) {\n        if (this.range.start.line < position.line) {\n            return true;\n        }\n        return this.range.end.line > position.line ? false : this.range.end.character < position.character;\n    }\n}\nexports.Argument = Argument;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONArgument = void 0;\nconst argument_1 = require(\"./argument\");\nclass JSONArgument extends argument_1.Argument {\n    constructor(value, range, jsonRange) {\n        super(value, range);\n        this.jsonRange = jsonRange;\n    }\n    getJSONRange() {\n        return this.jsonRange;\n    }\n    getJSONValue() {\n        let value = super.getValue();\n        value = value.substring(1, value.length - 1);\n        return value;\n    }\n}\nexports.JSONArgument = JSONArgument;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Comment = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst line_1 = require(\"./line\");\nconst util_1 = require(\"./util\");\nclass Comment extends line_1.Line {\n    constructor(document, range) {\n        super(document, range);\n    }\n    toString() {\n        const content = this.getContent();\n        if (content) {\n            return \"# \" + content;\n        }\n        return \"#\";\n    }\n    /**\n     * Returns the content of this comment. This excludes leading and\n     * trailing whitespace as well as the # symbol. If the comment only\n     * consists of whitespace, the empty string will be returned.\n     */\n    getContent() {\n        let range = this.getContentRange();\n        if (range === null) {\n            return \"\";\n        }\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    /**\n     * Returns a range that includes the content of the comment\n     * excluding any leading and trailing whitespace as well as the #\n     * symbol. May return null if the comment only consists of whitespace\n     * characters.\n     */\n    getContentRange() {\n        let range = this.getRange();\n        const startOffset = this.document.offsetAt(range.start);\n        let raw = this.document.getText().substring(startOffset, this.document.offsetAt(range.end));\n        let start = -1;\n        let end = -1;\n        // skip the first # symbol\n        for (let i = 1; i < raw.length; i++) {\n            if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n                start = i;\n                break;\n            }\n        }\n        if (start === -1) {\n            return null;\n        }\n        // go backwards up to the first # symbol\n        for (let i = raw.length - 1; i >= 1; i--) {\n            if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n                end = i + 1;\n                break;\n            }\n        }\n        return vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + start), this.document.positionAt(startOffset + end));\n    }\n}\nexports.Comment = Comment;\n","(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;\n    var DocumentUri;\n    (function (DocumentUri) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        DocumentUri.is = is;\n    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));\n    var URI;\n    (function (URI) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        URI.is = is;\n    })(URI || (exports.URI = URI = {}));\n    var integer;\n    (function (integer) {\n        integer.MIN_VALUE = -2147483648;\n        integer.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n        }\n        integer.is = is;\n    })(integer || (exports.integer = integer = {}));\n    var uinteger;\n    (function (uinteger) {\n        uinteger.MIN_VALUE = 0;\n        uinteger.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n        }\n        uinteger.is = is;\n    })(uinteger || (exports.uinteger = uinteger = {}));\n    /**\n     * The Position namespace provides helper functions to work with\n     * {@link Position} literals.\n     */\n    var Position;\n    (function (Position) {\n        /**\n         * Creates a new Position literal from the given line and character.\n         * @param line The position's line.\n         * @param character The position's character.\n         */\n        function create(line, character) {\n            if (line === Number.MAX_VALUE) {\n                line = uinteger.MAX_VALUE;\n            }\n            if (character === Number.MAX_VALUE) {\n                character = uinteger.MAX_VALUE;\n            }\n            return { line: line, character: character };\n        }\n        Position.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Position} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n        }\n        Position.is = is;\n    })(Position || (exports.Position = Position = {}));\n    /**\n     * The Range namespace provides helper functions to work with\n     * {@link Range} literals.\n     */\n    var Range;\n    (function (Range) {\n        function create(one, two, three, four) {\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n                return { start: Position.create(one, two), end: Position.create(three, four) };\n            }\n            else if (Position.is(one) && Position.is(two)) {\n                return { start: one, end: two };\n            }\n            else {\n                throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n            }\n        }\n        Range.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Range} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n        }\n        Range.is = is;\n    })(Range || (exports.Range = Range = {}));\n    /**\n     * The Location namespace provides helper functions to work with\n     * {@link Location} literals.\n     */\n    var Location;\n    (function (Location) {\n        /**\n         * Creates a Location literal.\n         * @param uri The location's uri.\n         * @param range The location's range.\n         */\n        function create(uri, range) {\n            return { uri: uri, range: range };\n        }\n        Location.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Location} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n        }\n        Location.is = is;\n    })(Location || (exports.Location = Location = {}));\n    /**\n     * The LocationLink namespace provides helper functions to work with\n     * {@link LocationLink} literals.\n     */\n    var LocationLink;\n    (function (LocationLink) {\n        /**\n         * Creates a LocationLink literal.\n         * @param targetUri The definition's uri.\n         * @param targetRange The full range of the definition.\n         * @param targetSelectionRange The span of the symbol definition at the target.\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\n         */\n        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n        }\n        LocationLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n                && Range.is(candidate.targetSelectionRange)\n                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n        }\n        LocationLink.is = is;\n    })(LocationLink || (exports.LocationLink = LocationLink = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link Color} literals.\n     */\n    var Color;\n    (function (Color) {\n        /**\n         * Creates a new Color literal.\n         */\n        function create(red, green, blue, alpha) {\n            return {\n                red: red,\n                green: green,\n                blue: blue,\n                alpha: alpha,\n            };\n        }\n        Color.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Color} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n                && Is.numberRange(candidate.green, 0, 1)\n                && Is.numberRange(candidate.blue, 0, 1)\n                && Is.numberRange(candidate.alpha, 0, 1);\n        }\n        Color.is = is;\n    })(Color || (exports.Color = Color = {}));\n    /**\n     * The ColorInformation namespace provides helper functions to work with\n     * {@link ColorInformation} literals.\n     */\n    var ColorInformation;\n    (function (ColorInformation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(range, color) {\n            return {\n                range: range,\n                color: color,\n            };\n        }\n        ColorInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n        }\n        ColorInformation.is = is;\n    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link ColorPresentation} literals.\n     */\n    var ColorPresentation;\n    (function (ColorPresentation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(label, textEdit, additionalTextEdits) {\n            return {\n                label: label,\n                textEdit: textEdit,\n                additionalTextEdits: additionalTextEdits,\n            };\n        }\n        ColorPresentation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label)\n                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n        }\n        ColorPresentation.is = is;\n    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));\n    /**\n     * A set of predefined range kinds.\n     */\n    var FoldingRangeKind;\n    (function (FoldingRangeKind) {\n        /**\n         * Folding range for a comment\n         */\n        FoldingRangeKind.Comment = 'comment';\n        /**\n         * Folding range for an import or include\n         */\n        FoldingRangeKind.Imports = 'imports';\n        /**\n         * Folding range for a region (e.g. `#region`)\n         */\n        FoldingRangeKind.Region = 'region';\n    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));\n    /**\n     * The folding range namespace provides helper functions to work with\n     * {@link FoldingRange} literals.\n     */\n    var FoldingRange;\n    (function (FoldingRange) {\n        /**\n         * Creates a new FoldingRange literal.\n         */\n        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n            var result = {\n                startLine: startLine,\n                endLine: endLine\n            };\n            if (Is.defined(startCharacter)) {\n                result.startCharacter = startCharacter;\n            }\n            if (Is.defined(endCharacter)) {\n                result.endCharacter = endCharacter;\n            }\n            if (Is.defined(kind)) {\n                result.kind = kind;\n            }\n            if (Is.defined(collapsedText)) {\n                result.collapsedText = collapsedText;\n            }\n            return result;\n        }\n        FoldingRange.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n        }\n        FoldingRange.is = is;\n    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));\n    /**\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\n     * {@link DiagnosticRelatedInformation} literals.\n     */\n    var DiagnosticRelatedInformation;\n    (function (DiagnosticRelatedInformation) {\n        /**\n         * Creates a new DiagnosticRelatedInformation literal.\n         */\n        function create(location, message) {\n            return {\n                location: location,\n                message: message\n            };\n        }\n        DiagnosticRelatedInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n        }\n        DiagnosticRelatedInformation.is = is;\n    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\n    /**\n     * The diagnostic's severity.\n     */\n    var DiagnosticSeverity;\n    (function (DiagnosticSeverity) {\n        /**\n         * Reports an error.\n         */\n        DiagnosticSeverity.Error = 1;\n        /**\n         * Reports a warning.\n         */\n        DiagnosticSeverity.Warning = 2;\n        /**\n         * Reports an information.\n         */\n        DiagnosticSeverity.Information = 3;\n        /**\n         * Reports a hint.\n         */\n        DiagnosticSeverity.Hint = 4;\n    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));\n    /**\n     * The diagnostic tags.\n     *\n     * @since 3.15.0\n     */\n    var DiagnosticTag;\n    (function (DiagnosticTag) {\n        /**\n         * Unused or unnecessary code.\n         *\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\n         * an error squiggle.\n         */\n        DiagnosticTag.Unnecessary = 1;\n        /**\n         * Deprecated or obsolete code.\n         *\n         * Clients are allowed to rendered diagnostics with this tag strike through.\n         */\n        DiagnosticTag.Deprecated = 2;\n    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));\n    /**\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n     *\n     * @since 3.16.0\n     */\n    var CodeDescription;\n    (function (CodeDescription) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\n        }\n        CodeDescription.is = is;\n    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));\n    /**\n     * The Diagnostic namespace provides helper functions to work with\n     * {@link Diagnostic} literals.\n     */\n    var Diagnostic;\n    (function (Diagnostic) {\n        /**\n         * Creates a new Diagnostic literal.\n         */\n        function create(range, message, severity, code, source, relatedInformation) {\n            var result = { range: range, message: message };\n            if (Is.defined(severity)) {\n                result.severity = severity;\n            }\n            if (Is.defined(code)) {\n                result.code = code;\n            }\n            if (Is.defined(source)) {\n                result.source = source;\n            }\n            if (Is.defined(relatedInformation)) {\n                result.relatedInformation = relatedInformation;\n            }\n            return result;\n        }\n        Diagnostic.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n         */\n        function is(value) {\n            var _a;\n            var candidate = value;\n            return Is.defined(candidate)\n                && Range.is(candidate.range)\n                && Is.string(candidate.message)\n                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n                && (Is.string(candidate.source) || Is.undefined(candidate.source))\n                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n        }\n        Diagnostic.is = is;\n    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));\n    /**\n     * The Command namespace provides helper functions to work with\n     * {@link Command} literals.\n     */\n    var Command;\n    (function (Command) {\n        /**\n         * Creates a new Command literal.\n         */\n        function create(title, command) {\n            var args = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                args[_i - 2] = arguments[_i];\n            }\n            var result = { title: title, command: command };\n            if (Is.defined(args) && args.length > 0) {\n                result.arguments = args;\n            }\n            return result;\n        }\n        Command.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Command} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n        }\n        Command.is = is;\n    })(Command || (exports.Command = Command = {}));\n    /**\n     * The TextEdit namespace provides helper function to create replace,\n     * insert and delete edits more easily.\n     */\n    var TextEdit;\n    (function (TextEdit) {\n        /**\n         * Creates a replace text edit.\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         */\n        function replace(range, newText) {\n            return { range: range, newText: newText };\n        }\n        TextEdit.replace = replace;\n        /**\n         * Creates an insert text edit.\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         */\n        function insert(position, newText) {\n            return { range: { start: position, end: position }, newText: newText };\n        }\n        TextEdit.insert = insert;\n        /**\n         * Creates a delete text edit.\n         * @param range The range of text to be deleted.\n         */\n        function del(range) {\n            return { range: range, newText: '' };\n        }\n        TextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && Is.string(candidate.newText)\n                && Range.is(candidate.range);\n        }\n        TextEdit.is = is;\n    })(TextEdit || (exports.TextEdit = TextEdit = {}));\n    var ChangeAnnotation;\n    (function (ChangeAnnotation) {\n        function create(label, needsConfirmation, description) {\n            var result = { label: label };\n            if (needsConfirmation !== undefined) {\n                result.needsConfirmation = needsConfirmation;\n            }\n            if (description !== undefined) {\n                result.description = description;\n            }\n            return result;\n        }\n        ChangeAnnotation.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        ChangeAnnotation.is = is;\n    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));\n    var ChangeAnnotationIdentifier;\n    (function (ChangeAnnotationIdentifier) {\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate);\n        }\n        ChangeAnnotationIdentifier.is = is;\n    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\n    var AnnotatedTextEdit;\n    (function (AnnotatedTextEdit) {\n        /**\n         * Creates an annotated replace text edit.\n         *\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         * @param annotation The annotation.\n         */\n        function replace(range, newText, annotation) {\n            return { range: range, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.replace = replace;\n        /**\n         * Creates an annotated insert text edit.\n         *\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         * @param annotation The annotation.\n         */\n        function insert(position, newText, annotation) {\n            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.insert = insert;\n        /**\n         * Creates an annotated delete text edit.\n         *\n         * @param range The range of text to be deleted.\n         * @param annotation The annotation.\n         */\n        function del(range, annotation) {\n            return { range: range, newText: '', annotationId: annotation };\n        }\n        AnnotatedTextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        AnnotatedTextEdit.is = is;\n    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));\n    /**\n     * The TextDocumentEdit namespace provides helper function to create\n     * an edit that manipulates a text document.\n     */\n    var TextDocumentEdit;\n    (function (TextDocumentEdit) {\n        /**\n         * Creates a new `TextDocumentEdit`\n         */\n        function create(textDocument, edits) {\n            return { textDocument: textDocument, edits: edits };\n        }\n        TextDocumentEdit.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate)\n                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n                && Array.isArray(candidate.edits);\n        }\n        TextDocumentEdit.is = is;\n    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));\n    var CreateFile;\n    (function (CreateFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'create',\n                uri: uri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        CreateFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        CreateFile.is = is;\n    })(CreateFile || (exports.CreateFile = CreateFile = {}));\n    var RenameFile;\n    (function (RenameFile) {\n        function create(oldUri, newUri, options, annotation) {\n            var result = {\n                kind: 'rename',\n                oldUri: oldUri,\n                newUri: newUri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        RenameFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        RenameFile.is = is;\n    })(RenameFile || (exports.RenameFile = RenameFile = {}));\n    var DeleteFile;\n    (function (DeleteFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'delete',\n                uri: uri\n            };\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        DeleteFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        DeleteFile.is = is;\n    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));\n    var WorkspaceEdit;\n    (function (WorkspaceEdit) {\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                    if (Is.string(change.kind)) {\n                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                    }\n                    else {\n                        return TextDocumentEdit.is(change);\n                    }\n                }));\n        }\n        WorkspaceEdit.is = is;\n    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));\n    var TextEditChangeImpl = /** @class */ (function () {\n        function TextEditChangeImpl(edits, changeAnnotations) {\n            this.edits = edits;\n            this.changeAnnotations = changeAnnotations;\n        }\n        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.insert(position, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.insert(position, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.replace(range, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.replace(range, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.delete = function (range, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.del(range);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.del(range, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.del(range, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.add = function (edit) {\n            this.edits.push(edit);\n        };\n        TextEditChangeImpl.prototype.all = function () {\n            return this.edits;\n        };\n        TextEditChangeImpl.prototype.clear = function () {\n            this.edits.splice(0, this.edits.length);\n        };\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n            if (value === undefined) {\n                throw new Error(\"Text edit change is not configured to manage change annotations.\");\n            }\n        };\n        return TextEditChangeImpl;\n    }());\n    /**\n     * A helper class\n     */\n    var ChangeAnnotations = /** @class */ (function () {\n        function ChangeAnnotations(annotations) {\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\n            this._counter = 0;\n            this._size = 0;\n        }\n        ChangeAnnotations.prototype.all = function () {\n            return this._annotations;\n        };\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n            get: function () {\n                return this._size;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n            var id;\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n                id = idOrAnnotation;\n            }\n            else {\n                id = this.nextId();\n                annotation = idOrAnnotation;\n            }\n            if (this._annotations[id] !== undefined) {\n                throw new Error(\"Id \".concat(id, \" is already in use.\"));\n            }\n            if (annotation === undefined) {\n                throw new Error(\"No annotation provided for id \".concat(id));\n            }\n            this._annotations[id] = annotation;\n            this._size++;\n            return id;\n        };\n        ChangeAnnotations.prototype.nextId = function () {\n            this._counter++;\n            return this._counter.toString();\n        };\n        return ChangeAnnotations;\n    }());\n    /**\n     * A workspace change helps constructing changes to a workspace.\n     */\n    var WorkspaceChange = /** @class */ (function () {\n        function WorkspaceChange(workspaceEdit) {\n            var _this = this;\n            this._textEditChanges = Object.create(null);\n            if (workspaceEdit !== undefined) {\n                this._workspaceEdit = workspaceEdit;\n                if (workspaceEdit.documentChanges) {\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    workspaceEdit.documentChanges.forEach(function (change) {\n                        if (TextDocumentEdit.is(change)) {\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                        }\n                    });\n                }\n                else if (workspaceEdit.changes) {\n                    Object.keys(workspaceEdit.changes).forEach(function (key) {\n                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                        _this._textEditChanges[key] = textEditChange;\n                    });\n                }\n            }\n            else {\n                this._workspaceEdit = {};\n            }\n        }\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n            /**\n             * Returns the underlying {@link WorkspaceEdit} literal\n             * use to be returned from a workspace edit operation like rename.\n             */\n            get: function () {\n                this.initDocumentChanges();\n                if (this._changeAnnotations !== undefined) {\n                    if (this._changeAnnotations.size === 0) {\n                        this._workspaceEdit.changeAnnotations = undefined;\n                    }\n                    else {\n                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    }\n                }\n                return this._workspaceEdit;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WorkspaceChange.prototype.getTextEditChange = function (key) {\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n                this.initDocumentChanges();\n                if (this._workspaceEdit.documentChanges === undefined) {\n                    throw new Error('Workspace edit is not configured for document changes.');\n                }\n                var textDocument = { uri: key.uri, version: key.version };\n                var result = this._textEditChanges[textDocument.uri];\n                if (!result) {\n                    var edits = [];\n                    var textDocumentEdit = {\n                        textDocument: textDocument,\n                        edits: edits\n                    };\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                    this._textEditChanges[textDocument.uri] = result;\n                }\n                return result;\n            }\n            else {\n                this.initChanges();\n                if (this._workspaceEdit.changes === undefined) {\n                    throw new Error('Workspace edit is not configured for normal text edit changes.');\n                }\n                var result = this._textEditChanges[key];\n                if (!result) {\n                    var edits = [];\n                    this._workspaceEdit.changes[key] = edits;\n                    result = new TextEditChangeImpl(edits);\n                    this._textEditChanges[key] = result;\n                }\n                return result;\n            }\n        };\n        WorkspaceChange.prototype.initDocumentChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._changeAnnotations = new ChangeAnnotations();\n                this._workspaceEdit.documentChanges = [];\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        };\n        WorkspaceChange.prototype.initChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._workspaceEdit.changes = Object.create(null);\n            }\n        };\n        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = CreateFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = CreateFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = RenameFile.create(oldUri, newUri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = RenameFile.create(oldUri, newUri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = DeleteFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = DeleteFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        return WorkspaceChange;\n    }());\n    exports.WorkspaceChange = WorkspaceChange;\n    /**\n     * The TextDocumentIdentifier namespace provides helper functions to work with\n     * {@link TextDocumentIdentifier} literals.\n     */\n    var TextDocumentIdentifier;\n    (function (TextDocumentIdentifier) {\n        /**\n         * Creates a new TextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         */\n        function create(uri) {\n            return { uri: uri };\n        }\n        TextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri);\n        }\n        TextDocumentIdentifier.is = is;\n    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));\n    /**\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link VersionedTextDocumentIdentifier} literals.\n     */\n    var VersionedTextDocumentIdentifier;\n    (function (VersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new VersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        VersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n        }\n        VersionedTextDocumentIdentifier.is = is;\n    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\n    /**\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\n     */\n    var OptionalVersionedTextDocumentIdentifier;\n    (function (OptionalVersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        OptionalVersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n        }\n        OptionalVersionedTextDocumentIdentifier.is = is;\n    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\n    /**\n     * The TextDocumentItem namespace provides helper functions to work with\n     * {@link TextDocumentItem} literals.\n     */\n    var TextDocumentItem;\n    (function (TextDocumentItem) {\n        /**\n         * Creates a new TextDocumentItem literal.\n         * @param uri The document's uri.\n         * @param languageId The document's language identifier.\n         * @param version The document's version number.\n         * @param text The document's text.\n         */\n        function create(uri, languageId, version, text) {\n            return { uri: uri, languageId: languageId, version: version, text: text };\n        }\n        TextDocumentItem.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n        }\n        TextDocumentItem.is = is;\n    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));\n    /**\n     * Describes the content type that a client supports in various\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n     *\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\n     * are reserved for internal usage.\n     */\n    var MarkupKind;\n    (function (MarkupKind) {\n        /**\n         * Plain text is supported as a content format\n         */\n        MarkupKind.PlainText = 'plaintext';\n        /**\n         * Markdown is supported as a content format\n         */\n        MarkupKind.Markdown = 'markdown';\n        /**\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n        }\n        MarkupKind.is = is;\n    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));\n    var MarkupContent;\n    (function (MarkupContent) {\n        /**\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n        }\n        MarkupContent.is = is;\n    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));\n    /**\n     * The kind of a completion entry.\n     */\n    var CompletionItemKind;\n    (function (CompletionItemKind) {\n        CompletionItemKind.Text = 1;\n        CompletionItemKind.Method = 2;\n        CompletionItemKind.Function = 3;\n        CompletionItemKind.Constructor = 4;\n        CompletionItemKind.Field = 5;\n        CompletionItemKind.Variable = 6;\n        CompletionItemKind.Class = 7;\n        CompletionItemKind.Interface = 8;\n        CompletionItemKind.Module = 9;\n        CompletionItemKind.Property = 10;\n        CompletionItemKind.Unit = 11;\n        CompletionItemKind.Value = 12;\n        CompletionItemKind.Enum = 13;\n        CompletionItemKind.Keyword = 14;\n        CompletionItemKind.Snippet = 15;\n        CompletionItemKind.Color = 16;\n        CompletionItemKind.File = 17;\n        CompletionItemKind.Reference = 18;\n        CompletionItemKind.Folder = 19;\n        CompletionItemKind.EnumMember = 20;\n        CompletionItemKind.Constant = 21;\n        CompletionItemKind.Struct = 22;\n        CompletionItemKind.Event = 23;\n        CompletionItemKind.Operator = 24;\n        CompletionItemKind.TypeParameter = 25;\n    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));\n    /**\n     * Defines whether the insert text in a completion item should be interpreted as\n     * plain text or a snippet.\n     */\n    var InsertTextFormat;\n    (function (InsertTextFormat) {\n        /**\n         * The primary text to be inserted is treated as a plain string.\n         */\n        InsertTextFormat.PlainText = 1;\n        /**\n         * The primary text to be inserted is treated as a snippet.\n         *\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n         * the end of the snippet. Placeholders with equal identifiers are linked,\n         * that is typing in one will update others too.\n         *\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n         */\n        InsertTextFormat.Snippet = 2;\n    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));\n    /**\n     * Completion item tags are extra annotations that tweak the rendering of a completion\n     * item.\n     *\n     * @since 3.15.0\n     */\n    var CompletionItemTag;\n    (function (CompletionItemTag) {\n        /**\n         * Render a completion as obsolete, usually using a strike-out.\n         */\n        CompletionItemTag.Deprecated = 1;\n    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));\n    /**\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n     *\n     * @since 3.16.0\n     */\n    var InsertReplaceEdit;\n    (function (InsertReplaceEdit) {\n        /**\n         * Creates a new insert / replace edit\n         */\n        function create(newText, insert, replace) {\n            return { newText: newText, insert: insert, replace: replace };\n        }\n        InsertReplaceEdit.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n        }\n        InsertReplaceEdit.is = is;\n    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));\n    /**\n     * How whitespace and indentation is handled during completion\n     * item insertion.\n     *\n     * @since 3.16.0\n     */\n    var InsertTextMode;\n    (function (InsertTextMode) {\n        /**\n         * The insertion or replace strings is taken as it is. If the\n         * value is multi line the lines below the cursor will be\n         * inserted using the indentation defined in the string value.\n         * The client will not apply any kind of adjustments to the\n         * string.\n         */\n        InsertTextMode.asIs = 1;\n        /**\n         * The editor adjusts leading whitespace of new lines so that\n         * they match the indentation up to the cursor of the line for\n         * which the item is accepted.\n         *\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n         * multi line completion item is indented using 2 tabs and all\n         * following lines inserted will be indented using 2 tabs as well.\n         */\n        InsertTextMode.adjustIndentation = 2;\n    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));\n    var CompletionItemLabelDetails;\n    (function (CompletionItemLabelDetails) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        CompletionItemLabelDetails.is = is;\n    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\n    /**\n     * The CompletionItem namespace provides functions to deal with\n     * completion items.\n     */\n    var CompletionItem;\n    (function (CompletionItem) {\n        /**\n         * Create a completion item and seed it with a label.\n         * @param label The completion item's label\n         */\n        function create(label) {\n            return { label: label };\n        }\n        CompletionItem.create = create;\n    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));\n    /**\n     * The CompletionList namespace provides functions to deal with\n     * completion lists.\n     */\n    var CompletionList;\n    (function (CompletionList) {\n        /**\n         * Creates a new completion list.\n         *\n         * @param items The completion items.\n         * @param isIncomplete The list is not complete.\n         */\n        function create(items, isIncomplete) {\n            return { items: items ? items : [], isIncomplete: !!isIncomplete };\n        }\n        CompletionList.create = create;\n    })(CompletionList || (exports.CompletionList = CompletionList = {}));\n    var MarkedString;\n    (function (MarkedString) {\n        /**\n         * Creates a marked string from plain text.\n         *\n         * @param plainText The plain text.\n         */\n        function fromPlainText(plainText) {\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n        }\n        MarkedString.fromPlainText = fromPlainText;\n        /**\n         * Checks whether the given value conforms to the {@link MarkedString} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n        }\n        MarkedString.is = is;\n    })(MarkedString || (exports.MarkedString = MarkedString = {}));\n    var Hover;\n    (function (Hover) {\n        /**\n         * Checks whether the given value conforms to the {@link Hover} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n                MarkedString.is(candidate.contents) ||\n                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n        }\n        Hover.is = is;\n    })(Hover || (exports.Hover = Hover = {}));\n    /**\n     * The ParameterInformation namespace provides helper functions to work with\n     * {@link ParameterInformation} literals.\n     */\n    var ParameterInformation;\n    (function (ParameterInformation) {\n        /**\n         * Creates a new parameter information literal.\n         *\n         * @param label A label string.\n         * @param documentation A doc string.\n         */\n        function create(label, documentation) {\n            return documentation ? { label: label, documentation: documentation } : { label: label };\n        }\n        ParameterInformation.create = create;\n    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));\n    /**\n     * The SignatureInformation namespace provides helper functions to work with\n     * {@link SignatureInformation} literals.\n     */\n    var SignatureInformation;\n    (function (SignatureInformation) {\n        function create(label, documentation) {\n            var parameters = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                parameters[_i - 2] = arguments[_i];\n            }\n            var result = { label: label };\n            if (Is.defined(documentation)) {\n                result.documentation = documentation;\n            }\n            if (Is.defined(parameters)) {\n                result.parameters = parameters;\n            }\n            else {\n                result.parameters = [];\n            }\n            return result;\n        }\n        SignatureInformation.create = create;\n    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));\n    /**\n     * A document highlight kind.\n     */\n    var DocumentHighlightKind;\n    (function (DocumentHighlightKind) {\n        /**\n         * A textual occurrence.\n         */\n        DocumentHighlightKind.Text = 1;\n        /**\n         * Read-access of a symbol, like reading a variable.\n         */\n        DocumentHighlightKind.Read = 2;\n        /**\n         * Write-access of a symbol, like writing to a variable.\n         */\n        DocumentHighlightKind.Write = 3;\n    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));\n    /**\n     * DocumentHighlight namespace to provide helper functions to work with\n     * {@link DocumentHighlight} literals.\n     */\n    var DocumentHighlight;\n    (function (DocumentHighlight) {\n        /**\n         * Create a DocumentHighlight object.\n         * @param range The range the highlight applies to.\n         * @param kind The highlight kind\n         */\n        function create(range, kind) {\n            var result = { range: range };\n            if (Is.number(kind)) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        DocumentHighlight.create = create;\n    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));\n    /**\n     * A symbol kind.\n     */\n    var SymbolKind;\n    (function (SymbolKind) {\n        SymbolKind.File = 1;\n        SymbolKind.Module = 2;\n        SymbolKind.Namespace = 3;\n        SymbolKind.Package = 4;\n        SymbolKind.Class = 5;\n        SymbolKind.Method = 6;\n        SymbolKind.Property = 7;\n        SymbolKind.Field = 8;\n        SymbolKind.Constructor = 9;\n        SymbolKind.Enum = 10;\n        SymbolKind.Interface = 11;\n        SymbolKind.Function = 12;\n        SymbolKind.Variable = 13;\n        SymbolKind.Constant = 14;\n        SymbolKind.String = 15;\n        SymbolKind.Number = 16;\n        SymbolKind.Boolean = 17;\n        SymbolKind.Array = 18;\n        SymbolKind.Object = 19;\n        SymbolKind.Key = 20;\n        SymbolKind.Null = 21;\n        SymbolKind.EnumMember = 22;\n        SymbolKind.Struct = 23;\n        SymbolKind.Event = 24;\n        SymbolKind.Operator = 25;\n        SymbolKind.TypeParameter = 26;\n    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));\n    /**\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\n     *\n     * @since 3.16\n     */\n    var SymbolTag;\n    (function (SymbolTag) {\n        /**\n         * Render a symbol as obsolete, usually using a strike-out.\n         */\n        SymbolTag.Deprecated = 1;\n    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));\n    var SymbolInformation;\n    (function (SymbolInformation) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the location of the symbol.\n         * @param uri The resource of the location of symbol.\n         * @param containerName The name of the symbol containing the symbol.\n         */\n        function create(name, kind, range, uri, containerName) {\n            var result = {\n                name: name,\n                kind: kind,\n                location: { uri: uri, range: range }\n            };\n            if (containerName) {\n                result.containerName = containerName;\n            }\n            return result;\n        }\n        SymbolInformation.create = create;\n    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));\n    var WorkspaceSymbol;\n    (function (WorkspaceSymbol) {\n        /**\n         * Create a new workspace symbol.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param uri The resource of the location of the symbol.\n         * @param range An options range of the location.\n         * @returns A WorkspaceSymbol.\n         */\n        function create(name, kind, uri, range) {\n            return range !== undefined\n                ? { name: name, kind: kind, location: { uri: uri, range: range } }\n                : { name: name, kind: kind, location: { uri: uri } };\n        }\n        WorkspaceSymbol.create = create;\n    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));\n    var DocumentSymbol;\n    (function (DocumentSymbol) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param detail The detail of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the symbol.\n         * @param selectionRange The selectionRange of the symbol.\n         * @param children Children of the symbol.\n         */\n        function create(name, detail, kind, range, selectionRange, children) {\n            var result = {\n                name: name,\n                detail: detail,\n                kind: kind,\n                range: range,\n                selectionRange: selectionRange\n            };\n            if (children !== undefined) {\n                result.children = children;\n            }\n            return result;\n        }\n        DocumentSymbol.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                Is.string(candidate.name) && Is.number(candidate.kind) &&\n                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n                (candidate.detail === undefined || Is.string(candidate.detail)) &&\n                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n                (candidate.children === undefined || Array.isArray(candidate.children)) &&\n                (candidate.tags === undefined || Array.isArray(candidate.tags));\n        }\n        DocumentSymbol.is = is;\n    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));\n    /**\n     * A set of predefined code action kinds\n     */\n    var CodeActionKind;\n    (function (CodeActionKind) {\n        /**\n         * Empty kind.\n         */\n        CodeActionKind.Empty = '';\n        /**\n         * Base kind for quickfix actions: 'quickfix'\n         */\n        CodeActionKind.QuickFix = 'quickfix';\n        /**\n         * Base kind for refactoring actions: 'refactor'\n         */\n        CodeActionKind.Refactor = 'refactor';\n        /**\n         * Base kind for refactoring extraction actions: 'refactor.extract'\n         *\n         * Example extract actions:\n         *\n         * - Extract method\n         * - Extract function\n         * - Extract variable\n         * - Extract interface from class\n         * - ...\n         */\n        CodeActionKind.RefactorExtract = 'refactor.extract';\n        /**\n         * Base kind for refactoring inline actions: 'refactor.inline'\n         *\n         * Example inline actions:\n         *\n         * - Inline function\n         * - Inline variable\n         * - Inline constant\n         * - ...\n         */\n        CodeActionKind.RefactorInline = 'refactor.inline';\n        /**\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n         *\n         * Example rewrite actions:\n         *\n         * - Convert JavaScript function to class\n         * - Add or remove parameter\n         * - Encapsulate field\n         * - Make method static\n         * - Move method to base class\n         * - ...\n         */\n        CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n        /**\n         * Base kind for source actions: `source`\n         *\n         * Source code actions apply to the entire file.\n         */\n        CodeActionKind.Source = 'source';\n        /**\n         * Base kind for an organize imports source action: `source.organizeImports`\n         */\n        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n        /**\n         * Base kind for auto-fix source actions: `source.fixAll`.\n         *\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n         *\n         * @since 3.15.0\n         */\n        CodeActionKind.SourceFixAll = 'source.fixAll';\n    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));\n    /**\n     * The reason why code actions were requested.\n     *\n     * @since 3.17.0\n     */\n    var CodeActionTriggerKind;\n    (function (CodeActionTriggerKind) {\n        /**\n         * Code actions were explicitly requested by the user or by an extension.\n         */\n        CodeActionTriggerKind.Invoked = 1;\n        /**\n         * Code actions were requested automatically.\n         *\n         * This typically happens when current selection in a file changes, but can\n         * also be triggered when file content changes.\n         */\n        CodeActionTriggerKind.Automatic = 2;\n    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));\n    /**\n     * The CodeActionContext namespace provides helper functions to work with\n     * {@link CodeActionContext} literals.\n     */\n    var CodeActionContext;\n    (function (CodeActionContext) {\n        /**\n         * Creates a new CodeActionContext literal.\n         */\n        function create(diagnostics, only, triggerKind) {\n            var result = { diagnostics: diagnostics };\n            if (only !== undefined && only !== null) {\n                result.only = only;\n            }\n            if (triggerKind !== undefined && triggerKind !== null) {\n                result.triggerKind = triggerKind;\n            }\n            return result;\n        }\n        CodeActionContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n        }\n        CodeActionContext.is = is;\n    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));\n    var CodeAction;\n    (function (CodeAction) {\n        function create(title, kindOrCommandOrEdit, kind) {\n            var result = { title: title };\n            var checkKind = true;\n            if (typeof kindOrCommandOrEdit === 'string') {\n                checkKind = false;\n                result.kind = kindOrCommandOrEdit;\n            }\n            else if (Command.is(kindOrCommandOrEdit)) {\n                result.command = kindOrCommandOrEdit;\n            }\n            else {\n                result.edit = kindOrCommandOrEdit;\n            }\n            if (checkKind && kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        CodeAction.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.title) &&\n                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n                (candidate.kind === undefined || Is.string(candidate.kind)) &&\n                (candidate.edit !== undefined || candidate.command !== undefined) &&\n                (candidate.command === undefined || Command.is(candidate.command)) &&\n                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n        }\n        CodeAction.is = is;\n    })(CodeAction || (exports.CodeAction = CodeAction = {}));\n    /**\n     * The CodeLens namespace provides helper functions to work with\n     * {@link CodeLens} literals.\n     */\n    var CodeLens;\n    (function (CodeLens) {\n        /**\n         * Creates a new CodeLens literal.\n         */\n        function create(range, data) {\n            var result = { range: range };\n            if (Is.defined(data)) {\n                result.data = data;\n            }\n            return result;\n        }\n        CodeLens.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n        }\n        CodeLens.is = is;\n    })(CodeLens || (exports.CodeLens = CodeLens = {}));\n    /**\n     * The FormattingOptions namespace provides helper functions to work with\n     * {@link FormattingOptions} literals.\n     */\n    var FormattingOptions;\n    (function (FormattingOptions) {\n        /**\n         * Creates a new FormattingOptions literal.\n         */\n        function create(tabSize, insertSpaces) {\n            return { tabSize: tabSize, insertSpaces: insertSpaces };\n        }\n        FormattingOptions.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n        }\n        FormattingOptions.is = is;\n    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));\n    /**\n     * The DocumentLink namespace provides helper functions to work with\n     * {@link DocumentLink} literals.\n     */\n    var DocumentLink;\n    (function (DocumentLink) {\n        /**\n         * Creates a new DocumentLink literal.\n         */\n        function create(range, target, data) {\n            return { range: range, target: target, data: data };\n        }\n        DocumentLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n        }\n        DocumentLink.is = is;\n    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));\n    /**\n     * The SelectionRange namespace provides helper function to work with\n     * SelectionRange literals.\n     */\n    var SelectionRange;\n    (function (SelectionRange) {\n        /**\n         * Creates a new SelectionRange\n         * @param range the range.\n         * @param parent an optional parent.\n         */\n        function create(range, parent) {\n            return { range: range, parent: parent };\n        }\n        SelectionRange.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n        }\n        SelectionRange.is = is;\n    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));\n    /**\n     * A set of predefined token types. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenTypes;\n    (function (SemanticTokenTypes) {\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\n        /**\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\n         * a specific type like class or enum.\n         */\n        SemanticTokenTypes[\"type\"] = \"type\";\n        SemanticTokenTypes[\"class\"] = \"class\";\n        SemanticTokenTypes[\"enum\"] = \"enum\";\n        SemanticTokenTypes[\"interface\"] = \"interface\";\n        SemanticTokenTypes[\"struct\"] = \"struct\";\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\n        SemanticTokenTypes[\"variable\"] = \"variable\";\n        SemanticTokenTypes[\"property\"] = \"property\";\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n        SemanticTokenTypes[\"event\"] = \"event\";\n        SemanticTokenTypes[\"function\"] = \"function\";\n        SemanticTokenTypes[\"method\"] = \"method\";\n        SemanticTokenTypes[\"macro\"] = \"macro\";\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\n        SemanticTokenTypes[\"comment\"] = \"comment\";\n        SemanticTokenTypes[\"string\"] = \"string\";\n        SemanticTokenTypes[\"number\"] = \"number\";\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\n        SemanticTokenTypes[\"operator\"] = \"operator\";\n        /**\n         * @since 3.17.0\n         */\n        SemanticTokenTypes[\"decorator\"] = \"decorator\";\n    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));\n    /**\n     * A set of predefined token modifiers. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenModifiers;\n    (function (SemanticTokenModifiers) {\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n        SemanticTokenModifiers[\"static\"] = \"static\";\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n        SemanticTokenModifiers[\"async\"] = \"async\";\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));\n    /**\n     * @since 3.16.0\n     */\n    var SemanticTokens;\n    (function (SemanticTokens) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n        }\n        SemanticTokens.is = is;\n    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));\n    /**\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueText;\n    (function (InlineValueText) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        InlineValueText.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n        }\n        InlineValueText.is = is;\n    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));\n    /**\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueVariableLookup;\n    (function (InlineValueVariableLookup) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, variableName, caseSensitiveLookup) {\n            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n        }\n        InlineValueVariableLookup.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n                && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n        }\n        InlineValueVariableLookup.is = is;\n    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));\n    /**\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueEvaluatableExpression;\n    (function (InlineValueEvaluatableExpression) {\n        /**\n         * Creates a new InlineValueEvaluatableExpression literal.\n         */\n        function create(range, expression) {\n            return { range: range, expression: expression };\n        }\n        InlineValueEvaluatableExpression.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n                && (Is.string(candidate.expression) || candidate.expression === undefined);\n        }\n        InlineValueEvaluatableExpression.is = is;\n    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\n    /**\n     * The InlineValueContext namespace provides helper functions to work with\n     * {@link InlineValueContext} literals.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueContext;\n    (function (InlineValueContext) {\n        /**\n         * Creates a new InlineValueContext literal.\n         */\n        function create(frameId, stoppedLocation) {\n            return { frameId: frameId, stoppedLocation: stoppedLocation };\n        }\n        InlineValueContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\n        }\n        InlineValueContext.is = is;\n    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));\n    /**\n     * Inlay hint kinds.\n     *\n     * @since 3.17.0\n     */\n    var InlayHintKind;\n    (function (InlayHintKind) {\n        /**\n         * An inlay hint that for a type annotation.\n         */\n        InlayHintKind.Type = 1;\n        /**\n         * An inlay hint that is for a parameter.\n         */\n        InlayHintKind.Parameter = 2;\n        function is(value) {\n            return value === 1 || value === 2;\n        }\n        InlayHintKind.is = is;\n    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));\n    var InlayHintLabelPart;\n    (function (InlayHintLabelPart) {\n        function create(value) {\n            return { value: value };\n        }\n        InlayHintLabelPart.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.location === undefined || Location.is(candidate.location))\n                && (candidate.command === undefined || Command.is(candidate.command));\n        }\n        InlayHintLabelPart.is = is;\n    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));\n    var InlayHint;\n    (function (InlayHint) {\n        function create(position, label, kind) {\n            var result = { position: position, label: label };\n            if (kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        InlayHint.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.position)\n                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n        }\n        InlayHint.is = is;\n    })(InlayHint || (exports.InlayHint = InlayHint = {}));\n    var StringValue;\n    (function (StringValue) {\n        function createSnippet(value) {\n            return { kind: 'snippet', value: value };\n        }\n        StringValue.createSnippet = createSnippet;\n    })(StringValue || (exports.StringValue = StringValue = {}));\n    var InlineCompletionItem;\n    (function (InlineCompletionItem) {\n        function create(insertText, filterText, range, command) {\n            return { insertText: insertText, filterText: filterText, range: range, command: command };\n        }\n        InlineCompletionItem.create = create;\n    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));\n    var InlineCompletionList;\n    (function (InlineCompletionList) {\n        function create(items) {\n            return { items: items };\n        }\n        InlineCompletionList.create = create;\n    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));\n    /**\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n     *\n     * @since 3.18.0\n     * @proposed\n     */\n    var InlineCompletionTriggerKind;\n    (function (InlineCompletionTriggerKind) {\n        /**\n         * Completion was triggered explicitly by a user gesture.\n         */\n        InlineCompletionTriggerKind.Invoked = 0;\n        /**\n         * Completion was triggered automatically while editing.\n         */\n        InlineCompletionTriggerKind.Automatic = 1;\n    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\n    var SelectedCompletionInfo;\n    (function (SelectedCompletionInfo) {\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        SelectedCompletionInfo.create = create;\n    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));\n    var InlineCompletionContext;\n    (function (InlineCompletionContext) {\n        function create(triggerKind, selectedCompletionInfo) {\n            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };\n        }\n        InlineCompletionContext.create = create;\n    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));\n    var WorkspaceFolder;\n    (function (WorkspaceFolder) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n        }\n        WorkspaceFolder.is = is;\n    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));\n    exports.EOL = ['\\n', '\\r\\n', '\\r'];\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var TextDocument;\n    (function (TextDocument) {\n        /**\n         * Creates a new ITextDocument literal from the given uri and content.\n         * @param uri The document's uri.\n         * @param languageId The document's language Id.\n         * @param version The document's version.\n         * @param content The document's content.\n         */\n        function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n        }\n        TextDocument.is = is;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits, function (a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) {\n                    return a.range.start.character - b.range.start.character;\n                }\n                return diff;\n            });\n            var lastModifiedOffset = text.length;\n            for (var i = sortedEdits.length - 1; i >= 0; i--) {\n                var e = sortedEdits[i];\n                var startOffset = document.offsetAt(e.range.start);\n                var endOffset = document.offsetAt(e.range.end);\n                if (endOffset <= lastModifiedOffset) {\n                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n                }\n                else {\n                    throw new Error('Overlapping edit');\n                }\n                lastModifiedOffset = startOffset;\n            }\n            return text;\n        }\n        TextDocument.applyEdits = applyEdits;\n        function mergeSort(data, compare) {\n            if (data.length <= 1) {\n                // sorted\n                return data;\n            }\n            var p = (data.length / 2) | 0;\n            var left = data.slice(0, p);\n            var right = data.slice(p);\n            mergeSort(left, compare);\n            mergeSort(right, compare);\n            var leftIdx = 0;\n            var rightIdx = 0;\n            var i = 0;\n            while (leftIdx < left.length && rightIdx < right.length) {\n                var ret = compare(left[leftIdx], right[rightIdx]);\n                if (ret <= 0) {\n                    // smaller_equal -> take left to preserve order\n                    data[i++] = left[leftIdx++];\n                }\n                else {\n                    // greater -> take right\n                    data[i++] = right[rightIdx++];\n                }\n            }\n            while (leftIdx < left.length) {\n                data[i++] = left[leftIdx++];\n            }\n            while (rightIdx < right.length) {\n                data[i++] = right[rightIdx++];\n            }\n            return data;\n        }\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var FullTextDocument = /** @class */ (function () {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function () {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function () {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function () {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function (range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function (event, version) {\n            this._content = event.text;\n            this._version = version;\n            this._lineOffsets = undefined;\n        };\n        FullTextDocument.prototype.getLineOffsets = function () {\n            if (this._lineOffsets === undefined) {\n                var lineOffsets = [];\n                var text = this._content;\n                var isLineStart = true;\n                for (var i = 0; i < text.length; i++) {\n                    if (isLineStart) {\n                        lineOffsets.push(i);\n                        isLineStart = false;\n                    }\n                    var ch = text.charAt(i);\n                    isLineStart = (ch === '\\r' || ch === '\\n');\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                        i++;\n                    }\n                }\n                if (isLineStart && text.length > 0) {\n                    lineOffsets.push(text.length);\n                }\n                this._lineOffsets = lineOffsets;\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function (offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) {\n                return Position.create(0, offset);\n            }\n            while (low < high) {\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            return Position.create(line, offset - lineOffsets[line]);\n        };\n        FullTextDocument.prototype.offsetAt = function (position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) {\n                return this._content.length;\n            }\n            else if (position.line < 0) {\n                return 0;\n            }\n            var lineOffset = lineOffsets[position.line];\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function () {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return FullTextDocument;\n    }());\n    var Is;\n    (function (Is) {\n        var toString = Object.prototype.toString;\n        function defined(value) {\n            return typeof value !== 'undefined';\n        }\n        Is.defined = defined;\n        function undefined(value) {\n            return typeof value === 'undefined';\n        }\n        Is.undefined = undefined;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        Is.boolean = boolean;\n        function string(value) {\n            return toString.call(value) === '[object String]';\n        }\n        Is.string = string;\n        function number(value) {\n            return toString.call(value) === '[object Number]';\n        }\n        Is.number = number;\n        function numberRange(value, min, max) {\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\n        }\n        Is.numberRange = numberRange;\n        function integer(value) {\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n        }\n        Is.integer = integer;\n        function uinteger(value) {\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n        }\n        Is.uinteger = uinteger;\n        function func(value) {\n            return toString.call(value) === '[object Function]';\n        }\n        Is.func = func;\n        function objectLiteral(value) {\n            // Strictly speaking class instances pass this check as well. Since the LSP\n            // doesn't use classes we ignore this for now. If we do we need to add something\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n            return value !== null && typeof value === 'object';\n        }\n        Is.objectLiteral = objectLiteral;\n        function typedArray(value, check) {\n            return Array.isArray(value) && value.every(check);\n        }\n        Is.typedArray = typedArray;\n    })(Is || (Is = {}));\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Line = void 0;\nclass Line {\n    constructor(document, range) {\n        this.document = document;\n        this.range = range;\n    }\n    getRange() {\n        return this.range;\n    }\n    getTextContent() {\n        return this.document.getText().substring(this.document.offsetAt(this.range.start), this.document.offsetAt(this.range.end));\n    }\n    isAfter(line) {\n        return this.range.start.line > line.range.start.line;\n    }\n    isBefore(line) {\n        return this.range.start.line < line;\n    }\n}\nexports.Line = Line;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    static isUTF8BOM(char) {\n        const uintArray = Uint8Array.from(Buffer.from(char, \"UTF-8\"));\n        return uintArray[0] === 0xEF && uintArray[1] == 0xBB && uintArray[2] == 0xBF;\n    }\n    static isWhitespace(char) {\n        return char === ' ' || char === '\\t' || Util.isNewline(char);\n    }\n    static isNewline(char) {\n        return char === '\\r' || char === '\\n';\n    }\n    static findLeadingNonWhitespace(content, escapeChar) {\n        whitespaceCheck: for (let i = 0; i < content.length; i++) {\n            switch (content.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    continue;\n                case escapeChar:\n                    escapeCheck: for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '\\r':\n                                // offset one more for \\r\\n\n                                i = j + 1;\n                                continue whitespaceCheck;\n                            case '\\n':\n                                i = j;\n                                continue whitespaceCheck;\n                            default:\n                                break escapeCheck;\n                        }\n                    }\n                    // found an escape character and then reached EOF\n                    return -1;\n                default:\n                    return i;\n            }\n        }\n        // only possible if the content is the empty string\n        return -1;\n    }\n    /**\n     * Determines if the given position is contained within the given range.\n     *\n     * @param position the position to check\n     * @param range the range to see if the position is inside of\n     */\n    static isInsideRange(position, range) {\n        if (range.start.line === range.end.line) {\n            return range.start.line === position.line\n                && range.start.character <= position.character\n                && position.character <= range.end.character;\n        }\n        else if (range.start.line === position.line) {\n            return range.start.character <= position.character;\n        }\n        else if (range.end.line === position.line) {\n            return position.character <= range.end.character;\n        }\n        return range.start.line < position.line && position.line < range.end.line;\n    }\n    static parseHeredocName(value) {\n        value = value.substring(2);\n        if (value.charAt(0) === '-') {\n            value = value.substring(1);\n        }\n        if (value.charAt(0) === '\"') {\n            if (value.charAt(value.length - 1) !== '\"') {\n                return null;\n            }\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === '\\'') {\n            if (value.charAt(value.length - 1) !== '\\'') {\n                return null;\n            }\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === \"<\") {\n            return null;\n        }\n        return value;\n    }\n}\nexports.Util = Util;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst vscode_languageserver_textdocument_1 = require(\"vscode-languageserver-textdocument\");\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst comment_1 = require(\"./comment\");\nconst parserDirective_1 = require(\"./parserDirective\");\nconst instruction_1 = require(\"./instruction\");\nconst add_1 = require(\"./instructions/add\");\nconst arg_1 = require(\"./instructions/arg\");\nconst cmd_1 = require(\"./instructions/cmd\");\nconst copy_1 = require(\"./instructions/copy\");\nconst env_1 = require(\"./instructions/env\");\nconst entrypoint_1 = require(\"./instructions/entrypoint\");\nconst from_1 = require(\"./instructions/from\");\nconst healthcheck_1 = require(\"./instructions/healthcheck\");\nconst label_1 = require(\"./instructions/label\");\nconst onbuild_1 = require(\"./instructions/onbuild\");\nconst run_1 = require(\"./instructions/run\");\nconst shell_1 = require(\"./instructions/shell\");\nconst stopsignal_1 = require(\"./instructions/stopsignal\");\nconst workdir_1 = require(\"./instructions/workdir\");\nconst user_1 = require(\"./instructions/user\");\nconst volume_1 = require(\"./instructions/volume\");\nconst dockerfile_1 = require(\"./dockerfile\");\nconst util_1 = require(\"./util\");\nconst main_1 = require(\"./main\");\nclass Parser {\n    constructor() {\n        this.escapeChar = null;\n    }\n    static createInstruction(document, dockerfile, escapeChar, lineRange, instruction, instructionRange) {\n        switch (instruction.toUpperCase()) {\n            case \"ADD\":\n                return new add_1.Add(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ARG\":\n                return new arg_1.Arg(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"CMD\":\n                return new cmd_1.Cmd(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"COPY\":\n                return new copy_1.Copy(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENTRYPOINT\":\n                return new entrypoint_1.Entrypoint(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENV\":\n                return new env_1.Env(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"FROM\":\n                return new from_1.From(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"HEALTHCHECK\":\n                return new healthcheck_1.Healthcheck(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"LABEL\":\n                return new label_1.Label(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ONBUILD\":\n                return new onbuild_1.Onbuild(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"RUN\":\n                return new run_1.Run(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"SHELL\":\n                return new shell_1.Shell(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"STOPSIGNAL\":\n                return new stopsignal_1.Stopsignal(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"WORKDIR\":\n                return new workdir_1.Workdir(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"USER\":\n                return new user_1.User(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"VOLUME\":\n                return new volume_1.Volume(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n        }\n        return new instruction_1.Instruction(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getParserDirectives(document, buffer) {\n        // reset the escape directive in between runs\n        const directives = [];\n        this.escapeChar = '';\n        const offset = util_1.Util.isUTF8BOM(buffer.substring(0, 1)) ? 1 : 0;\n        directiveCheck: for (let i = offset; i < buffer.length; i++) {\n            switch (buffer.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    break;\n                case '\\r':\n                case '\\n':\n                    // blank lines stop the parsing of directives immediately\n                    break directiveCheck;\n                case '#':\n                    let directiveStart = -1;\n                    let directiveEnd = -1;\n                    for (let j = i + 1; j < buffer.length; j++) {\n                        let char = buffer.charAt(j);\n                        switch (char) {\n                            case ' ':\n                            case '\\t':\n                                if (directiveStart !== -1 && directiveEnd === -1) {\n                                    directiveEnd = j;\n                                }\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                break directiveCheck;\n                            case '=':\n                                let valueStart = -1;\n                                let valueEnd = -1;\n                                if (directiveEnd === -1) {\n                                    directiveEnd = j;\n                                }\n                                // assume the line ends with the file\n                                let lineEnd = buffer.length;\n                                directiveValue: for (let k = j + 1; k < buffer.length; k++) {\n                                    char = buffer.charAt(k);\n                                    switch (char) {\n                                        case '\\r':\n                                        case '\\n':\n                                            if (valueStart !== -1 && valueEnd === -1) {\n                                                valueEnd = k;\n                                            }\n                                            // line break found, reset\n                                            lineEnd = k;\n                                            break directiveValue;\n                                        case '\\t':\n                                        case ' ':\n                                            if (valueStart !== -1 && valueEnd === -1) {\n                                                valueEnd = k;\n                                            }\n                                            continue;\n                                        default:\n                                            if (valueStart === -1) {\n                                                valueStart = k;\n                                            }\n                                            break;\n                                    }\n                                }\n                                if (directiveStart === -1) {\n                                    // no directive, it's a regular comment\n                                    break directiveCheck;\n                                }\n                                if (valueStart === -1) {\n                                    // no non-whitespace characters found, highlight all the characters then\n                                    valueStart = j + 1;\n                                    valueEnd = lineEnd;\n                                }\n                                else if (valueEnd === -1) {\n                                    // reached EOF\n                                    valueEnd = buffer.length;\n                                }\n                                const lineRange = vscode_languageserver_types_1.Range.create(document.positionAt(i), document.positionAt(lineEnd));\n                                const nameRange = vscode_languageserver_types_1.Range.create(document.positionAt(directiveStart), document.positionAt(directiveEnd));\n                                const valueRange = vscode_languageserver_types_1.Range.create(document.positionAt(valueStart), document.positionAt(valueEnd));\n                                directives.push(new parserDirective_1.ParserDirective(document, lineRange, nameRange, valueRange));\n                                directiveStart = -1;\n                                if (buffer.charAt(valueEnd) === '\\r') {\n                                    // skip over the \\r\n                                    i = valueEnd + 1;\n                                }\n                                else {\n                                    i = valueEnd;\n                                }\n                                continue directiveCheck;\n                            default:\n                                if (directiveStart === -1) {\n                                    directiveStart = j;\n                                }\n                                break;\n                        }\n                    }\n                    break;\n                default:\n                    break directiveCheck;\n            }\n        }\n        return directives;\n    }\n    parse(buffer) {\n        this.document = vscode_languageserver_textdocument_1.TextDocument.create(\"\", \"\", 0, buffer);\n        this.buffer = buffer;\n        let dockerfile = new dockerfile_1.Dockerfile(this.document);\n        let directives = this.getParserDirectives(this.document, this.buffer);\n        let offset = 0;\n        this.escapeChar = '\\\\';\n        if (directives.length > 0) {\n            dockerfile.setDirectives(directives);\n            this.escapeChar = dockerfile.getEscapeCharacter();\n            // start parsing after the directives\n            offset = this.document.offsetAt(vscode_languageserver_types_1.Position.create(directives.length, 0));\n        }\n        else if (util_1.Util.isUTF8BOM(buffer.substring(0, 1))) {\n            offset = 1;\n        }\n        for (let i = offset; i < this.buffer.length; i++) {\n            const char = this.buffer.charAt(i);\n            switch (char) {\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '#':\n                    i = this.processComment(dockerfile, i);\n                    break;\n                default:\n                    i = this.processInstruction(dockerfile, char, i);\n                    break;\n            }\n        }\n        dockerfile.organizeComments();\n        return dockerfile;\n    }\n    processInstruction(dockerfile, char, start) {\n        let instruction = char;\n        let instructionEnd = -1;\n        let escapedInstruction = false;\n        instructionCheck: for (let i = start + 1; i < this.buffer.length; i++) {\n            char = this.buffer.charAt(i);\n            switch (char) {\n                case this.escapeChar:\n                    escapedInstruction = true;\n                    char = this.buffer.charAt(i + 1);\n                    if (char === '\\r' || char === '\\n') {\n                        if (instructionEnd === -1) {\n                            instructionEnd = i;\n                        }\n                        i++;\n                    }\n                    else if (char === ' ' || char === '\\t') {\n                        for (let j = i + 2; j < this.buffer.length; j++) {\n                            switch (this.buffer.charAt(j)) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    i = j;\n                                    continue instructionCheck;\n                                default:\n                                    // found an argument, mark end of instruction\n                                    instructionEnd = i + 1;\n                                    instruction = instruction + this.escapeChar;\n                                    i = j - 2;\n                                    continue instructionCheck;\n                            }\n                        }\n                        // reached EOF\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        break instructionCheck;\n                    }\n                    else {\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        // reset and consider it as one contiguous word\n                        escapedInstruction = false;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escapedInstruction) {\n                        // on an escaped newline, need to search for non-whitespace\n                        escapeCheck: for (let j = i + 1; j < this.buffer.length; j++) {\n                            switch (this.buffer.charAt(j)) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    i = j;\n                                    continue instructionCheck;\n                                default:\n                                    break escapeCheck;\n                            }\n                        }\n                        escapedInstruction = false;\n                    }\n                    if (instructionEnd === -1) {\n                        instructionEnd = i;\n                    }\n                    i = this.processArguments(dockerfile, instruction, instructionEnd, start, i);\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, i));\n                    return i;\n                case '\\r':\n                case '\\n':\n                    if (escapedInstruction) {\n                        continue;\n                    }\n                    if (instructionEnd === -1) {\n                        instructionEnd = i;\n                    }\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, i, i));\n                    return i;\n                case '#':\n                    if (escapedInstruction) {\n                        continue;\n                    }\n                default:\n                    instructionEnd = i + 1;\n                    instruction = instruction + char;\n                    escapedInstruction = false;\n                    break;\n            }\n        }\n        // reached EOF\n        if (instructionEnd === -1) {\n            instructionEnd = this.buffer.length;\n        }\n        dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, this.buffer.length));\n        return this.buffer.length;\n    }\n    processHeredocs(instruction, offset) {\n        let keyword = instruction.getKeyword();\n        if (keyword === main_1.Keyword.ONBUILD) {\n            instruction = instruction.getTriggerInstruction();\n            if (instruction === null) {\n                return offset;\n            }\n            keyword = instruction.getKeyword();\n        }\n        if (keyword !== main_1.Keyword.ADD && keyword !== main_1.Keyword.COPY && keyword !== main_1.Keyword.RUN) {\n            return offset;\n        }\n        const heredocs = [];\n        for (const arg of instruction.getArguments()) {\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && value.length > 2) {\n                const name = util_1.Util.parseHeredocName(value);\n                if (name !== null) {\n                    heredocs.push(name);\n                }\n            }\n        }\n        if (heredocs.length > 0) {\n            for (const heredoc of heredocs) {\n                offset = this.parseHeredoc(heredoc, offset);\n            }\n        }\n        return offset;\n    }\n    processArguments(dockerfile, instruction, instructionEnd, start, offset) {\n        let escaped = false;\n        argumentsCheck: for (let i = offset + 1; i < this.buffer.length; i++) {\n            switch (this.buffer.charAt(i)) {\n                case '\\r':\n                case '\\n':\n                    if (escaped) {\n                        continue;\n                    }\n                    return this.processHeredocs(this.createInstruction(dockerfile, instruction, start, instructionEnd, i), i);\n                case this.escapeChar:\n                    const next = this.buffer.charAt(i + 1);\n                    if (next === '\\n' || next === '\\r') {\n                        escaped = true;\n                        i++;\n                    }\n                    else if (next === ' ' || next === '\\t') {\n                        for (let j = i + 2; j < this.buffer.length; j++) {\n                            switch (this.buffer.charAt(j)) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    escaped = true;\n                                default:\n                                    i = j;\n                                    continue argumentsCheck;\n                            }\n                        }\n                        // reached EOF\n                        return this.buffer.length;\n                    }\n                    continue;\n                case '#':\n                    if (escaped) {\n                        i = this.processComment(dockerfile, i);\n                        continue argumentsCheck;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    break;\n                default:\n                    if (escaped) {\n                        escaped = false;\n                    }\n                    break;\n            }\n        }\n        return this.buffer.length;\n    }\n    processComment(dockerfile, start) {\n        let end = this.buffer.length;\n        commentLoop: for (let i = start + 1; i < this.buffer.length; i++) {\n            switch (this.buffer.charAt(i)) {\n                case '\\r':\n                case '\\n':\n                    end = i;\n                    break commentLoop;\n            }\n        }\n        const range = vscode_languageserver_types_1.Range.create(this.document.positionAt(start), this.document.positionAt(end));\n        dockerfile.addComment(new comment_1.Comment(this.document, range));\n        return end;\n    }\n    parseHeredoc(heredocName, offset) {\n        let startWord = -1;\n        let lineStart = true;\n        for (let i = offset; i < this.buffer.length; i++) {\n            switch (this.buffer.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    lineStart = false;\n                    break;\n                case '\\r':\n                case '\\n':\n                    if (startWord !== -1 && heredocName === this.buffer.substring(startWord, i)) {\n                        return i;\n                    }\n                    startWord = -1;\n                    lineStart = true;\n                    break;\n                default:\n                    if (lineStart) {\n                        startWord = i;\n                        lineStart = false;\n                    }\n                    break;\n            }\n        }\n        return this.buffer.length;\n    }\n    createInstruction(dockerfile, instruction, start, instructionEnd, end) {\n        const startPosition = this.document.positionAt(start);\n        const instructionRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(instructionEnd));\n        const lineRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(end));\n        return Parser.createInstruction(this.document, dockerfile, this.escapeChar, lineRange, instruction, instructionRange);\n    }\n}\nexports.Parser = Parser;\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TextDocument = void 0;\n    var FullTextDocument = /** @class */ (function () {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function () {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function () {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function () {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function (range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function (changes, version) {\n            for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n                var change = changes_1[_i];\n                if (FullTextDocument.isIncremental(change)) {\n                    // makes sure start is before end\n                    var range = getWellformedRange(change.range);\n                    // update content\n                    var startOffset = this.offsetAt(range.start);\n                    var endOffset = this.offsetAt(range.end);\n                    this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                    // update the offsets\n                    var startLine = Math.max(range.start.line, 0);\n                    var endLine = Math.max(range.end.line, 0);\n                    var lineOffsets = this._lineOffsets;\n                    var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                    if (endLine - startLine === addedLineOffsets.length) {\n                        for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                        }\n                    }\n                    else {\n                        if (addedLineOffsets.length < 10000) {\n                            lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));\n                        }\n                        else { // avoid too many arguments for splice\n                            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                        }\n                    }\n                    var diff = change.text.length - (endOffset - startOffset);\n                    if (diff !== 0) {\n                        for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                            lineOffsets[i] = lineOffsets[i] + diff;\n                        }\n                    }\n                }\n                else if (FullTextDocument.isFull(change)) {\n                    this._content = change.text;\n                    this._lineOffsets = undefined;\n                }\n                else {\n                    throw new Error('Unknown change event received');\n                }\n            }\n            this._version = version;\n        };\n        FullTextDocument.prototype.getLineOffsets = function () {\n            if (this._lineOffsets === undefined) {\n                this._lineOffsets = computeLineOffsets(this._content, true);\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function (offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) {\n                return { line: 0, character: offset };\n            }\n            while (low < high) {\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n            return { line: line, character: offset - lineOffsets[line] };\n        };\n        FullTextDocument.prototype.offsetAt = function (position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) {\n                return this._content.length;\n            }\n            else if (position.line < 0) {\n                return 0;\n            }\n            var lineOffset = lineOffsets[position.line];\n            if (position.character <= 0) {\n                return lineOffset;\n            }\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n            var offset = Math.min(lineOffset + position.character, nextLineOffset);\n            return this.ensureBeforeEOL(offset, lineOffset);\n        };\n        FullTextDocument.prototype.ensureBeforeEOL = function (offset, lineOffset) {\n            while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n                offset--;\n            }\n            return offset;\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function () {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.isIncremental = function (event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null &&\n                typeof candidate.text === 'string' && candidate.range !== undefined &&\n                (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n        };\n        FullTextDocument.isFull = function (event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null &&\n                typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n        };\n        return FullTextDocument;\n    }());\n    var TextDocument;\n    (function (TextDocument) {\n        /**\n         * Creates a new text document.\n         *\n         * @param uri The document's uri.\n         * @param languageId  The document's language Id.\n         * @param version The document's initial version number.\n         * @param content The document's content.\n         */\n        function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Updates a TextDocument by modifying its content.\n         *\n         * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n         * @param changes the changes to apply to the document.\n         * @param version the changes version for the document.\n         * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n         *\n         */\n        function update(document, changes, version) {\n            if (document instanceof FullTextDocument) {\n                document.update(changes, version);\n                return document;\n            }\n            else {\n                throw new Error('TextDocument.update: document must be created by TextDocument.create');\n            }\n        }\n        TextDocument.update = update;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) {\n                    return a.range.start.character - b.range.start.character;\n                }\n                return diff;\n            });\n            var lastModifiedOffset = 0;\n            var spans = [];\n            for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n                var e = sortedEdits_1[_i];\n                var startOffset = document.offsetAt(e.range.start);\n                if (startOffset < lastModifiedOffset) {\n                    throw new Error('Overlapping edit');\n                }\n                else if (startOffset > lastModifiedOffset) {\n                    spans.push(text.substring(lastModifiedOffset, startOffset));\n                }\n                if (e.newText.length) {\n                    spans.push(e.newText);\n                }\n                lastModifiedOffset = document.offsetAt(e.range.end);\n            }\n            spans.push(text.substr(lastModifiedOffset));\n            return spans.join('');\n        }\n        TextDocument.applyEdits = applyEdits;\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n    function computeLineOffsets(text, isAtLineStart, textOffset) {\n        if (textOffset === void 0) { textOffset = 0; }\n        var result = isAtLineStart ? [textOffset] : [];\n        for (var i = 0; i < text.length; i++) {\n            var ch = text.charCodeAt(i);\n            if (isEOL(ch)) {\n                if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                    i++;\n                }\n                result.push(textOffset + i + 1);\n            }\n        }\n        return result;\n    }\n    function isEOL(char) {\n        return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n    }\n    function getWellformedRange(range) {\n        var start = range.start;\n        var end = range.end;\n        if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n            return { start: end, end: start };\n        }\n        return range;\n    }\n    function getWellformedEdit(textEdit) {\n        var range = getWellformedRange(textEdit.range);\n        if (range !== textEdit.range) {\n            return { newText: textEdit.newText, range: range };\n        }\n        return textEdit;\n    }\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserDirective = void 0;\nconst main_1 = require(\"./main\");\nconst line_1 = require(\"./line\");\nclass ParserDirective extends line_1.Line {\n    constructor(document, range, nameRange, valueRange) {\n        super(document, range);\n        this.nameRange = nameRange;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        return \"# \" + this.getName() + '=' + this.getValue();\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    getName() {\n        return this.document.getText().substring(this.document.offsetAt(this.nameRange.start), this.document.offsetAt(this.nameRange.end));\n    }\n    getValue() {\n        return this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n    }\n    getDirective() {\n        const directive = main_1.Directive[this.getName().toLowerCase()];\n        return directive === undefined ? null : directive;\n    }\n}\nexports.ParserDirective = ParserDirective;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Instruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst util_1 = require(\"./util\");\nconst line_1 = require(\"./line\");\nconst argument_1 = require(\"./argument\");\nconst heredoc_1 = require(\"./heredoc\");\nconst variable_1 = require(\"./variable\");\nconst main_1 = require(\"./main\");\nclass Instruction extends line_1.Line {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range);\n        this.dockerfile = dockerfile;\n        this.escapeChar = escapeChar;\n        this.instruction = instruction;\n        this.instructionRange = instructionRange;\n    }\n    toString() {\n        let value = this.getKeyword();\n        for (let arg of this.getRawArguments()) {\n            value += ' ';\n            value += arg.getValue();\n        }\n        return value;\n    }\n    getRangeContent(range) {\n        if (range === null) {\n            return null;\n        }\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    getInstructionRange() {\n        return this.instructionRange;\n    }\n    getInstruction() {\n        return this.instruction;\n    }\n    getKeyword() {\n        return this.getInstruction().toUpperCase();\n    }\n    getArgumentsRange() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return null;\n        }\n        return vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end);\n    }\n    getArgumentsRanges() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return [];\n        }\n        if (args[0].getRange().start.line === args[args.length - 1].getRange().end.line) {\n            return [vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end)];\n        }\n        let ranges = [];\n        let end = -1;\n        let startPosition = args[0].getRange().start;\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(startPosition) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra, this.document.offsetAt(args[args.length - 1].getRange().end) - this.document.offsetAt(range.start));\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        for (let i = 0; i < fullArgs.length; i++) {\n            let char = fullArgs.charAt(i);\n            if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') {\n                    whitespaceCheck: for (let j = i + 2; j < fullArgs.length; j++) {\n                        switch (fullArgs.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                if (startPosition !== null) {\n                                    ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                                }\n                                startPosition = null;\n                                start = true;\n                                comment = false;\n                                i = j;\n                                break whitespaceCheck;\n                            default:\n                                break whitespaceCheck;\n                        }\n                    }\n                }\n                else if (next === '\\r') {\n                    if (startPosition !== null) {\n                        ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                        startPosition = null;\n                    }\n                    start = true;\n                    comment = false;\n                    i += 2;\n                }\n                else if (next === '\\n') {\n                    if (startPosition !== null) {\n                        ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                    }\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                    i++;\n                }\n                else {\n                    i++;\n                }\n            }\n            else if (util_1.Util.isNewline(char)) {\n                if (comment) {\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                }\n            }\n            else {\n                if (!comment) {\n                    if (startPosition === null) {\n                        if (char === '#') {\n                            comment = true;\n                            continue;\n                        }\n                        let position = this.document.positionAt(offset + i);\n                        if (position.character !== 0) {\n                            startPosition = vscode_languageserver_types_1.Position.create(position.line, 0);\n                        }\n                    }\n                    end = i;\n                }\n            }\n        }\n        if (startPosition === null) {\n            // should only happen if the last argument is on its own line with\n            // no leading whitespace\n            ranges.push(vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + end), this.document.positionAt(offset + end + 1)));\n        }\n        else {\n            ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n        }\n        return ranges;\n    }\n    getRawArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return null;\n        }\n        return this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end));\n    }\n    getArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return null;\n        }\n        let content = \"\";\n        let ranges = this.getArgumentsRanges();\n        let documentText = this.document.getText();\n        for (let range of ranges) {\n            content += documentText.substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n        }\n        return content;\n    }\n    getArguments() {\n        return this.getRawArguments();\n    }\n    getRawArguments() {\n        let args = [];\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(range.end) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        let found = -1;\n        // determines whether the parser has found a space or tab\n        // whitespace character that's a part of an escaped newline sequence\n        let escapedWhitespaceDetected = false;\n        // determines if the parser is currently in an escaped newline sequence\n        let escaping = false;\n        let escapeMarker = -1;\n        let escapedArg = \"\";\n        for (let i = 0; i < fullArgs.length; i++) {\n            let char = fullArgs.charAt(i);\n            if (util_1.Util.isWhitespace(char)) {\n                if (escaping) {\n                    escapedWhitespaceDetected = true;\n                    if (util_1.Util.isNewline(char)) {\n                        // reached a newline, any previously\n                        // detected whitespace should be ignored\n                        escapedWhitespaceDetected = false;\n                        if (comment) {\n                            // reached a newline, no longer in a comment\n                            comment = false;\n                            start = true;\n                        }\n                    }\n                    continue;\n                }\n                else if (found !== -1) {\n                    if (escapeMarker === -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + i))));\n                    }\n                    else {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                    }\n                    escapeMarker = -1;\n                    escapedArg = \"\";\n                    found = -1;\n                }\n            }\n            else if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') {\n                    whitespaceCheck: for (let j = i + 2; j < fullArgs.length; j++) {\n                        let newlineCheck = fullArgs.charAt(j);\n                        switch (newlineCheck) {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                comment = false;\n                                escaping = true;\n                                start = true;\n                                if (found !== -1) {\n                                    escapeMarker = i;\n                                }\n                                i = j;\n                                break whitespaceCheck;\n                            default:\n                                escapeMarker = i;\n                                if (found === -1) {\n                                    i = j - 1;\n                                }\n                                break whitespaceCheck;\n                        }\n                    }\n                }\n                else if (next === '\\r') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) {\n                        escapeMarker = i;\n                    }\n                    i += 2;\n                }\n                else if (next === '\\n') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) {\n                        escapeMarker = i;\n                    }\n                    i++;\n                }\n                else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapeMarker = -1;\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    if (next === '$') {\n                        escapedArg = escapedArg + char + next;\n                    }\n                    else if (next === '') {\n                        // reached EOF, stop processing\n                        break;\n                    }\n                    else {\n                        escapedArg = escapedArg + next;\n                    }\n                    if (found === -1) {\n                        found = i;\n                    }\n                    i++;\n                }\n            }\n            else if (!comment) {\n                if (start && char === '#') {\n                    comment = true;\n                }\n                else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    escapeMarker = -1;\n                    escapedArg = escapedArg + char;\n                    if (found === -1) {\n                        found = i;\n                    }\n                }\n                // non-whitespace character detected, reset\n                start = false;\n            }\n        }\n        if (found !== -1) {\n            if (escapeMarker === -1) {\n                args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + fullArgs.length))));\n            }\n            else {\n                args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n            }\n        }\n        return args;\n    }\n    getExpandedArguments() {\n        let args = this.getArguments();\n        for (let i = 0; i < args.length; i++) {\n            const argRange = args[i].getRange();\n            let offset = this.document.offsetAt(argRange.start);\n            const variables = this.parseVariables(offset, args[i].getValue());\n            const swaps = [];\n            let requiresExpansion = false;\n            for (let variable of variables) {\n                const value = this.dockerfile.resolveVariable(variable.getName(), variable.getNameRange().start.line);\n                swaps.push(value);\n                requiresExpansion = requiresExpansion || value !== undefined;\n            }\n            if (requiresExpansion) {\n                let expanded = \"\";\n                for (let j = 0; j < swaps.length; j++) {\n                    const variableRange = variables[j].getRange();\n                    const start = this.document.offsetAt(variableRange.start);\n                    const end = this.document.offsetAt(variableRange.end);\n                    if (swaps[j]) {\n                        // replace variable with its resolved value\n                        expanded += this.document.getText().substring(offset, start);\n                        expanded += swaps[j];\n                        offset = end;\n                    }\n                    else {\n                        expanded += this.document.getText().substring(offset, end);\n                        offset = end;\n                    }\n                }\n                const argEnd = this.document.offsetAt(argRange.end);\n                if (argEnd !== offset) {\n                    // if the variable's range doesn't match the argument,\n                    // append the remaining text\n                    expanded += this.document.getText().substring(offset, argEnd);\n                }\n                args[i] = new argument_1.Argument(expanded, argRange);\n            }\n        }\n        return args;\n    }\n    getVariables() {\n        const variables = [];\n        const args = this.getRawArguments();\n        for (const arg of args) {\n            let range = arg.getRange();\n            let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n            const parsedVariables = this.parseVariables(this.document.offsetAt(arg.getRange().start), rawValue);\n            for (const parsedVariable of parsedVariables) {\n                variables.push(parsedVariable);\n            }\n        }\n        return variables;\n    }\n    parseVariables(offset, arg) {\n        let variables = [];\n        variableLoop: for (let i = 0; i < arg.length; i++) {\n            switch (arg.charAt(i)) {\n                case this.escapeChar:\n                    if (arg.charAt(i + 1) === '$') {\n                        i++;\n                    }\n                    break;\n                case '$':\n                    if (arg.charAt(i + 1) === '{') {\n                        let escapedString = \"${\";\n                        let escapedName = \"\";\n                        let nameEnd = -1;\n                        let escapedSubstitutionParameter = \"\";\n                        let substitutionStart = -1;\n                        let substitutionEnd = -1;\n                        let modifierRead = -1;\n                        nameLoop: for (let j = i + 2; j < arg.length; j++) {\n                            let char = arg.charAt(j);\n                            switch (char) {\n                                case this.escapeChar:\n                                    for (let k = j + 1; k < arg.length; k++) {\n                                        switch (arg.charAt(k)) {\n                                            case ' ':\n                                            case '\\t':\n                                            case '\\r':\n                                                // ignore whitespace\n                                                continue;\n                                            case '\\n':\n                                                // escape this newline\n                                                j = k;\n                                                continue nameLoop;\n                                        }\n                                    }\n                                    break;\n                                case '}':\n                                    escapedString += '}';\n                                    let modifier = null;\n                                    let modifierRange = null;\n                                    let substitutionParameter = modifierRead !== -1 ? escapedSubstitutionParameter : null;\n                                    let substitutionRange = null;\n                                    if (nameEnd === -1) {\n                                        nameEnd = j;\n                                    }\n                                    else if (nameEnd + 1 === j) {\n                                        modifier = \"\";\n                                        modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + nameEnd + 1), this.document.positionAt(offset + nameEnd + 1));\n                                    }\n                                    else {\n                                        if (substitutionStart === -1) {\n                                            // no substitution parameter found,\n                                            // but a modifier character existed,\n                                            // just offset the range by 1 from\n                                            // the modifier character\n                                            substitutionStart = modifierRead + 1;\n                                            substitutionEnd = modifierRead + 1;\n                                        }\n                                        else {\n                                            // offset one more from the last\n                                            // character found\n                                            substitutionEnd = substitutionEnd + 1;\n                                        }\n                                        modifier = arg.substring(modifierRead, modifierRead + 1);\n                                        modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + modifierRead), this.document.positionAt(offset + modifierRead + 1));\n                                        substitutionRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + substitutionStart), this.document.positionAt(offset + substitutionEnd));\n                                    }\n                                    let start = this.document.positionAt(offset + i);\n                                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 2), this.document.positionAt(offset + nameEnd)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j + 1)), modifier, modifierRange, substitutionParameter, substitutionRange, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), escapedString));\n                                    i = j;\n                                    continue variableLoop;\n                                case ':':\n                                    if (nameEnd === -1) {\n                                        nameEnd = j;\n                                    }\n                                    else if (modifierRead !== -1) {\n                                        if (substitutionStart === -1) {\n                                            substitutionStart = j;\n                                            substitutionEnd = j;\n                                        }\n                                        else {\n                                            substitutionEnd = j;\n                                        }\n                                        escapedSubstitutionParameter += ':';\n                                    }\n                                    else {\n                                        modifierRead = j;\n                                    }\n                                    escapedString += ':';\n                                    break;\n                                case '\\n':\n                                case '\\r':\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    if (nameEnd === -1) {\n                                        escapedName += char;\n                                    }\n                                    else if (modifierRead !== -1) {\n                                        if (substitutionStart === -1) {\n                                            substitutionStart = j;\n                                            substitutionEnd = j;\n                                        }\n                                        else {\n                                            substitutionEnd = j;\n                                        }\n                                        escapedSubstitutionParameter += char;\n                                    }\n                                    else {\n                                        modifierRead = j;\n                                    }\n                                    escapedString += char;\n                                    break;\n                            }\n                        }\n                        // no } found, not a valid variable, stop processing\n                        break variableLoop;\n                    }\n                    else if (util_1.Util.isWhitespace(arg.charAt(i + 1)) || i === arg.length - 1) {\n                        // $ followed by whitespace or EOF, ignore this variable\n                        continue;\n                    }\n                    else {\n                        let escapedName = \"\";\n                        nameLoop: for (let j = i + 1; j < arg.length; j++) {\n                            let char = arg.charAt(j);\n                            switch (char) {\n                                case '\\r':\n                                case '\\n':\n                                case ' ':\n                                case '\\t':\n                                    continue;\n                                case '$':\n                                case '\\'':\n                                case '\"':\n                                    let varStart = this.document.positionAt(offset + i);\n                                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                                    i = j - 1;\n                                    continue variableLoop;\n                                case this.escapeChar:\n                                    for (let k = j + 1; k < arg.length; k++) {\n                                        switch (arg.charAt(k)) {\n                                            case ' ':\n                                            case '\\t':\n                                            case '\\r':\n                                                // ignore whitespace\n                                                continue;\n                                            case '\\n':\n                                                // escape this newline\n                                                j = k;\n                                                continue nameLoop;\n                                        }\n                                    }\n                                    // reached EOF after an escape character\n                                    let start = this.document.positionAt(offset + i);\n                                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                                    break variableLoop;\n                            }\n                            if (char.match(/^[a-z0-9_]+$/i) === null) {\n                                let varStart = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                                i = j - 1;\n                                continue variableLoop;\n                            }\n                            escapedName += char;\n                        }\n                        let start = this.document.positionAt(offset + i);\n                        variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + arg.length)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + arg.length)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                    }\n                    break variableLoop;\n            }\n        }\n        return variables;\n    }\n    isBuildVariable(variable, line) {\n        if (this.getKeyword() === main_1.Keyword.FROM) {\n            for (const initialArg of this.dockerfile.getInitialARGs()) {\n                const arg = initialArg;\n                const property = arg.getProperty();\n                if (property && variable === property.getName()) {\n                    return true;\n                }\n            }\n            return undefined;\n        }\n        let image = this.dockerfile.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        let envs = image.getENVs();\n        for (let i = envs.length - 1; i >= 0; i--) {\n            if (envs[i].isBefore(line)) {\n                for (let property of envs[i].getProperties()) {\n                    if (property.getName() === variable) {\n                        return false;\n                    }\n                }\n            }\n        }\n        let args = image.getARGs();\n        for (let i = args.length - 1; i >= 0; i--) {\n            if (args[i].isBefore(line)) {\n                let property = args[i].getProperty();\n                if (property && property.getName() === variable) {\n                    return true;\n                }\n            }\n        }\n        return undefined;\n    }\n    createSingleLineHeredocs(args) {\n        const heredocs = [];\n        // instruction only on one line, if heredocs exist they would be incomplete\n        for (const arg of args) {\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && util_1.Util.parseHeredocName(value) !== null) {\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n            }\n        }\n        return heredocs;\n    }\n    getName(nameRange) {\n        const content = this.document.getText(nameRange);\n        let escaping = false;\n        let name = \"\";\n        nameLoop: for (let i = 0; i < content.length; i++) {\n            const ch = content.charAt(i);\n            switch (ch) {\n                case this.escapeChar:\n                    escaping = true;\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                                i = j + 1;\n                                continue nameLoop;\n                            case '\\n':\n                                i = j;\n                                continue nameLoop;\n                            default:\n                                name += content.charAt(j);\n                                i = j;\n                                continue nameLoop;\n                        }\n                    }\n                    break;\n                case '#':\n                    if (escaping) {\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\n':\n                                    i = j;\n                                    continue nameLoop;\n                            }\n                        }\n                    }\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    if (escaping) {\n                        break;\n                    }\n                default:\n                    name += ch;\n                    break;\n            }\n        }\n        return name;\n    }\n    getNameRange(startRange) {\n        const content = this.document.getText(startRange);\n        let endFound = false;\n        let searchHyphen = false;\n        let start = -1;\n        let end = -1;\n        let escaping = false;\n        let quote = null;\n        contentLoop: for (let i = 0; i < content.length; i++) {\n            const ch = content.charAt(i);\n            switch (ch) {\n                case '\"':\n                case '\\'':\n                    if (quote === ch) {\n                        break contentLoop;\n                    }\n                    quote = ch;\n                    continue;\n                case this.escapeChar:\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case '\\n':\n                                escaping = true;\n                                j = i;\n                                continue contentLoop;\n                        }\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '<':\n                    if (endFound) {\n                        searchHyphen = true;\n                    }\n                    else {\n                        endFound = true;\n                    }\n                    break;\n                case '-':\n                    if (searchHyphen) {\n                        searchHyphen = false;\n                        break;\n                    }\n                case '#':\n                    if (escaping) {\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\n':\n                                    i = j;\n                                    continue contentLoop;\n                            }\n                        }\n                    }\n                default:\n                    if (start === -1) {\n                        start = i;\n                    }\n                    if (quote !== null) {\n                        end = i + 1;\n                        break;\n                    }\n                    break contentLoop;\n            }\n        }\n        if (start === -1) {\n            return vscode_languageserver_types_1.Range.create(startRange.end, startRange.end);\n        }\n        const nameStart = this.document.positionAt(this.document.offsetAt(startRange.start) + start);\n        const nameEnd = quote !== null ? this.document.positionAt(this.document.offsetAt(startRange.start) + end) : startRange.end;\n        return vscode_languageserver_types_1.Range.create(nameStart, nameEnd);\n    }\n    getHeredocs() {\n        const args = this.getArguments();\n        if (args.length === 0) {\n            return [];\n        }\n        const heredocs = [];\n        const range = this.getRange();\n        if (range.start.line === range.end.line) {\n            // instruction only on one line, if heredocs exist they would be incomplete\n            return this.createSingleLineHeredocs(args);\n        }\n        const heredocDefinitions = [];\n        let heredocsProcessed = false;\n        let escaping = false;\n        let contentStart = -1;\n        let contentEnd = -1;\n        let lineStart = -1;\n        let currentHeredoc = 0;\n        const startOffset = this.document.offsetAt(args[0].getRange().start);\n        const content = this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end));\n        contentLoop: for (let i = 0; i < content.length; i++) {\n            switch (content.charAt(i)) {\n                case this.escapeChar:\n                    escaping = true;\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                i = j;\n                                continue contentLoop;\n                            default:\n                                i = j;\n                                continue contentLoop;\n                        }\n                    }\n                    break;\n                case '\\r':\n                    break;\n                case '\\n':\n                    if (escaping) {\n                        break;\n                    }\n                    if (heredocsProcessed) {\n                        if (contentStart === -1) {\n                            contentStart = i;\n                        }\n                        contentEnd = i;\n                        const arg = heredocDefinitions[currentHeredoc];\n                        const startRange = arg.getRange();\n                        const nameRange = this.getNameRange(startRange);\n                        const name = this.getName(nameRange);\n                        const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), this.document.positionAt(startOffset + i)));\n                        if (delimiterRange !== null) {\n                            const contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + lineStart - 1));\n                            heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n                            contentStart = -1;\n                            currentHeredoc++;\n                        }\n                        lineStart = -1;\n                    }\n                    else {\n                        // found a newline that hasn't been escaped,\n                        // must be in a heredoc\n                        const offsetLimit = startOffset + i;\n                        for (const arg of args) {\n                            // check if this argument is on the initial line of the instruction,\n                            // note that it may not all be on the same line due to escaped newlines,\n                            // because of that we need to use offset checks instead of line checks\n                            // as an argument being on a different line in the document does not\n                            // imply it is on a different line from the Dockerfile's point of view\n                            if (this.document.offsetAt(arg.getRange().start) < offsetLimit) {\n                                if (arg.getValue().startsWith(\"<<\")) {\n                                    heredocDefinitions.push(arg);\n                                }\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        heredocsProcessed = true;\n                        lineStart = -1;\n                        continue contentLoop;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escaping) {\n                        break;\n                    }\n                case '#':\n                    if (escaping) {\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\n':\n                                    i = j;\n                                    continue contentLoop;\n                            }\n                        }\n                    }\n                default:\n                    if (escaping) {\n                        escaping = false;\n                    }\n                    if (heredocsProcessed) {\n                        if (contentStart === -1) {\n                            contentStart = i;\n                        }\n                        if (lineStart === -1) {\n                            lineStart = i;\n                        }\n                    }\n                    break;\n            }\n        }\n        if (heredocsProcessed) {\n            const arg = heredocDefinitions[currentHeredoc];\n            const startRange = arg.getRange();\n            const nameRange = this.getNameRange(startRange);\n            const name = this.getName(nameRange);\n            let contentRange = null;\n            // check if the last line of this instruction matches the name of the last heredoc\n            const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), range.end));\n            if (delimiterRange === null) {\n                contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), range.end);\n            }\n            else if (contentEnd !== -1) {\n                contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + contentEnd));\n            }\n            heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n            currentHeredoc++;\n            for (let i = currentHeredoc; i < heredocDefinitions.length; i++) {\n                const arg = heredocDefinitions[currentHeredoc];\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n                currentHeredoc++;\n            }\n        }\n        else {\n            // instruction only on one line, if heredocs exist they would be incomplete\n            return this.createSingleLineHeredocs(args);\n        }\n        return heredocs;\n    }\n    getDelimiterRange(startArg, name, candidateRange) {\n        const text = this.document.getText(candidateRange);\n        if (startArg.getValue().startsWith(\"<<-\")) {\n            // remove tabs in the front\n            let index = 0;\n            while (text.charAt(index) === '\\t') {\n                index++;\n            }\n            if (text.substring(index) === name) {\n                return vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(candidateRange.start.line, index), candidateRange.end);\n            }\n            return null;\n        }\n        return text === name ? candidateRange : null;\n    }\n}\nexports.Instruction = Instruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Heredoc = void 0;\n/**\n * Heredoc represents a here-document that has been embedded in a\n * Dockerfile.\n *\n * This API is experimental and subject to change.\n */\nclass Heredoc {\n    constructor(startRange, name, nameRange, contentRange, endRange) {\n        this.startRange = startRange;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.contentRange = contentRange;\n        this.endRange = endRange;\n    }\n    /**\n     * Returns the name of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */\n    getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range of the start operator and the name. If the\n     * here-document is initialized with <<EOT then the start range would\n     * encompass all five characters.\n     *\n     * This API is experimental and subject to change.\n     */\n    getStartRange() {\n        return this.startRange;\n    }\n    /**\n     * Returns the range of this here-document's name that is declared at\n     * the beginning of the here-document with the operator. If the\n     * here-document is initialized with <<EOT then the name range would\n     * encompass the latter three \"EOT\" characters.\n     *\n     * This API is experimental and subject to change.\n     */\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the content of this here-document. This may\n     * be null if the here-document has no content because:\n     * - the start range is the only thing that was declared\n     * - the end range was declared immediately and there is no content\n     *\n     * This API is experimental and subject to change.\n     */\n    getContentRange() {\n        return this.contentRange;\n    }\n    /**\n     * Returns the range of the here-document's name on a line that\n     * represents the end of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */\n    getDelimiterRange() {\n        return this.endRange;\n    }\n}\nexports.Heredoc = Heredoc;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\nclass Variable {\n    constructor(name, nameRange, range, modifier, modifierRange, substitutionParameter, substitutionRange, defined, buildVariable, stringValue) {\n        this.name = name;\n        this.nameRange = nameRange;\n        this.range = range;\n        this.modifier = modifier;\n        this.modifierRange = modifierRange;\n        this.substitutionParameter = substitutionParameter;\n        this.substitutionRange = substitutionRange;\n        this.defined = defined;\n        this.buildVariable = buildVariable;\n        this.stringValue = stringValue;\n    }\n    toString() {\n        return this.stringValue;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the entire variable. This includes the symbols for\n     * the declaration of the variable such as the $, {, and } symbols.\n     *\n     * @return the range in the document that this variable encompasses in its\n     *         entirety\n     */\n    getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the modifier character that has been set for\n     * specifying how this variable should be expanded and resolved.\n     * If this variable is ${variable:+value} then the modifier\n     * character is '+'. Will be the empty string if the variable is\n     * declared as ${variable:}. Otherwise, will be null if this\n     * variable will not use variable substitution at all (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's modifier character, or the empty\n     *         string if it does not have one, or null if this\n     *         variable will not use variable substitution\n     */\n    getModifier() {\n        return this.modifier;\n    }\n    getModifierRange() {\n        return this.modifierRange;\n    }\n    /**\n     * Returns the parameter that will be used for substitution if\n     * this variable uses modifiers to define how its value should be\n     * resolved. If this variable is ${variable:+value} then the\n     * substitution value will be 'value'. Will be the empty string\n     * if the variable is declared as ${variable:+} or some other\n     * variant where the only thing that follows the modifier\n     * character (excluding considerations of escape characters and\n     * so on) is the variable's closing bracket. May be null if this\n     * variable does not have a modifier character defined (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's substitution parameter, or the empty\n     *         string if it does not have one, or null if there is\n     *         not one defined\n     */\n    getSubstitutionParameter() {\n        return this.substitutionParameter;\n    }\n    getSubstitutionRange() {\n        return this.substitutionRange;\n    }\n    /**\n     * Returns whether this variable has been defined or not.\n     *\n     * @return true if this variable has been defined, false otherwise\n     */\n    isDefined() {\n        return this.defined;\n    }\n    isBuildVariable() {\n        return this.buildVariable === true;\n    }\n    isEnvironmentVariable() {\n        return this.buildVariable === false;\n    }\n}\nexports.Variable = Variable;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Add = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Add extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n}\nexports.Add = Add;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst argument_1 = require(\"./argument\");\nconst jsonArgument_1 = require(\"./jsonArgument\");\nconst modifiableInstruction_1 = require(\"./modifiableInstruction\");\nclass JSONInstruction extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.openingBracket = null;\n        this.closingBracket = null;\n        this.jsonStrings = [];\n        const argsContent = this.getRawArgumentsContent();\n        if (argsContent === null) {\n            return;\n        }\n        const args = this.getArguments();\n        if (args.length === 1 && args[0].getValue() === \"[]\") {\n            let argRange = args[0].getRange();\n            this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character, argRange.start.line, argRange.start.character + 1));\n            this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character + 1, argRange.end.line, argRange.end.character));\n            return;\n        }\n        else if (args.length === 2 && args[0].getValue() === '[' && args[1].getValue() === ']') {\n            this.openingBracket = args[0];\n            this.closingBracket = args[1];\n            return;\n        }\n        const argsOffset = document.offsetAt(this.getArgumentsRange().start);\n        let start = -1;\n        let last = \"\";\n        let quoted = false;\n        let escapedArg = \"\";\n        argsCheck: for (let i = 0; i < argsContent.length; i++) {\n            let char = argsContent.charAt(i);\n            switch (char) {\n                case '[':\n                    if (last === \"\") {\n                        this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        last = '[';\n                    }\n                    else if (quoted) {\n                        escapedArg = escapedArg + char;\n                    }\n                    else {\n                        break argsCheck;\n                    }\n                    break;\n                case '\"':\n                    if (last === '[' || last === ',') {\n                        start = i;\n                        quoted = true;\n                        last = '\"';\n                        escapedArg = escapedArg + char;\n                        continue;\n                    }\n                    else if (last === '\"') {\n                        if (quoted) {\n                            escapedArg = escapedArg + char;\n                            // quoted string done\n                            quoted = false;\n                            this.jsonStrings.push(new jsonArgument_1.JSONArgument(escapedArg, vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start), document.positionAt(argsOffset + i + 1)), vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start + 1), document.positionAt(argsOffset + i))));\n                            escapedArg = \"\";\n                        }\n                        else {\n                            // should be a , or a ]\n                            break argsCheck;\n                        }\n                    }\n                    else {\n                        break argsCheck;\n                    }\n                    break;\n                case ',':\n                    if (quoted) {\n                        escapedArg = escapedArg + char;\n                    }\n                    else {\n                        if (last === '\"') {\n                            last = ',';\n                        }\n                        else {\n                            break argsCheck;\n                        }\n                    }\n                    break;\n                case ']':\n                    if (quoted) {\n                        escapedArg = escapedArg + char;\n                    }\n                    else if (last !== \"\") {\n                        this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        break argsCheck;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    break;\n                case '\\\\':\n                    if (quoted) {\n                        switch (argsContent.charAt(i + 1)) {\n                            case '\"':\n                            case '\\\\':\n                                escapedArg = escapedArg + argsContent.charAt(i + 1);\n                                i++;\n                                continue;\n                            case ' ':\n                            case '\\t':\n                                escapeCheck: for (let j = i + 2; j < argsContent.length; j++) {\n                                    switch (argsContent.charAt(j)) {\n                                        case '\\r':\n                                            // offset one more for \\r\\n\n                                            j++;\n                                        case '\\n':\n                                            i = j;\n                                            continue argsCheck;\n                                        case ' ':\n                                        case '\\t':\n                                            break;\n                                        default:\n                                            break escapeCheck;\n                                    }\n                                }\n                                break;\n                            case '\\r':\n                                // offset one more for \\r\\n\n                                i++;\n                            default:\n                                i++;\n                                continue;\n                        }\n                    }\n                    else {\n                        escapeCheck: for (let j = i + 1; j < argsContent.length; j++) {\n                            switch (argsContent.charAt(j)) {\n                                case '\\r':\n                                    // offset one more for \\r\\n\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    continue argsCheck;\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    break escapeCheck;\n                            }\n                        }\n                    }\n                    break argsCheck;\n                default:\n                    if (!quoted) {\n                        break argsCheck;\n                    }\n                    escapedArg = escapedArg + char;\n                    break;\n            }\n        }\n    }\n    stopSearchingForFlags(_value) {\n        return true;\n    }\n    getOpeningBracket() {\n        return this.openingBracket;\n    }\n    getJSONStrings() {\n        return this.jsonStrings;\n    }\n    getClosingBracket() {\n        return this.closingBracket;\n    }\n}\nexports.JSONInstruction = JSONInstruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ModifiableInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst flag_1 = require(\"./flag\");\nconst instruction_1 = require(\"./instruction\");\nclass ModifiableInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getFlags() {\n        if (!this.flags) {\n            this.flags = [];\n            for (let arg of this.getArguments()) {\n                let value = arg.getValue();\n                if (this.stopSearchingForFlags(value)) {\n                    return this.flags;\n                }\n                else if (value.indexOf(\"--\") === 0) {\n                    let range = arg.getRange();\n                    let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n                    let nameIndex = value.indexOf('=');\n                    let index = rawValue.indexOf('=');\n                    let firstMatch = false;\n                    let secondMatch = false;\n                    let startIndex = -1;\n                    nameSearchLoop: for (let i = 0; i < rawValue.length; i++) {\n                        switch (rawValue.charAt(i)) {\n                            case '\\\\':\n                            case ' ':\n                            case '\\t':\n                            case '\\r':\n                            case '\\n':\n                                break;\n                            case '-':\n                                if (secondMatch) {\n                                    startIndex = i;\n                                    break nameSearchLoop;\n                                }\n                                else if (firstMatch) {\n                                    secondMatch = true;\n                                }\n                                else {\n                                    firstMatch = true;\n                                }\n                                break;\n                            default:\n                                startIndex = i;\n                                break nameSearchLoop;\n                        }\n                    }\n                    let nameStart = this.document.positionAt(this.document.offsetAt(range.start) + startIndex);\n                    if (index === -1) {\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2), vscode_languageserver_types_1.Range.create(nameStart, range.end), null, null));\n                    }\n                    else if (index === value.length - 1) {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, index), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), \"\", vscode_languageserver_types_1.Range.create(range.end, range.end)));\n                    }\n                    else {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, nameIndex), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), value.substring(nameIndex + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(this.document.offsetAt(range.start) + index + 1), range.end)));\n                    }\n                }\n            }\n        }\n        return this.flags;\n    }\n    getArguments() {\n        const args = super.getArguments();\n        const flags = this.getFlags();\n        if (flags.length === 0) {\n            return args;\n        }\n        for (let i = 0; i < flags.length; i++) {\n            args.shift();\n        }\n        return args;\n    }\n}\nexports.ModifiableInstruction = ModifiableInstruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Flag = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst flagOption_1 = require(\"./flagOption\");\nclass Flag {\n    constructor(document, range, name, nameRange, value, valueRange) {\n        this.options = [];\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n        if (this.value !== null) {\n            let offset = document.offsetAt(valueRange.start);\n            let nameStart = -1;\n            let valueStart = -1;\n            let hasOptions = false;\n            for (let i = 0; i < value.length; i++) {\n                switch (value.charAt(i)) {\n                    case '=':\n                        hasOptions = true;\n                        if (valueStart === -1) {\n                            valueStart = i + 1;\n                            break;\n                        }\n                        break;\n                    case ',':\n                        this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, i));\n                        nameStart = -1;\n                        valueStart = -1;\n                        break;\n                    default:\n                        if (nameStart === -1) {\n                            nameStart = i;\n                        }\n                        break;\n                }\n            }\n            if (hasOptions && nameStart !== -1) {\n                this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, value.length));\n            }\n        }\n    }\n    createFlagOption(document, content, documentOffset, nameStart, valueStart, valueEnd) {\n        const optionRange = vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueEnd));\n        if (valueStart === -1) {\n            return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueEnd), optionRange, null, null);\n        }\n        return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueStart - 1), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueStart - 1)), content.substring(valueStart, valueEnd), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + valueStart), document.positionAt(documentOffset + valueEnd)));\n    }\n    toString() {\n        if (this.valueRange) {\n            return \"--\" + this.name + \"=\" + this.value;\n        }\n        return \"--\" + this.name;\n    }\n    /**\n     * Returns the range that encompasses this entire flag. This includes the\n     * -- prefix in the beginning to the last character of the flag's value (if\n     * it has been defined).\n     *\n     * @return the entire range of this flag\n     */\n    getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the name of this flag. The name does not include the -- prefix.\n     * Thus, for HEALTHCHECK's --interval flag, interval is the flag's name and\n     * not --interval.\n     *\n     * @return this flag's name\n     */\n    getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range that encompasses the flag's name\n     *\n     * @return the range containing the flag's name\n     */\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the value that has been set to this flag. May be null if the\n     * flag is invalid and has no value set like a --start-period. If the flag\n     * is instead a --start-period= with an equals sign then the flag's value\n     * is the empty string.\n     *\n     * @return this flag's value if it has been defined, null otherwise\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * Returns the range that encompasses this flag's value. If no value has\n     * been set then null will be returned.\n     *\n     * @return the range containing this flag's value, or null if the flag\n     *         has no value defined\n     */\n    getValueRange() {\n        return this.valueRange;\n    }\n    getOption(name) {\n        for (const option of this.options) {\n            if (option.getName() === name) {\n                return option;\n            }\n        }\n        return null;\n    }\n    getOptions() {\n        return this.options;\n    }\n    hasOptions() {\n        return this.options.length > 0;\n    }\n}\nexports.Flag = Flag;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlagOption = void 0;\nclass FlagOption {\n    constructor(range, name, nameRange, value, valueRange) {\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        if (this.valueRange !== null) {\n            return this.name + \"=\" + this.value;\n        }\n        return this.name;\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n}\nexports.FlagOption = FlagOption;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Arg = void 0;\nconst property_1 = require(\"../property\");\nconst propertyInstruction_1 = require(\"../propertyInstruction\");\nclass Arg extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.property = null;\n        const args = this.getPropertyArguments();\n        if (args.length === 1) {\n            this.property = new property_1.Property(this.document, this.escapeChar, args[0]);\n        }\n        else {\n            this.property = null;\n        }\n    }\n    /**\n     * Returns the variable defined by this ARG. This may be null if\n     * this ARG instruction is malformed and has no variable\n     * declaration.\n     */\n    getProperty() {\n        return this.property;\n    }\n}\nexports.Arg = Arg;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Property = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst util_1 = require(\"./util\");\nclass Property {\n    constructor(document, escapeChar, arg, arg2) {\n        this.assignmentOperatorRange = null;\n        this.assignmentOperator = null;\n        this.valueRange = null;\n        this.value = null;\n        this.document = document;\n        this.escapeChar = escapeChar;\n        this.nameRange = Property.getNameRange(document, arg);\n        let value = document.getText().substring(document.offsetAt(this.nameRange.start), document.offsetAt(this.nameRange.end));\n        this.name = Property.getValue(value, escapeChar);\n        if (arg2) {\n            this.valueRange = arg2.getRange();\n            value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n            this.value = Property.getValue(value, escapeChar);\n            this.range = vscode_languageserver_types_1.Range.create(this.nameRange.start, this.valueRange.end);\n        }\n        else {\n            let argRange = arg.getRange();\n            if (this.nameRange.start.line === argRange.start.line\n                && this.nameRange.start.character === argRange.start.character\n                && this.nameRange.end.line === argRange.end.line\n                && this.nameRange.end.character === argRange.end.character) {\n            }\n            else {\n                this.valueRange = Property.getValueRange(document, arg);\n                value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n                this.value = Property.getValue(value, escapeChar);\n                this.assignmentOperatorRange = vscode_languageserver_types_1.Range.create(this.nameRange.end, this.valueRange.start);\n                this.assignmentOperator = \"=\";\n            }\n            this.range = argRange;\n        }\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    /**\n     * Retrieves the operator used for delimiting between the name and\n     * value of this property. This will either be the \"=\" character\n     * or null if a character was not used or if this property has no\n     * value defined.\n     */\n    getAssignmentOperator() {\n        return this.assignmentOperator;\n    }\n    getAssignmentOperatorRange() {\n        return this.assignmentOperatorRange;\n    }\n    /**\n     * Returns the value of this property including any enclosing\n     * single or double quotes and relevant escape characters.\n     * Escaped newlines and its associated contiguous whitespace\n     * characters however will not be returned as they are deemed to\n     * be uninteresting to clients trying to return a Dockerfile.\n     *\n     * @return the unescaped value of this property or null if this\n     *         property has no associated value\n     */\n    getUnescapedValue() {\n        if (this.valueRange === null) {\n            return null;\n        }\n        let escaped = false;\n        let rawValue = \"\";\n        let value = this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n        rawLoop: for (let i = 0; i < value.length; i++) {\n            let char = value.charAt(i);\n            switch (char) {\n                case this.escapeChar:\n                    for (let j = i + 1; j < value.length; j++) {\n                        switch (value.charAt(j)) {\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                escaped = true;\n                                i = j;\n                                continue rawLoop;\n                            case ' ':\n                            case '\\t':\n                                break;\n                            default:\n                                rawValue = rawValue + char;\n                                continue rawLoop;\n                        }\n                    }\n                    // this happens if there's only whitespace after the escape character\n                    rawValue = rawValue + char;\n                    break;\n                case '\\r':\n                case '\\n':\n                    break;\n                case ' ':\n                case '\\t':\n                    if (!escaped) {\n                        rawValue = rawValue + char;\n                    }\n                    break;\n                case '#':\n                    if (escaped) {\n                        for (let j = i + 1; j < value.length; j++) {\n                            switch (value.charAt(j)) {\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    continue rawLoop;\n                            }\n                        }\n                    }\n                    else {\n                        rawValue = rawValue + char;\n                    }\n                    break;\n                default:\n                    rawValue = rawValue + char;\n                    escaped = false;\n                    break;\n            }\n        }\n        return rawValue;\n    }\n    static getNameRange(document, arg) {\n        let value = arg.getValue();\n        let index = value.indexOf('=');\n        if (index !== -1) {\n            let initial = value.charAt(0);\n            let before = value.charAt(index - 1);\n            // check if content before the equals sign are in quotes\n            // \"var\"=value\n            // 'var'=value\n            // otherwise, just assume it's a standard definition\n            // var=value\n            if ((initial === '\"' && before === '\"') || (initial === '\\'' && before === '\\'') || (initial !== '\"' && initial !== '\\'')) {\n                return vscode_languageserver_types_1.Range.create(arg.getRange().start, document.positionAt(document.offsetAt(arg.getRange().start) + index));\n            }\n        }\n        // no '=' found, just defined the property's name\n        return arg.getRange();\n    }\n    static getValueRange(document, arg) {\n        return vscode_languageserver_types_1.Range.create(document.positionAt(document.offsetAt(arg.getRange().start) + arg.getValue().indexOf('=') + 1), document.positionAt(document.offsetAt(arg.getRange().end)));\n    }\n    /**\n     * Returns the actual value of this key-value pair. The value will\n     * have its escape characters removed if applicable. If the value\n     * spans multiple lines and there are comments nested within the\n     * lines, they too will be removed.\n     *\n     * @return the value that this key-value pair will actually be, may\n     *         be null if no value is defined, may be the empty string\n     *         if the value only consists of whitespace\n     */\n    static getValue(value, escapeChar) {\n        let escaped = false;\n        const skip = util_1.Util.findLeadingNonWhitespace(value, escapeChar);\n        if (skip !== 0 && value.charAt(skip) === '#') {\n            // need to skip over comments\n            escaped = true;\n        }\n        value = value.substring(skip);\n        let first = value.charAt(0);\n        let last = value.charAt(value.length - 1);\n        let literal = first === '\\'' || first === '\"';\n        let inSingle = (first === '\\'' && last === '\\'');\n        let inDouble = false;\n        if (first === '\"') {\n            for (let i = 1; i < value.length; i++) {\n                if (value.charAt(i) === escapeChar) {\n                    i++;\n                }\n                else if (value.charAt(i) === '\"' && i === value.length - 1) {\n                    inDouble = true;\n                }\n            }\n        }\n        if (inSingle || inDouble) {\n            value = value.substring(1, value.length - 1);\n        }\n        let commentCheck = -1;\n        let escapedValue = \"\";\n        let start = 0;\n        parseValue: for (let i = 0; i < value.length; i++) {\n            let char = value.charAt(i);\n            switch (char) {\n                case escapeChar:\n                    if (i + 1 === value.length) {\n                        escapedValue = escapedValue + escapeChar;\n                        break parseValue;\n                    }\n                    char = value.charAt(i + 1);\n                    if (char === ' ' || char === '\\t') {\n                        whitespaceCheck: for (let j = i + 2; j < value.length; j++) {\n                            let char2 = value.charAt(j);\n                            switch (char2) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    escaped = true;\n                                    i = j;\n                                    continue parseValue;\n                                default:\n                                    if (!inDouble && !inSingle && !literal) {\n                                        if (char2 === escapeChar) {\n                                            // add the escaped character\n                                            escapedValue = escapedValue + char;\n                                            // now start parsing from the next escape character\n                                            i = i + 1;\n                                        }\n                                        else {\n                                            // the expectation is that this j = i + 2 here\n                                            escapedValue = escapedValue + char + char2;\n                                            i = j;\n                                        }\n                                        continue parseValue;\n                                    }\n                                    break whitespaceCheck;\n                            }\n                        }\n                    }\n                    if (inDouble) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        }\n                        else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        }\n                        else if (char !== '\"') {\n                            if (char === escapeChar) {\n                                i++;\n                            }\n                            escapedValue = escapedValue + escapeChar;\n                        }\n                        continue parseValue;\n                    }\n                    else if (inSingle || literal) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        }\n                        else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        }\n                        else {\n                            escapedValue = escapedValue + escapeChar;\n                        }\n                        continue parseValue;\n                    }\n                    else if (char === escapeChar) {\n                        // double escape, append one and move on\n                        escapedValue = escapedValue + escapeChar;\n                        i++;\n                    }\n                    else if (char === '\\r') {\n                        escaped = true;\n                        // offset one more for \\r\\n\n                        i = i + 2;\n                    }\n                    else if (char === '\\n') {\n                        escaped = true;\n                        i++;\n                        start = i;\n                    }\n                    else {\n                        // any other escapes are simply ignored\n                        escapedValue = escapedValue + char;\n                        i++;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escaped && commentCheck === -1) {\n                        commentCheck = i;\n                    }\n                    escapedValue = escapedValue + char;\n                    break;\n                case '\\r':\n                    i++;\n                case '\\n':\n                    if (escaped && commentCheck !== -1) {\n                        // rollback and remove the whitespace that was previously appended\n                        escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck - 1));\n                        commentCheck = -1;\n                    }\n                    break;\n                case '#':\n                    // a newline was escaped and now there's a comment\n                    if (escaped) {\n                        if (commentCheck !== -1) {\n                            // rollback and remove the whitespace that was previously appended\n                            escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck));\n                            commentCheck = -1;\n                        }\n                        newlineCheck: for (let j = i + 1; j < value.length; j++) {\n                            switch (value.charAt(j)) {\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    break newlineCheck;\n                            }\n                        }\n                        continue parseValue;\n                    }\n                default:\n                    if (escaped) {\n                        escaped = false;\n                        commentCheck = -1;\n                    }\n                    escapedValue = escapedValue + char;\n                    break;\n            }\n        }\n        return escapedValue;\n    }\n}\nexports.Property = Property;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PropertyInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst instruction_1 = require(\"./instruction\");\nconst property_1 = require(\"./property\");\nconst argument_1 = require(\"./argument\");\nconst util_1 = require(\"./util\");\nclass PropertyInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.properties = undefined;\n    }\n    getProperties() {\n        if (this.properties === undefined) {\n            let args = this.getPropertyArguments();\n            if (args.length === 0) {\n                this.properties = [];\n            }\n            else if (args.length === 1) {\n                this.properties = [new property_1.Property(this.document, this.escapeChar, args[0])];\n            }\n            else if (args.length === 2) {\n                if (args[0].getValue().indexOf('=') === -1) {\n                    this.properties = [new property_1.Property(this.document, this.escapeChar, args[0], args[1])];\n                }\n                else {\n                    this.properties = [\n                        new property_1.Property(this.document, this.escapeChar, args[0]),\n                        new property_1.Property(this.document, this.escapeChar, args[1])\n                    ];\n                }\n            }\n            else if (args[0].getValue().indexOf('=') === -1) {\n                let text = this.document.getText();\n                let start = args[1].getRange().start;\n                let end = args[args.length - 1].getRange().end;\n                text = text.substring(this.document.offsetAt(start), this.document.offsetAt(end));\n                this.properties = [new property_1.Property(this.document, this.escapeChar, args[0], new argument_1.Argument(text, vscode_languageserver_types_1.Range.create(args[1].getRange().start, args[args.length - 1].getRange().end)))];\n            }\n            else {\n                this.properties = [];\n                for (let i = 0; i < args.length; i++) {\n                    this.properties.push(new property_1.Property(this.document, this.escapeChar, args[i]));\n                }\n            }\n        }\n        return this.properties;\n    }\n    /**\n     * Goes from the back of the string and returns the first\n     * non-whitespace character that is found. If an escape character\n     * is found with newline characters, the escape character will\n     * not be considered a non-whitespace character and its index in\n     * the string will not be returned.\n     *\n     * @param content the string to search through\n     * @return the index in the string for the first non-whitespace\n     *         character when searching from the end of the string\n     */\n    findTrailingNonWhitespace(content) {\n        // loop back to find the first non-whitespace character\n        let index = content.length;\n        whitespaceCheck: for (let i = content.length - 1; i >= 0; i--) {\n            switch (content.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    continue;\n                case '\\n':\n                    if (content.charAt(i - 1) === '\\r') {\n                        i = i - 1;\n                    }\n                case '\\r':\n                    newlineCheck: for (let j = i - 1; j >= 0; j--) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                            case '\\r':\n                            case '\\n':\n                            case this.escapeChar:\n                                continue;\n                            default:\n                                index = j;\n                                break newlineCheck;\n                        }\n                    }\n                    break whitespaceCheck;\n                default:\n                    index = i;\n                    break whitespaceCheck;\n            }\n        }\n        return index;\n    }\n    getPropertyArguments() {\n        const args = [];\n        let range = this.getInstructionRange();\n        let instructionNameEndOffset = this.document.offsetAt(range.end);\n        let extra = instructionNameEndOffset - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let start = util_1.Util.findLeadingNonWhitespace(fullArgs, this.escapeChar);\n        if (start === -1) {\n            // only whitespace found, no arguments\n            return [];\n        }\n        const startPosition = this.document.positionAt(instructionNameEndOffset + start);\n        // records whether the parser has just processed an escaped newline or not,\n        // if our starting position is not on the same line as the instruction then\n        // the start of the content is already on an escaped line\n        let escaped = range.start.line !== startPosition.line;\n        // flag to track if the last character was an escape character\n        let endingEscape = false;\n        // position before the first escape character was hit\n        let mark = -1;\n        let end = this.findTrailingNonWhitespace(fullArgs);\n        content = fullArgs.substring(start, end + 1);\n        let argStart = escaped ? -1 : 0;\n        let spaced = false;\n        argumentLoop: for (let i = 0; i < content.length; i++) {\n            let char = content.charAt(i);\n            switch (char) {\n                case this.escapeChar:\n                    if (i + 1 === content.length) {\n                        endingEscape = true;\n                        break argumentLoop;\n                    }\n                    if (!escaped) {\n                        mark = i;\n                    }\n                    switch (content.charAt(i + 1)) {\n                        case ' ':\n                        case '\\t':\n                            if (!util_1.Util.isWhitespace(content.charAt(i + 2))) {\n                                // space was escaped, continue as normal\n                                i = i + 1;\n                                continue argumentLoop;\n                            }\n                            // whitespace encountered, need to figure out if it extends to EOL\n                            whitespaceCheck: for (let j = i + 2; j < content.length; j++) {\n                                switch (content.charAt(j)) {\n                                    case '\\r':\n                                        // offset one more for \\r\\n\n                                        j++;\n                                    case '\\n':\n                                        // whitespace only, safe to skip\n                                        escaped = true;\n                                        i = j;\n                                        continue argumentLoop;\n                                    case ' ':\n                                    case '\\t':\n                                        // ignore whitespace\n                                        break;\n                                    default:\n                                        // whitespace doesn't extend to EOL, create an argument\n                                        args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i + 2))));\n                                        argStart = j;\n                                        break whitespaceCheck;\n                                }\n                            }\n                            // go back and start processing the encountered non-whitespace character\n                            i = argStart - 1;\n                            continue argumentLoop;\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            i++;\n                        case '\\n':\n                            // immediately followed by a newline, skip the newline\n                            escaped = true;\n                            i = i + 1;\n                            continue argumentLoop;\n                        case this.escapeChar:\n                            // double escape found, skip it and move on\n                            if (argStart === -1) {\n                                argStart = i;\n                            }\n                            i = i + 1;\n                            continue argumentLoop;\n                        default:\n                            if (argStart === -1) {\n                                argStart = i;\n                            }\n                            // non-whitespace encountered, skip the escape and process the\n                            // character normally\n                            continue argumentLoop;\n                    }\n                case '\\'':\n                case '\"':\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    if (argStart === -1) {\n                        argStart = i;\n                    }\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case char:\n                                if (content.charAt(j + 1) !== ' ' && content.charAt(j + 1) !== '') {\n                                    // there is more content after this quote,\n                                    // continue so that it is all processed as\n                                    // one single argument\n                                    i = j;\n                                    continue argumentLoop;\n                                }\n                                args.push(new argument_1.Argument(content.substring(argStart, j + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + j + 1))));\n                                i = j;\n                                argStart = -1;\n                                continue argumentLoop;\n                            case this.escapeChar:\n                                j++;\n                                break;\n                        }\n                    }\n                    break argumentLoop;\n                case ' ':\n                case '\\t':\n                    if (escaped) {\n                        // consider there to be a space only if an argument\n                        // is not spanning multiple lines\n                        if (argStart !== -1) {\n                            spaced = true;\n                        }\n                    }\n                    else if (argStart !== -1) {\n                        args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i))));\n                        argStart = -1;\n                    }\n                    break;\n                case '\\r':\n                    // offset one more for \\r\\n\n                    i++;\n                case '\\n':\n                    spaced = false;\n                    break;\n                case '#':\n                    if (escaped) {\n                        // a newline was escaped and now there's a comment\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    spaced = false;\n                                    continue argumentLoop;\n                            }\n                        }\n                        // went to the end without finding a newline,\n                        // the comment was the last line in the instruction,\n                        // just stop parsing, create an argument if needed\n                        if (argStart !== -1) {\n                            let value = content.substring(argStart, mark);\n                            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n                            argStart = -1;\n                        }\n                        break argumentLoop;\n                    }\n                    else if (argStart === -1) {\n                        argStart = i;\n                    }\n                    break;\n                default:\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    escaped = false;\n                    if (argStart === -1) {\n                        argStart = i;\n                    }\n                    // variable detected\n                    if (char === '$' && content.charAt(i + 1) === '{') {\n                        let singleQuotes = false;\n                        let doubleQuotes = false;\n                        let escaped = false;\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case this.escapeChar:\n                                    escaped = true;\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    break;\n                                case '\\'':\n                                    singleQuotes = !singleQuotes;\n                                    escaped = false;\n                                    break;\n                                case '\"':\n                                    doubleQuotes = !doubleQuotes;\n                                    escaped = false;\n                                    break;\n                                case ' ':\n                                case '\\t':\n                                    if (escaped || singleQuotes || doubleQuotes) {\n                                        break;\n                                    }\n                                    i = j - 1;\n                                    continue argumentLoop;\n                                case '}':\n                                    i = j;\n                                    continue argumentLoop;\n                                default:\n                                    escaped = false;\n                                    break;\n                            }\n                        }\n                        break argumentLoop;\n                    }\n                    break;\n            }\n        }\n        if (argStart !== -1 && argStart !== content.length) {\n            let end = endingEscape ? content.length - 1 : content.length;\n            let value = content.substring(argStart, end);\n            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + end))));\n        }\n        return args;\n    }\n    createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start) {\n        if (argStart !== -1) {\n            args.push(new argument_1.Argument(content.substring(argStart, mark), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n        }\n    }\n}\nexports.PropertyInstruction = PropertyInstruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cmd = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Cmd extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Cmd = Cmd;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Copy = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Copy extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getFromFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"from\" ? flags[0] : null;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */\n    getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Copy = Copy;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Env = void 0;\nconst propertyInstruction_1 = require(\"../propertyInstruction\");\nclass Env extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Env = Env;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Entrypoint = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Entrypoint extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Entrypoint = Entrypoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.From = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst modifiableInstruction_1 = require(\"../modifiableInstruction\");\nclass From extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getImage() {\n        return this.getRangeContent(this.getImageRange());\n    }\n    /**\n     * Returns the name of the image that will be used as the base image.\n     *\n     * @return the base image's name, or null if unspecified\n     */\n    getImageName() {\n        return this.getRangeContent(this.getImageNameRange());\n    }\n    /**\n     * Returns the range that covers the name of the image used by\n     * this instruction.\n     *\n     * @return the range of the name of this instruction's argument,\n     *         or null if no image has been specified\n     */\n    getImageNameRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let registryRange = this.getRegistryRange();\n            if (registryRange) {\n                range.start = this.document.positionAt(this.document.offsetAt(registryRange.end) + 1);\n            }\n            let tagRange = this.getImageTagRange();\n            let digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) {\n                    range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n                }\n            }\n            else {\n                range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            }\n            return range;\n        }\n        return null;\n    }\n    /**\n     * Returns the range that covers the image argument of this\n     * instruction. This includes the tag or digest of the image if\n     * it has been specified by the instruction.\n     *\n     * @return the range of the image argument, or null if no image\n     *         has been specified\n     */\n    getImageRange() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0].getRange() : null;\n    }\n    getImageTag() {\n        return this.getRangeContent(this.getImageTagRange());\n    }\n    /**\n     * Returns the range in the document that the tag of the base\n     * image encompasses.\n     *\n     * @return the base image's tag's range in the document, or null\n     *         if no tag has been specified\n     */\n    getImageTagRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const rangeStartOffset = this.document.offsetAt(range.start);\n            const content = this.getRangeContent(range);\n            const atIndex = this.indexOf(rangeStartOffset, content, '@');\n            const slashIndex = content.indexOf('/');\n            if (atIndex === -1) {\n                const colonIndex = this.lastIndexOf(rangeStartOffset, content, ':');\n                if (colonIndex > slashIndex) {\n                    return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + colonIndex + 1, range.end.line, range.end.character);\n                }\n            }\n            const subcontent = content.substring(0, atIndex);\n            const subcolonIndex = subcontent.indexOf(':');\n            if (subcolonIndex === -1) {\n                return null;\n            }\n            if (slashIndex === -1) {\n                // slash not found suggests no registry and no namespace defined\n                return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + atIndex));\n            }\n            // both colon and slash found, check if it is a port\n            if (subcolonIndex < slashIndex) {\n                return null;\n            }\n            return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + subcontent.length));\n        }\n        return null;\n    }\n    getImageDigest() {\n        return this.getRangeContent(this.getImageDigestRange());\n    }\n    /**\n     * Returns the range in the document that the digest of the base\n     * image encompasses.\n     *\n     * @return the base image's digest's range in the document, or null\n     *         if no digest has been specified\n     */\n    getImageDigestRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let content = this.getRangeContent(range);\n            let index = this.lastIndexOf(this.document.offsetAt(range.start), content, '@');\n            if (index !== -1) {\n                return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + index + 1, range.end.line, range.end.character);\n            }\n        }\n        return null;\n    }\n    indexOf(documentOffset, content, searchString) {\n        let index = content.indexOf(searchString);\n        const variables = this.getVariables();\n        for (let i = 0; i < variables.length; i++) {\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                const offset = this.document.offsetAt(variableRange.end) - documentOffset;\n                const substring = content.substring(offset);\n                const subIndex = substring.indexOf(searchString);\n                if (subIndex === -1) {\n                    return -1;\n                }\n                index = subIndex + offset;\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    lastIndexOf(documentOffset, content, searchString) {\n        let index = content.lastIndexOf(searchString);\n        const variables = this.getVariables();\n        for (let i = 0; i < variables.length; i++) {\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                index = content.substring(0, index).lastIndexOf(searchString);\n                if (index === -1) {\n                    return -1;\n                }\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    getRegistry() {\n        return this.getRangeContent(this.getRegistryRange());\n    }\n    getRegistryRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const tagRange = this.getImageTagRange();\n            const digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) {\n                    range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n                }\n            }\n            else {\n                range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            }\n            const content = this.getRangeContent(range);\n            const rangeStart = this.document.offsetAt(range.start);\n            const startingSlashIndex = this.indexOf(rangeStart, content, '/');\n            if (startingSlashIndex === -1) {\n                return null;\n            }\n            const portIndex = this.indexOf(rangeStart, content, ':');\n            const dotIndex = this.indexOf(rangeStart, content, '.');\n            // hostname detected\n            if (portIndex !== -1 || dotIndex !== -1) {\n                return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n            }\n            const registry = content.substring(0, startingSlashIndex);\n            // localhost registry detected\n            if (registry === 'localhost') {\n                return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n            }\n        }\n        return null;\n    }\n    getBuildStage() {\n        let range = this.getBuildStageRange();\n        return range === null ? null : this.getRangeContent(range);\n    }\n    getBuildStageRange() {\n        let args = this.getArguments();\n        if (args.length > 2 && args[1].getValue().toUpperCase() === \"AS\") {\n            return args[2].getRange();\n        }\n        return null;\n    }\n    getPlatformFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"platform\" ? flags[0] : null;\n    }\n}\nexports.From = From;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Healthcheck = void 0;\nconst modifiableInstruction_1 = require(\"../modifiableInstruction\");\nclass Healthcheck extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        argument = argument.toUpperCase();\n        return argument === \"CMD\" || argument === \"NONE\";\n    }\n    getSubcommand() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0] : null;\n    }\n}\nexports.Healthcheck = Healthcheck;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Label = void 0;\nconst propertyInstruction_1 = require(\"../propertyInstruction\");\nconst util_1 = require(\"../util\");\nclass Label extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getVariables() {\n        const variables = super.getVariables();\n        const properties = this.getProperties();\n        // iterate over all of this LABEL's properties\n        for (const property of properties) {\n            const value = property.getUnescapedValue();\n            // check if the value is contained in single quotes,\n            // single quotes would indicate a literal value\n            if (value !== null && value.length > 2 && value.charAt(0) === '\\'' && value.charAt(value.length - 1) === '\\'') {\n                const range = property.getValueRange();\n                for (let i = 0; i < variables.length; i++) {\n                    // if a variable is in a single quote, remove it from the list\n                    if (util_1.Util.isInsideRange(variables[i].getRange().start, range)) {\n                        variables.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n        return variables;\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Label = Label;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Onbuild = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst parser_1 = require(\"../parser\");\nconst instruction_1 = require(\"../instruction\");\nclass Onbuild extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getTrigger() {\n        let trigger = this.getTriggerWord();\n        return trigger === null ? null : trigger.toUpperCase();\n    }\n    getTriggerWord() {\n        return this.getRangeContent(this.getTriggerRange());\n    }\n    getTriggerRange() {\n        let args = this.getArguments();\n        return args.length > 0 ? args[0].getRange() : null;\n    }\n    getTriggerInstruction() {\n        let triggerRange = this.getTriggerRange();\n        if (triggerRange === null) {\n            return null;\n        }\n        let args = this.getArguments();\n        return parser_1.Parser.createInstruction(this.document, this.dockerfile, this.escapeChar, vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end), this.getTriggerWord(), triggerRange);\n    }\n}\nexports.Onbuild = Onbuild;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Run = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Run extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */\n    getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Run = Run;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Shell = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Shell extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Shell = Shell;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Stopsignal = void 0;\nconst instruction_1 = require(\"../instruction\");\nclass Stopsignal extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Stopsignal = Stopsignal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Workdir = void 0;\nconst instruction_1 = require(\"../instruction\");\nclass Workdir extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    /**\n     * Returns the path that has been defined. Note that this path may\n     * be absolute or relative depending on what was written in the\n     * instruction.\n     *\n     * @return the working directory's path, or null if this\n     *         instruction has no arguments\n     */\n    getPath() {\n        return this.getArgumentsContent();\n    }\n    /**\n     * Returns the absolute path that this instruction resolves to. The\n     * function will inspect prior WORKDIR instructions in the current\n     * image or another build stage in the Dockerfile to try to\n     * determine this.\n     *\n     * @return the absolute path of the working directory, or null if\n     *         this instruction has no arguments, or undefined if it\n     *         cannot be determined because only relative paths could be\n     *         found\n     */\n    getAbsolutePath() {\n        const path = this.getPath();\n        if (path === null || path.startsWith(\"/\")) {\n            return path;\n        }\n        const startLine = this.getRange().start.line;\n        const hierarchy = this.dockerfile.getStageHierarchy(startLine);\n        for (let i = hierarchy.length - 1; i >= 0; i--) {\n            const workdirs = hierarchy[i].getWORKDIRs();\n            for (let j = workdirs.length - 1; j >= 0; j--) {\n                if (workdirs[j].getRange().start.line < startLine) {\n                    const parent = workdirs[j].getAbsolutePath();\n                    if (parent === undefined || parent === null) {\n                        return undefined;\n                    }\n                    return parent.endsWith(\"/\") ? parent + path : parent + \"/\" + path;\n                }\n            }\n        }\n        return undefined;\n    }\n}\nexports.Workdir = Workdir;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.User = void 0;\nconst instruction_1 = require(\"../instruction\");\nclass User extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.User = User;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Volume = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Volume extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Volume = Volume;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dockerfile = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst ast = require(\"./main\");\nconst imageTemplate_1 = require(\"./imageTemplate\");\nconst from_1 = require(\"./instructions/from\");\nconst util_1 = require(\"./util\");\nconst main_1 = require(\"./main\");\nclass Dockerfile extends imageTemplate_1.ImageTemplate {\n    constructor(document) {\n        super();\n        this.initialInstructions = new imageTemplate_1.ImageTemplate();\n        this.buildStages = [];\n        this.directives = [];\n        /**\n         * Whether a FROM instruction has been added to this Dockerfile or not.\n         */\n        this.foundFrom = false;\n        this.document = document;\n    }\n    getEscapeCharacter() {\n        for (const directive of this.directives) {\n            if (directive.getDirective() === ast.Directive.escape) {\n                const value = directive.getValue();\n                if (value === '\\\\' || value === '`') {\n                    return value;\n                }\n            }\n        }\n        return '\\\\';\n    }\n    getInitialARGs() {\n        return this.initialInstructions.getARGs();\n    }\n    getContainingImage(position) {\n        let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), this.document.positionAt(this.document.getText().length));\n        if (!util_1.Util.isInsideRange(position, range)) {\n            // not inside the document, invalid position\n            return null;\n        }\n        if (this.initialInstructions.getComments().length > 0 || this.initialInstructions.getInstructions().length > 0) {\n            if (util_1.Util.isInsideRange(position, this.initialInstructions.getRange())) {\n                return this.initialInstructions;\n            }\n        }\n        for (const buildStage of this.buildStages) {\n            if (util_1.Util.isInsideRange(position, buildStage.getRange())) {\n                return buildStage;\n            }\n        }\n        return this;\n    }\n    addInstruction(instruction) {\n        if (instruction.getKeyword() === main_1.Keyword.FROM) {\n            this.currentBuildStage = new imageTemplate_1.ImageTemplate();\n            this.buildStages.push(this.currentBuildStage);\n            this.foundFrom = true;\n        }\n        else if (!this.foundFrom) {\n            this.initialInstructions.addInstruction(instruction);\n        }\n        if (this.foundFrom) {\n            this.currentBuildStage.addInstruction(instruction);\n        }\n        super.addInstruction(instruction);\n    }\n    setDirectives(directives) {\n        this.directives = directives;\n    }\n    getDirective() {\n        return this.directives.length === 0 ? null : this.directives[0];\n    }\n    getDirectives() {\n        return this.directives;\n    }\n    resolveVariable(variable, line) {\n        for (let from of this.getFROMs()) {\n            let range = from.getRange();\n            if (range.start.line <= line && line <= range.end.line) {\n                // resolve the FROM variable against the initial ARGs\n                let initialARGs = new imageTemplate_1.ImageTemplate();\n                for (let instruction of this.initialInstructions.getARGs()) {\n                    initialARGs.addInstruction(instruction);\n                }\n                return initialARGs.resolveVariable(variable, line);\n            }\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) {\n            return undefined;\n        }\n        let resolvedVariable = image.resolveVariable(variable, line);\n        if (resolvedVariable === null) {\n            // refers to an uninitialized ARG variable,\n            // try resolving it against the initial ARGs then\n            let initialARGs = new imageTemplate_1.ImageTemplate();\n            for (let instruction of this.initialInstructions.getARGs()) {\n                initialARGs.addInstruction(instruction);\n            }\n            return initialARGs.resolveVariable(variable, line);\n        }\n        return resolvedVariable;\n    }\n    getAvailableVariables(currentLine) {\n        if (this.getInstructionAt(currentLine) instanceof from_1.From) {\n            let variables = [];\n            for (let arg of this.getInitialARGs()) {\n                let property = arg.getProperty();\n                if (property) {\n                    variables.push(property.getName());\n                }\n            }\n            return variables;\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(currentLine, 0));\n        return image ? image.getAvailableVariables(currentLine) : [];\n    }\n    getParentStage(image) {\n        const templateFrom = image.getFROM();\n        const imageName = templateFrom === null ? null : templateFrom.getImageName();\n        if (imageName === null) {\n            return null;\n        }\n        for (const from of this.getFROMs()) {\n            if (from.getBuildStage() === imageName) {\n                const range = from.getRange();\n                // on the same line then it's an image that shares the name as the build stage\n                if (range.start.line === templateFrom.getRange().start.line) {\n                    return null;\n                }\n                return this.getContainingImage(range.start);\n            }\n        }\n        return null;\n    }\n    getStageHierarchy(line) {\n        const image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) {\n            return [];\n        }\n        const stages = [image];\n        let stage = this.getParentStage(image);\n        while (stage !== null) {\n            stages.splice(0, 0, stage);\n            stage = this.getParentStage(stage);\n        }\n        return stages;\n    }\n    getAvailableWorkingDirectories(line) {\n        const availableDirectories = new Set();\n        for (const image of this.getStageHierarchy(line)) {\n            for (const workdir of image.getWORKDIRs()) {\n                if (workdir.getRange().end.line < line) {\n                    let directory = workdir.getAbsolutePath();\n                    if (directory !== undefined && directory !== null) {\n                        if (!directory.endsWith(\"/\")) {\n                            directory += \"/\";\n                        }\n                        availableDirectories.add(directory);\n                    }\n                }\n            }\n        }\n        return Array.from(availableDirectories);\n    }\n    /**\n     * Internally reorganize the comments in the Dockerfile and allocate\n     * them to the relevant build stages that they belong to.\n     */\n    organizeComments() {\n        const comments = this.getComments();\n        for (let i = 0; i < comments.length; i++) {\n            if (util_1.Util.isInsideRange(comments[i].getRange().end, this.initialInstructions.getRange())) {\n                this.initialInstructions.addComment(comments[i]);\n            }\n            else {\n                for (const buildStage of this.buildStages) {\n                    if (util_1.Util.isInsideRange(comments[i].getRange().start, buildStage.getRange())) {\n                        buildStage.addComment(comments[i]);\n                    }\n                }\n            }\n        }\n    }\n    getRange() {\n        const comments = this.getComments();\n        const instructions = this.getInstructions();\n        let range = null;\n        if (comments.length === 0) {\n            if (instructions.length > 0) {\n                range = vscode_languageserver_types_1.Range.create(instructions[0].getRange().start, instructions[instructions.length - 1].getRange().end);\n            }\n        }\n        else if (instructions.length === 0) {\n            range = vscode_languageserver_types_1.Range.create(comments[0].getRange().start, comments[comments.length - 1].getRange().end);\n        }\n        else {\n            const commentStart = comments[0].getRange().start;\n            const commentEnd = comments[comments.length - 1].getRange().end;\n            const instructionStart = instructions[0].getRange().start;\n            const instructionEnd = instructions[instructions.length - 1].getRange().end;\n            if (commentStart.line < instructionStart.line) {\n                if (commentEnd.line < instructionEnd.line) {\n                    range = vscode_languageserver_types_1.Range.create(commentStart, instructionEnd);\n                }\n                range = vscode_languageserver_types_1.Range.create(commentStart, commentEnd);\n            }\n            else if (commentEnd.line < instructionEnd.line) {\n                range = vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n            }\n            else {\n                range = vscode_languageserver_types_1.Range.create(instructionStart, commentEnd);\n            }\n        }\n        if (range === null) {\n            if (this.directives.length === 0) {\n                return null;\n            }\n            return this.directives[0].getRange();\n        }\n        else if (this.directives.length === 0) {\n            return range;\n        }\n        return vscode_languageserver_types_1.Range.create(this.directives[0].getRange().start, range.end);\n    }\n}\nexports.Dockerfile = Dockerfile;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageTemplate = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst arg_1 = require(\"./instructions/arg\");\nconst cmd_1 = require(\"./instructions/cmd\");\nconst copy_1 = require(\"./instructions/copy\");\nconst env_1 = require(\"./instructions/env\");\nconst entrypoint_1 = require(\"./instructions/entrypoint\");\nconst from_1 = require(\"./instructions/from\");\nconst healthcheck_1 = require(\"./instructions/healthcheck\");\nconst onbuild_1 = require(\"./instructions/onbuild\");\nconst util_1 = require(\"./util\");\nconst workdir_1 = require(\"./instructions/workdir\");\nclass ImageTemplate {\n    constructor() {\n        this.comments = [];\n        this.instructions = [];\n    }\n    addComment(comment) {\n        this.comments.push(comment);\n    }\n    getComments() {\n        return this.comments;\n    }\n    addInstruction(instruction) {\n        this.instructions.push(instruction);\n    }\n    getInstructions() {\n        return this.instructions;\n    }\n    getInstructionAt(line) {\n        for (let instruction of this.instructions) {\n            if (util_1.Util.isInsideRange(vscode_languageserver_types_1.Position.create(line, 0), instruction.getRange())) {\n                return instruction;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets all the ARG instructions that are defined in this image.\n     */\n    getARGs() {\n        let args = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof arg_1.Arg) {\n                args.push(instruction);\n            }\n        }\n        return args;\n    }\n    /**\n     * Gets all the CMD instructions that are defined in this image.\n     */\n    getCMDs() {\n        let cmds = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof cmd_1.Cmd) {\n                cmds.push(instruction);\n            }\n        }\n        return cmds;\n    }\n    /**\n     * Gets all the COPY instructions that are defined in this image.\n     */\n    getCOPYs() {\n        let copies = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof copy_1.Copy) {\n                copies.push(instruction);\n            }\n        }\n        return copies;\n    }\n    /**\n     * Gets all the ENTRYPOINT instructions that are defined in this image.\n     */\n    getENTRYPOINTs() {\n        let froms = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof entrypoint_1.Entrypoint) {\n                froms.push(instruction);\n            }\n        }\n        return froms;\n    }\n    /**\n     * Gets all the ENV instructions that are defined in this image.\n     */\n    getENVs() {\n        let args = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof env_1.Env) {\n                args.push(instruction);\n            }\n        }\n        return args;\n    }\n    getFROM() {\n        for (const instruction of this.instructions) {\n            if (instruction instanceof from_1.From) {\n                return instruction;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets all the FROM instructions that are defined in this image.\n     */\n    getFROMs() {\n        let froms = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof from_1.From) {\n                froms.push(instruction);\n            }\n        }\n        return froms;\n    }\n    /**\n     * Gets all the HEALTHCHECK instructions that are defined in this image.\n     */\n    getHEALTHCHECKs() {\n        let froms = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof healthcheck_1.Healthcheck) {\n                froms.push(instruction);\n            }\n        }\n        return froms;\n    }\n    getWORKDIRs() {\n        const workdirs = [];\n        for (const instruction of this.instructions) {\n            if (instruction instanceof workdir_1.Workdir) {\n                workdirs.push(instruction);\n            }\n        }\n        return workdirs;\n    }\n    getOnbuildTriggers() {\n        let triggers = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof onbuild_1.Onbuild) {\n                let trigger = instruction.getTriggerInstruction();\n                if (trigger) {\n                    triggers.push(trigger);\n                }\n            }\n        }\n        return triggers;\n    }\n    getAvailableVariables(currentLine) {\n        const variables = [];\n        for (const arg of this.getARGs()) {\n            if (arg.isBefore(currentLine)) {\n                const property = arg.getProperty();\n                if (property) {\n                    const variable = property.getName();\n                    if (variables.indexOf(variable) === -1) {\n                        variables.push(variable);\n                    }\n                }\n            }\n        }\n        for (const env of this.getENVs()) {\n            if (env.isBefore(currentLine)) {\n                for (const property of env.getProperties()) {\n                    const variable = property.getName();\n                    if (variables.indexOf(variable) === -1) {\n                        variables.push(variable);\n                    }\n                }\n            }\n        }\n        return variables;\n    }\n    /**\n     * Resolves a variable with the given name at the specified line\n     * to its value. If null is returned, then the variable has been\n     * defined but no value was given. If undefined is returned, then\n     * a variable with the given name has not been defined yet as of\n     * the given line.\n     *\n     * @param variable the name of the variable to resolve\n     * @param line the line number that the variable is on, zero-based\n     * @return the value of the variable as defined by an ARG or ENV\n     *         instruction, or null if no value has been specified, or\n     *         undefined if a variable with the given name has not\n     *         been defined\n     */\n    resolveVariable(variable, line) {\n        let envs = this.getENVs();\n        for (let i = envs.length - 1; i >= 0; i--) {\n            if (envs[i].isBefore(line)) {\n                for (let property of envs[i].getProperties()) {\n                    if (property.getName() === variable) {\n                        return property.getValue();\n                    }\n                }\n            }\n        }\n        let args = this.getARGs();\n        for (let i = args.length - 1; i >= 0; i--) {\n            if (args[i].isBefore(line)) {\n                let property = args[i].getProperty();\n                if (property && property.getName() === variable) {\n                    return property.getValue();\n                }\n            }\n        }\n        return undefined;\n    }\n    getRange() {\n        const instructions = this.getInstructions();\n        if (instructions.length === 0) {\n            // all templates should have instructions, this only happens for\n            // the initial set of instruction\n            return vscode_languageserver_types_1.Range.create(0, 0, 0, 0);\n        }\n        const instructionStart = instructions[0].getRange().start;\n        const instructionEnd = instructions[instructions.length - 1].getRange().end;\n        return vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n    }\n    contains(position) {\n        const range = this.getRange();\n        if (range === null) {\n            return false;\n        }\n        return util_1.Util.isInsideRange(position, range);\n    }\n}\nexports.ImageTemplate = ImageTemplate;\n","import {\n    debug as coreDebug,\n    error as coreError,\n    info as coreInfo,\n    notice as coreNotice,\n    warning as coreWarning,\n    isDebug as coreIsDebug,\n    startGroup as coreStartGroup,\n    endGroup as coreEndGroup,\n    group as coreGroup,\n} from \"@actions/core/lib/core.js\";\nimport { AsyncLocalStorage } from \"async_hooks\";\n\nlet verboseEnabled = false;\n\n// Async context for group prefixes\nconst groupContext = new AsyncLocalStorage<string>();\n\nfunction callCore(fn: () => void, fallback: () => void) {\n    try {\n        fn();\n    } catch (error) {\n        fallback();\n    }\n}\n\nconst isActionsRuntime = process.env.GITHUB_ACTIONS === \"true\";\n\nfunction formatMessageForConsole(message: string): string {\n    const groupName = groupContext.getStore();\n    return groupName ? `[${groupName}] ${message}` : message;\n}\n\nexport function configureLogger(options: { verbose: boolean }) {\n    verboseEnabled = options.verbose;\n    if (verboseEnabled) {\n        logVerbose(\"Verbose logging enabled\");\n    } else {\n        logDebug(\"Verbose logging disabled\");\n    }\n}\n\nexport function logInfo(message: string) {\n    callCore(\n        () => coreInfo(message),\n        () => console.log(formatMessageForConsole(message))\n    );\n}\n\nexport function logNotice(message: string) {\n    callCore(\n        () => coreNotice(message),\n        () => console.log(formatMessageForConsole(message))\n    );\n}\n\nexport function logWarning(message: string) {\n    callCore(\n        () => coreWarning(message),\n        () => console.warn(formatMessageForConsole(message))\n    );\n}\n\nexport function logError(message: string | Error) {\n    const text = message instanceof Error ? message.message : message;\n    callCore(\n        () => coreError(text),\n        () => console.error(formatMessageForConsole(text))\n    );\n}\n\nexport function logDebug(message: string) {\n    callCore(\n        () => coreDebug(message),\n        () => console.debug(formatMessageForConsole(message))\n    );\n}\n\nexport function logVerbose(message: string) {\n    if (!verboseEnabled) {\n        return;\n    }\n\n    const verboseMessage = `[verbose] ${message}`;\n\n    if (isActionsRuntime) {\n        callCore(\n            () => coreDebug(verboseMessage),\n            () => console.debug(formatMessageForConsole(verboseMessage))\n        );\n        if (!coreIsDebug()) {\n            callCore(\n                () => coreInfo(verboseMessage),\n                () => console.log(formatMessageForConsole(verboseMessage))\n            );\n        }\n    } else {\n        console.debug(formatMessageForConsole(verboseMessage));\n    }\n}\n\nasync function createNativeGroup<T>(\n    name: string,\n    fn: () => Promise<T>\n): Promise<T> {\n  return groupContext.run(name, fn);\n}\n\nexport async function logGroup<T>(\n    name: string,\n    fn: () => Promise<T>\n): Promise<T> {\n    if (isActionsRuntime) {\n        try {\n            // In Actions environment, use core.group without context (Actions handles grouping)\n            return await coreGroup(name, fn);\n        } catch (error) {\n            // Fallback to manual wrapper if core.group fails\n            return await createNativeGroup(name, fn);\n        }\n    } else {\n        // Non-Actions environment - use native wrapper with context\n        return await createNativeGroup(name, fn);\n    }\n}\n\nexport function isVerboseEnabled() {\n    return verboseEnabled;\n}\n","import spawnPlease from 'spawn-please'\nimport cp, { type ChildProcess } from 'child_process';\nimport { logError, logVerbose } from './logger.js';\n\nexport async function run(command: string, args: string[]) {\n    const commandString = formatCommand(command, args);\n    logVerbose(`Executing command: ${commandString}`);\n    try {\n        const result = await spawnPlease(command, args);\n        logVerbose(`Command succeeded: ${commandString}`);\n        return result;\n    } catch (error) {\n        logError(`Error running command: ${commandString}`);\n        if (error instanceof Error && error.stack) {\n            logVerbose(error.stack);\n        }\n        throw error;\n    }\n}\n\nexport async function runPiped([command1, args1]: [string, string[]], [command2, args2]: [string, string[]]) {\n    const commandString = `${formatCommand(command1, args1)} | ${formatCommand(command2, args2)}`;\n    logVerbose(`Executing piped command: ${commandString}`);\n    const cp1 = cp.spawn(command1, args1, { stdio: ['inherit', 'pipe', 'inherit'] });\n    const cp2 = cp.spawn(command2, args2, { stdio: ['pipe', 'inherit', 'inherit'] });\n\n    cp1.stdout.pipe(cp2.stdin);\n\n    await Promise.all([\n        assertSuccess(cp1, formatCommand(command1, args1)),\n        assertSuccess(cp2, formatCommand(command2, args2)),\n    ]);\n\n    logVerbose(`Piped command succeeded: ${commandString}`);\n}\n\nexport async function runWithInput(command: string, args: string[], input: string) {\n    const commandString = formatCommand(command, args);\n    logVerbose(`Executing command with stdin: ${commandString}`);\n    const child = cp.spawn(command, args, { stdio: ['pipe', 'inherit', 'inherit'] });\n\n    child.stdin.on('error', (error) => {\n        logError(`Failed to write to stdin for ${commandString}: ${error}`);\n    });\n\n    child.stdin.write(input);\n    child.stdin.end();\n\n    try {\n        await assertSuccess(child, commandString);\n        logVerbose(`Command with stdin succeeded: ${commandString}`);\n    } catch (error) {\n        if (error instanceof Error && error.stack) {\n            logVerbose(error.stack);\n        }\n        throw error;\n    }\n}\n\nfunction assertSuccess(cp: ChildProcess, command: string) {\n    return new Promise<void>((resolve, reject) => {\n        cp.on('error', (error) => {\n            logError(`Process error: ${command}`);\n            if (error instanceof Error && error.stack) {\n                logVerbose(error.stack);\n            }\n            reject(error);\n        });\n        cp.on('close', (code) => {\n            if (code !== 0) {\n                const error = new Error(`process exited with code ${code}`);\n                logError(`${command} failed: ${error.message}`);\n                reject(error);\n            }\n            logVerbose(`Process exited successfully: ${command}`);\n            resolve();\n        });\n    });\n}\n\nfunction formatCommand(command: string, args: string[]) {\n    return [command, ...args].join(' ').trim();\n}\n","const spawn = require('cross-spawn')\n\n/** Spawns a child process, as long as you ask nicely.\n * \n * @param {string} command - The shell command to execute.\n * @param {string[]} [args] - An array of arguments that are given after the command.\n * @param {{ rejectOnError?: boolean, stdin?: string, stderr?: (data: string) => void, stdout?: (data: string) => void }} [options] - Options.\n * @param {any} [spawnOptions] - Options that are passed directly to child_process.spawn. Also supports stdin: string.\n * @returns {Promise<{ stdout: string, stderr: string }>}\n */\nconst spawnPlease = (command, args, options={}, spawnOptions={}) => {\n  // defaults\n  if (options.rejectOnError === undefined) {\n    options.rejectOnError = true\n  }\n\n  let stdout = ''\n  let stderr = ''\n  const child = spawn(command, args, spawnOptions)\n\n  return new Promise((resolve, reject) => {\n    if (options.stdin !== undefined && options.stdin != null) {\n      child.stdin.write(options.stdin)\n    }\n    child.stdin.end()\n\n    child.stdout.on('data', data => {\n      stdout += data\n      if (options.stdout) options.stdout(data)\n    })\n\n    child.stderr.on('data', data => {\n      stderr += data\n      if (options.stderr) options.stderr(data)\n    })\n\n    if (options.rejectOnError) {\n      child.addListener('error', reject)\n    }\n\n    child.on('close', code => {\n      if (code !== 0 && options.rejectOnError) {\n        reject(stderr)\n      } else {\n        resolve({ stdout, stderr })\n      }\n    })\n  })\n}\n\nmodule.exports = spawnPlease\n","'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n","'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n","const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n","'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n","'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n","'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n","'use strict';\nmodule.exports = /^#!(.*)/;\n","'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n","import { promises as fs } from 'fs';\nimport path from 'path';\nimport { CacheOptions, Opts, getCacheMap, getMountArgsString, getTargetPath, getBuilder } from './opts.js';\nimport { run, runWithInput, runPiped } from './run.js';\nimport { logError, logGroup, logInfo, logVerbose, logWarning } from './logger.js';\n\nasync function extractCachesBatch(cacheMap: Record<string, CacheOptions>, scratchDir: string, containerImage: string, builder: string) {\n    return await logGroup(`Extract all caches in batch`, async () => {\n        const imageTag = `dance:extract-batch`;\n        const containerName = `cache-container-batch`;\n\n        logInfo(`Preparing batch cache extraction for ${Object.keys(cacheMap).length} cache(s) using builder '${builder}'.`);\n\n        // Prepare Timestamp for Layer Cache Busting\n        const date = new Date().toISOString();\n\n        await fs.rm(scratchDir, { recursive: true, force: true });\n        await fs.mkdir(scratchDir, { recursive: true });\n        await fs.writeFile(path.join(scratchDir, 'buildstamp'), date);\n\n        // Prepare Dancefile to Access All Caches\n        const cacheEntries = Object.entries(cacheMap);\n        const mountArgs = cacheEntries.map(([_, cacheOptions]) => getMountArgsString(cacheOptions)).join(' ');\n        \n        // Create RUN commands to copy each cache to a numbered subdirectory\n        const copyCommands = cacheEntries.map(([cacheSource, cacheOptions], index) => {\n            const targetPath = getTargetPath(cacheOptions);\n            const cacheId = `cache-${index}`;\n            return `mkdir -p \"/var/dance-cache/${cacheId}/\" && cp -p -R ${targetPath}/. \"/var/dance-cache/${cacheId}/\" || true`;\n        }).join(' && ');\n\n        const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    ${copyCommands}\n`;\n        logVerbose(`Dancefile for batch extraction generated:\\n${dancefileContent}`);\n\n        // Extract Data into Docker Image\n        await runWithInput('docker', ['buildx', 'build', '--builder', builder, '-f', '-', '--tag', imageTag, '--load', scratchDir], dancefileContent);\n\n        // Create Extraction Container\n        try {\n            await run('docker', ['rm', '-f', containerName]);\n        } catch (error) {\n            // Ignore error if container does not exist\n        }\n        await run('docker', ['create', '-ti', '--name', containerName, imageTag]);\n\n        // Extract all caches in one operation\n        await runPiped(\n            ['docker', ['cp', '-L', `${containerName}:/var/dance-cache`, '-']],\n            ['tar', ['-H', 'posix', '-x', '-C', scratchDir]]\n        );\n\n        // Move each cache from scratch to its target location\n        for (const [cacheSource, _] of cacheEntries) {\n            const index = cacheEntries.findIndex(([source, _]) => source === cacheSource);\n            const cacheId = `cache-${index}`;\n            const sourcePath = path.join(scratchDir, 'dance-cache', cacheId);\n\n            await fs.mkdir(path.dirname(cacheSource), { recursive: true });\n            \n            try {\n                await run('sudo', ['rm', '-rf', cacheSource]);\n            } catch (error) {\n                logWarning(`Failed to clean existing cache directory '${cacheSource}' with sudo. Attempting fallback without sudo.`);\n                try {\n                    await fs.rm(cacheSource, { recursive: true, force: true });\n                } catch (cleanupError) {\n                    logError(`Unable to remove existing cache directory '${cacheSource}': ${cleanupError}`);\n                    throw cleanupError;\n                }\n            }\n\n            try {\n                await fs.rename(sourcePath, cacheSource);\n                logInfo(`Cache extraction completed for source '${cacheSource}'.`);\n            } catch (error) {\n                if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n                    await fs.mkdir(cacheSource, { recursive: true });\n                    logVerbose(`Cache extraction produced no files for '${cacheSource}'. Directory created.`);\n                } else {\n                    logError(`Failed to move extracted cache from '${sourcePath}' to '${cacheSource}': ${error}`);\n                    throw error;\n                }\n            }\n        }\n\n        // Clean up container and scratch directory\n        try {\n            await run('docker', ['rm', '-f', containerName]);\n        } catch (error) {\n            // Ignore cleanup errors\n            logVerbose(`Failed to clean up container '${containerName}': ${error}`);\n        }\n\n        try {\n            await fs.rm(scratchDir, { recursive: true, force: true });\n        } catch (error) {\n            // Ignore cleanup errors\n            logVerbose(`Failed to clean up scratch directory '${scratchDir}': ${error}`);\n        }\n        \n        logInfo(`Batch cache extraction completed for ${Object.keys(cacheMap).length} cache(s).`);\n    });\n}\n\nexport async function extractCaches(opts: Opts) {\n    if (opts[\"skip-extraction\"]) {\n        logInfo(\"skip-extraction is set. Skipping extraction step...\");\n        return;\n    }\n\n    const cacheMap = await getCacheMap(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n    const builder = getBuilder(opts);\n\n    // Extract all caches in a single batch operation\n    logInfo(`Extracting ${Object.keys(cacheMap).length} cache mount(s) using image '${containerImage}'.`);\n\n    if (Object.keys(cacheMap).length === 0) {\n        logInfo(\"No caches to extract.\");\n        return;\n    }\n\n    await extractCachesBatch(cacheMap, scratchDir, containerImage, builder);\n}\n"],"names":["__parcelExternal0","__parcelExternal1","__parcelExternal2","__parcelExternal3","__parcelExternal4","__parcelExternal5","__parcelExternal6","__parcelExternal7","__parcelExternal8","__parcelExternal9","__parcelExternal10","__parcelExternal11","modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","_fs","_os","_osDefault","interopDefault","_injectCacheJs","_extractCacheJs","_optsJs","_loggerJs","main","args","opts","parseOpts","configureLogger","verbose","help","logInfo","extract","extractCaches","process","undefined","env","GITHUB_STATE","promises","appendFile","default","EOL","injectCaches","argv","catch","logError","String","stack","logVerbose","exit","defineInteropFlag","export","_path","_pathDefault","_runJs","injectCache","cacheSource","cacheOptions","scratchDir","containerImage","builder","logGroup","jobId","createJobId","slug","replace","toLowerCase","slice","unique","Math","random","toString","jobScratchDir","join","imageTag","rm","recursive","force","mkdir","date","Date","toISOString","writeFile","targetPath","getTargetPath","mountArgs","getMountArgsString","ownershipCommand","uid","getUID","gid","getGID","dancefileContent","runWithInput","logNotice","cacheMap","getCacheMap","getBuilder","keys","tasks","entries","map","error","logWarning","Promise","all","_mri","_mriDefault","_coreJs","_dockerfileAst","getInput","string","boolean","alias","warning","JSON","stringify","console","log","getCacheMapFromDockerfile","dockerfilePath","bindRoot","dockerfileContent","readFile","dockerfile","DockerfileParser","parse","run","getInstructions","filter","getKeyword","flag","getFlags","getName","getOption","getValue","target","cacheMapFromDockerfile","e","otherOptions","key","value","toArr","any","Array","isArray","k","arr","arg","val","out","_","j","idx","len","alibi","strict","unknown","defaults","concat","splice","push","charCodeAt","substring","indexOf","repeat","toVal","old","nxt","shift","a","__esModule","exportAll","source","dest","forEach","prototype","hasOwnProperty","enumerable","destName","ExitCode","__createBinding","create","o","m","k2","__setModuleDefault","v","__importStar","mod","result","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","next","rejected","done","adopt","then","apply","getIDToken","getState","saveState","group","endGroup","startGroup","info","notice","debug","isDebug","setFailed","setCommandEcho","setOutput","getBooleanInput","getMultilineInput","addPath","setSecret","exportVariable","command_1","file_command_1","utils_1","os","path","oidc_utils_1","options","toUpperCase","required","trimWhitespace","trim","message","properties","issueCommand","toCommandProperties","issue","convertedVal","toCommandValue","delimiter","commandValue","secret","inputPath","split","trueValue","includes","falseValue","TypeError","stdout","write","enabled","exitCode","Failure","fn","aud","OidcClient","summary_1","summary","summary_2","markdownSummary","command","cmd","Command","constructor","s","cmdStr","CMD_STRING","first","input","annotationProperties","title","file","line","startLine","endLine","col","startColumn","endColumn","fs","filePath","existsSync","appendFileSync","encoding","http_client_1","auth_1","core_1","createHttpClient","allowRetry","maxRetry","HttpClient","BearerCredentialHandler","getRequestToken","allowRetries","maxRetries","token","getIDTokenUrl","runtimeUrl","getCall","id_token_url","_a","httpclient","id_token","getJson","statusCode","audience","encodedAudience","encodeURIComponent","HttpCodes","Headers","MediaTypes","tunnel","http","https","pm","getProxyUrl","serverUrl","proxyUrl","URL","href","HttpRedirectCodes","MovedPermanently","ResourceMoved","SeeOther","TemporaryRedirect","PermanentRedirect","HttpResponseRetryCodes","BadGateway","ServiceUnavailable","GatewayTimeout","RetryableHttpVerbs","HttpClientError","setPrototypeOf","HttpClientResponse","readBody","output","Buffer","alloc","on","chunk","isHttps","requestUrl","parsedUrl","protocol","userAgent","handlers","requestOptions","_ignoreSslError","_allowRedirects","_allowRedirectDowngrade","_maxRedirects","_allowRetries","_maxRetries","_keepAlive","_disposed","ignoreSslError","_socketTimeout","socketTimeout","allowRedirects","allowRedirectDowngrade","maxRedirects","max","keepAlive","additionalHeaders","request","del","post","data","patch","put","head","sendStream","verb","stream","Accept","_getExistingOrDefaultHeader","ApplicationJson","_processResponse","postJson","obj","ContentType","putJson","patchJson","headers","response","_prepareRequest","maxTries","numTries","requestRaw","Unauthorized","authenticationHandler","canHandleAuthentication","handleAuthentication","redirectsRemaining","redirectUrl","parsedRedirectUrl","hostname","header","_performExponentialBackoff","dispose","_agent","destroy","requestRawWithCallback","onResult","socket","byteLength","callbackCalled","handleResult","req","httpModule","msg","sock","setTimeout","end","pipe","getAgent","_getAgent","method","usingSsl","host","port","parseInt","pathname","search","_mergeHeaders","agent","handler","prepareRequest","lowercaseKeys","reduce","c","assign","_default","clientHeader","useProxy","_proxyAgent","maxSockets","globalAgent","tunnelAgent","agentOptions","proxy","username","password","proxyAuth","overHttps","httpsOverHttps","httpsOverHttp","httpOverHttps","httpOverHttp","Agent","rejectUnauthorized","retryNumber","ms","ExponentialBackoffTimeSlice","pow","min","dateTimeDeserializer","isNaN","valueOf","contents","NotFound","deserializeDates","checkBypass","reqUrl","reqPort","noProxy","Number","upperReqHosts","upperNoProxyItem","some","proxyVar","tls","events","util","TunnelingAgent","proxyOptions","defaultMaxSockets","requests","sockets","localAddress","toOptions","pending","onSocket","removeSocket","createSecureSocket","cb","createSocket","hostHeader","getHeader","tlsOptions","mergeOptions","servername","secureSocket","connect","arguments","overrides","keyLen","defaultPort","inherits","EventEmitter","addRequest","onFree","emit","onCloseOrRemove","removeListener","placeholder","connectOptions","connectReq","onConnect","removeAllListeners","useChunkedEncodingByDefault","once","upgrade","nextTick","cause","pos","NODE_DEBUG","test","unshift","BasicCredentialHandler","from","httpClient","requestInfo","objs","PersonalAccessTokenCredentialHandler","SUMMARY_DOCS_URL","SUMMARY_ENV_VAR","os_1","fs_1","access","_summary","_buffer","_filePath","pathFromEnv","constants","R_OK","W_OK","wrap","tag","content","attrs","htmlAttrs","overwrite","writeFunc","emptyBuffer","clear","isEmptyBuffer","addRaw","text","addEOL","addCodeBlock","lang","element","addList","items","ordered","listItems","item","addTable","rows","tableBody","row","cells","cell","colspan","rowspan","addDetails","label","addImage","src","alt","width","height","addHeading","level","allowedTag","addSeparator","addBreak","addQuote","cite","addLink","DefaultVariables","Directive","Keyword","Workdir","Volume","User","Stopsignal","Shell","Run","PropertyInstruction","Onbuild","ModifiableInstruction","Label","JSONInstruction","Heredoc","Healthcheck","From","Env","Entrypoint","Copy","Cmd","Arg","Add","Variable","Property","ParserDirective","Line","Instruction","Flag","Comment","JSONArgument","Argument","argument_1","jsonArgument_1","comment_1","parser_1","flag_1","instruction_1","line_1","parserDirective_1","property_1","variable_1","add_1","arg_1","cmd_1","copy_1","entrypoint_1","env_1","from_1","healthcheck_1","heredoc_1","jsonInstruction_1","label_1","modifiableInstruction_1","onbuild_1","propertyInstruction_1","run_1","shell_1","stopsignal_1","user_1","volume_1","workdir_1","parser","Parser","range","getRange","isAfter","position","start","character","isBefore","jsonRange","getJSONRange","getJSONValue","vscode_languageserver_types_1","util_1","document","getContent","getContentRange","getText","offsetAt","startOffset","raw","Util","isWhitespace","charAt","Range","positionAt","factory","exports1","TextDocument","WorkspaceFolder","InlineCompletionContext","SelectedCompletionInfo","InlineCompletionTriggerKind","InlineCompletionList","InlineCompletionItem","StringValue","InlayHint","InlayHintLabelPart","InlayHintKind","InlineValueContext","InlineValueEvaluatableExpression","InlineValueVariableLookup","InlineValueText","SemanticTokens","SemanticTokenModifiers","SemanticTokenTypes","SelectionRange","DocumentLink","FormattingOptions","CodeLens","CodeAction","CodeActionContext","CodeActionTriggerKind","CodeActionKind","DocumentSymbol","WorkspaceSymbol","SymbolInformation","SymbolTag","SymbolKind","DocumentHighlight","DocumentHighlightKind","SignatureInformation","ParameterInformation","Hover","MarkedString","CompletionList","CompletionItem","CompletionItemLabelDetails","InsertTextMode","InsertReplaceEdit","CompletionItemTag","InsertTextFormat","CompletionItemKind","MarkupContent","MarkupKind","TextDocumentItem","OptionalVersionedTextDocumentIdentifier","VersionedTextDocumentIdentifier","TextDocumentIdentifier","WorkspaceChange","WorkspaceEdit","DeleteFile","RenameFile","CreateFile","TextDocumentEdit","AnnotatedTextEdit","ChangeAnnotationIdentifier","ChangeAnnotation","TextEdit","Diagnostic","CodeDescription","DiagnosticTag","DiagnosticSeverity","DiagnosticRelatedInformation","FoldingRange","FoldingRangeKind","ColorPresentation","ColorInformation","Color","LocationLink","Location","Position","uinteger","integer","URI","DocumentUri","is","MIN_VALUE","MAX_VALUE","Is","objectLiteral","candidate","one","two","three","four","uri","targetUri","targetRange","targetSelectionRange","originSelectionRange","red","green","blue","alpha","numberRange","color","textEdit","additionalTextEdits","typedArray","Imports","Region","startCharacter","endCharacter","kind","collapsedText","defined","location","Warning","Information","Hint","Unnecessary","Deprecated","severity","relatedInformation","number","codeDescription","_i","newText","insert","needsConfirmation","description","annotation","annotationId","textDocument","edits","ignoreIfExists","oldUri","newUri","ignoreIfNotExists","changes","documentChanges","every","change","TextEditChangeImpl","changeAnnotations","edit","assertChangeAnnotations","manage","delete","add","ChangeAnnotations","annotations","_annotations","_counter","_size","configurable","idOrAnnotation","nextId","workspaceEdit","_this","_textEditChanges","_workspaceEdit","_changeAnnotations","textEditChange","initDocumentChanges","size","getTextEditChange","version","textDocumentEdit","initChanges","createFile","optionsOrAnnotation","operation","renameFile","deleteFile","languageId","PlainText","Markdown","Text","Method","Function","Constructor","Field","Class","Interface","Unit","Value","Enum","Snippet","File","Reference","Folder","EnumMember","Constant","Struct","Event","Operator","TypeParameter","asIs","adjustIndentation","detail","isIncomplete","fromPlainText","plainText","language","documentation","parameters","Read","Write","Namespace","Package","Boolean","Key","Null","containerName","selectionRange","children","deprecated","tags","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","Invoked","Automatic","diagnostics","only","triggerKind","kindOrCommandOrEdit","checkKind","isPreferred","tabSize","insertSpaces","resultId","variableName","caseSensitiveLookup","expression","frameId","stoppedLocation","Type","Parameter","tooltip","textEdits","paddingLeft","paddingRight","createSnippet","insertText","filterText","selectedCompletionInfo","FullTextDocument","lineCount","func","applyEdits","sortedEdits","mergeSort","compare","p","left","right","leftIdx","rightIdx","ret","b","diff","lastModifiedOffset","endOffset","_uri","_languageId","_version","_content","_lineOffsets","update","event","getLineOffsets","lineOffsets","isLineStart","ch","offset","low","high","mid","floor","lineOffset","nextLineOffset","check","getTextContent","isUTF8BOM","char","uintArray","Uint8Array","isNewline","findLeadingNonWhitespace","escapeChar","whitespaceCheck","escapeCheck","isInsideRange","parseHeredocName","vscode_languageserver_textdocument_1","dockerfile_1","main_1","createInstruction","lineRange","instruction","instructionRange","getParserDirectives","buffer","directives","directiveCheck","directiveStart","directiveEnd","valueStart","valueEnd","lineEnd","directiveValue","nameRange","valueRange","Dockerfile","setDirectives","getEscapeCharacter","processComment","processInstruction","organizeComments","instructionEnd","escapedInstruction","instructionCheck","processArguments","addInstruction","processHeredocs","keyword","ONBUILD","getTriggerInstruction","ADD","COPY","RUN","heredocs","getArguments","startsWith","heredoc","parseHeredoc","escaped","argumentsCheck","commentLoop","addComment","heredocName","startWord","lineStart","startPosition","__spreadArray","to","pack","ar","l","changes_1","isIncremental","getWellformedRange","addedLineOffsets","computeLineOffsets","isFull","ensureBeforeEOL","isEOL","rangeLength","isAtLineStart","textOffset","getWellformedEdit","spans","sortedEdits_1","substr","getNameRange","getValueRange","getDirective","directive","getRawArguments","getRangeContent","getInstructionRange","getInstruction","getArgumentsRange","getArgumentsRanges","ranges","extra","fullArgs","comment","getRawArgumentsContent","getArgumentsContent","documentText","found","escapedWhitespaceDetected","escaping","escapeMarker","escapedArg","getExpandedArguments","argRange","variables","parseVariables","swaps","requiresExpansion","variable","resolveVariable","expanded","variableRange","argEnd","getVariables","rawValue","parsedVariable","variableLoop","escapedString","escapedName","nameEnd","escapedSubstitutionParameter","substitutionStart","substitutionEnd","modifierRead","nameLoop","modifier","modifierRange","substitutionParameter","substitutionRange","isBuildVariable","varStart","match","FROM","initialArg","getInitialARGs","property","getProperty","image","getContainingImage","envs","getENVs","getProperties","getARGs","createSingleLineHeredocs","startRange","endFound","searchHyphen","quote","contentLoop","nameStart","getHeredocs","heredocDefinitions","heredocsProcessed","contentStart","contentEnd","currentHeredoc","delimiterRange","getDelimiterRange","contentRange","offsetLimit","startArg","candidateRange","index","endRange","getStartRange","buildVariable","stringValue","getModifier","getModifierRange","getSubstitutionParameter","getSubstitutionRange","isDefined","isEnvironmentVariable","stopSearchingForFlags","argument","openingBracket","closingBracket","jsonStrings","argsContent","argsOffset","last","quoted","argsCheck","_value","getOpeningBracket","getJSONStrings","getClosingBracket","flags","nameIndex","firstMatch","secondMatch","startIndex","nameSearchLoop","flagOption_1","hasOptions","createFlagOption","documentOffset","optionRange","FlagOption","option","getOptions","getPropertyArguments","arg2","assignmentOperatorRange","assignmentOperator","getAssignmentOperator","getAssignmentOperatorRange","getUnescapedValue","rawLoop","initial","before","skip","literal","inSingle","inDouble","commentCheck","escapedValue","parseValue","char2","newlineCheck","findTrailingNonWhitespace","instructionNameEndOffset","endingEscape","mark","argStart","spaced","argumentLoop","createSpacedArgument","singleQuotes","doubleQuotes","getFromFlag","getImage","getImageRange","getImageName","getImageNameRange","registryRange","getRegistryRange","tagRange","getImageTagRange","digestRange","getImageDigestRange","getImageTag","rangeStartOffset","atIndex","slashIndex","colonIndex","lastIndexOf","subcontent","subcolonIndex","getImageDigest","searchString","subIndex","getRegistry","rangeStart","startingSlashIndex","portIndex","dotIndex","registry","getBuildStage","getBuildStageRange","getPlatformFlag","getSubcommand","getTrigger","trigger","getTriggerWord","getTriggerRange","triggerRange","getPath","getAbsolutePath","hierarchy","getStageHierarchy","workdirs","getWORKDIRs","endsWith","ast","imageTemplate_1","ImageTemplate","initialInstructions","buildStages","foundFrom","escape","getComments","buildStage","currentBuildStage","getDirectives","getFROMs","initialARGs","resolvedVariable","getAvailableVariables","currentLine","getInstructionAt","getParentStage","templateFrom","getFROM","imageName","stages","stage","getAvailableWorkingDirectories","availableDirectories","Set","workdir","directory","comments","instructions","commentStart","commentEnd","instructionStart","getCMDs","cmds","getCOPYs","copies","getENTRYPOINTs","froms","getHEALTHCHECKs","getOnbuildTriggers","triggers","contains","logDebug","isVerboseEnabled","_asyncHooks","verboseEnabled","groupContext","AsyncLocalStorage","callCore","fallback","isActionsRuntime","GITHUB_ACTIONS","formatMessageForConsole","groupName","getStore","warn","verboseMessage","createNativeGroup","runPiped","_spawnPlease","_spawnPleaseDefault","_childProcess","_childProcessDefault","commandString","formatCommand","command1","args1","command2","args2","cp1","spawn","stdio","cp2","stdin","assertSuccess","child","cp","spawnOptions","rejectOnError","stderr","addListener","enoent","parsed","spawned","hookChildProcess","sync","spawnSync","verifyENOENTSync","status","_parse","_enoent","resolveCommand","readShebang","isWin","platform","isExecutableRegExp","isCmdShimRegExp","original","shell","parseNonShell","commandFile","detectShebang","shebang","needsShell","forceShell","needsDoubleEscapeMetaChars","normalize","shellCommand","comspec","windowsVerbatimArguments","which","getPathKey","resolveCommandAttempt","withoutPathExt","resolved","cwd","hasCustomCwd","shouldSwitchCwd","chdir","disabled","pathExt","isWindows","OSTYPE","COLON","isexe","getNotFoundError","getPathInfo","opt","colon","pathEnv","PATH","pathExtExe","PATHEXT","ppRaw","pathPart","pCmd","subStep","ii","ext","er","cur","ex","nothrow","core","ignoreErrors","TESTING_WINDOWS","checkStat","statSync","stat","isSymbolicLink","isFile","pathext","myUid","myGid","u","g","mode","getuid","getgid","pathKey","environment","reverse","find","metaCharsRegExp","doubleEscapeMetaChars","shebangCommand","fd","openSync","readSync","closeSync","shebangRegex","binary","pop","notFoundError","syscall","errno","spawnargs","verifyENOENT","originalEmit","arg1","extractCachesBatch","cacheEntries","copyCommands","cacheId","findIndex","sourcePath","dirname","cleanupError","rename","parcelRequire86b4"],"version":3,"file":"index.js.map","sourceRoot":"../"}